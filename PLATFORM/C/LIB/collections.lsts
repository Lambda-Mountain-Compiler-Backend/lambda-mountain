
interface Collection<t> {
   let .length(self: Collection<t>): U64;
   let $"[]"(self: Collection<t>, idx: U64): t;
};

interface Iterator<t> {
   let .next(self: Iterator<t>[]): Maybe<t>;
};

interface Iterable<t> {
   let .iter(): Iterator<t>;
   let .unsafe-iter(): Iterator<t>;
};

type ZipIterator<ai+Iterator<at>, bi+Iterator<bt>> = ZipIterator { aii: ai, bii: bi };

let .next(p: ZipIterator<ai+Iterator<at>, bi+Iterator<bt>>[]): Maybe<Tuple<at,bt>> = (
   let v = open(p);
   let av = (&v.aii).next();
   let bv = (&v.bii).next();

   let res = if av.is-some() && bv.is-some() {
      Some { Tuple { av.get-or-panic(), bv.get-or-panic() } } :: Maybe<Tuple<at,bt>>
   } else {
      None :: Maybe<Tuple<at,bt>>
   };

   p[0] = v;

   res
);

let .zip(ai+Iterator<at>, bi+Iterator<bt>): ZipIterator<ai,bi> = (
   ZipIterator { ai, bi }
);

type EnumerateIterator<i+Iterator<t>> = EnumerateIterator { ii: i, idx: U64 };

let .next(p: EnumerateIterator<i+Iterator<t>>[]): Maybe<Tuple<U64, i>> = (
   let v = open(p);
   let iv = (&v.ii).next();

   let res = match iv {
      Some { content=content } => (
         let oldv = v.idx;
         v.idx = v.idx + 1;
         Some { Tuple { oldv, content } } :: Maybe<Tuple<at,bt>>
      );

      None {} => (
         None :: Maybe<Tuple<at,bt>>
      );
   };

   p[0] = v;

   res
);

let .enumerate(i+Iterator<t>): EnumerateIterator<i> = (
   EnumerateIterator { i, 0_u64 }
);

let cmp(ls: Collection<a>, rs: Collection<b>): Ord = (
   let diff = Equal;

   let lslen = ls.length();
   let rslen = rs.length();

   let li = 0_u64;
   let ri = 0_u64;

   while is(diff, Equal) && li < lslen && ri < rslen {
      diff = cmp(ls[li], rs[ri]);
      li = li + 1;
      ri = ri + 1;
   };
   if not(is(diff,Equal)) then diff else
   if li == lslen && ri != rslen then LessThan else
   if li != lslen && ri == rslen then GreaterThan else
   Equal
);

let .contains(self: Iterable<t>, value: t): U64 = (
   let ok = false;
   for x in self.unsafe-iter() {
      if x == value {
         ok = true;
      };
   };
   ok
);

let .join(self: Iterable<t>, sep: String, prefix: String, suffix: String): String = (
   let out = prefix;
   for iv in self.unsafe-iter().enumerate() {
      if iv.first != 0 {
         out = out + sep;
      };
      out = out + to-smart-string(iv.second);
   };
   if suffix.length() > 0 {
      out = out + suffix;
   };
   out
);

let .join(self: Iterable<t>, sep: String): String = (
   self.join(sep, "", "")
);

# should not be used
let .join(self: Iterable<t>, sep: CString): CString = (
   untern(self.join(intern(sep), "", ""))
);

let to-smart-string(ls: Iterable<t>): String = (
   ls.join(", ", "[", "]")
);

# TODO: use iterators in the following two functions

let .find-first(list: Collection<t>, elem: e): Maybe<U64> = (
   let found = false;

   let i = 0_u64;
   let where = 0_u64;
   let len = list.length();
   while i < len {
      if list[i] == elem {
         found = true;
         where = i;
         i = len; # break
      } else {
         i = i + 1;
      };
   };

   if found {
      Some{where}
   } else {
      None{} :: Maybe<U64>
   }
);

let .find-last(list: Collection<t>, elem: e): Maybe<U64> = (
   let found = false;
   let found_idx = 0_u64;

   let i = 0_u64;
   let len = list.length();
   while i < len {
      if list[i] == elem {
         found = true;
         found_idx = i;
      };
      i = i + 1;
   };

   if found {
      Some{found_idx}
   } else {
      None{} :: Maybe<U64>
   }
);

let .repeat(self: Iterable<t>, times: U64): Vector<t> = (
   let out = mk-vector(type(t), times);
   while times > 0 {
      for x in self {
         out = out.push(x);
      }
      times = times - 1;
   };
   out
);
