
interface Collection<t> {
   let .length(self: Collection<t>): U64;
   let $"[]"(self: Collection<t>, idx: U64): t;
}

interface Iterator<t> {
   let .next(self: Iterator<t>[]): Maybe<t>;
}

interface Iterable<t> {
   let .iter(self: Iterable<t>): Iterator<t>;
   let .unsafe-iter(self: Iterable<t>): Iterator<t>;
}

interface IteratorRemaining {
   let .remaining(self: IteratorRemaining+Iterator<t>): U64;
}

let remaining-or-zero(from: Iterator<t>): U64 = (
   0
);

let remaining-or-zero(from: Iterator<t>+IteratorRemaining): U64 = (
   from.remaining()
);

let .last(self: Collection<t>): t = (
   let ln = self.length();
   if ln == 0 {
      fail("cannot get .last() from empty element");
   };
   self[(ln-1)]
);

let length-or-zero(from: Iterable<t>): U64 = (
   0_u64
);

let length-or-zero(from: Collection<t>): U64 = (
   from.length()
);

let remaining-eq(a: Iterator<at>, b: Iterator<bt>): U64 = (
   let ok = true;
   while ok {
      let av = (&a).next();
      let bv = (&b).next();
      if av != bv {
         ok = false;
      };
   };
   ok
);

let .skip(self: Iterator<t>, num: U64): Iterator<t> = (
   while num > 0 {
      (&self).next();
      num = num - 1;
   };
   self
);

type RangeIter = RangeIter { i: U64, len: U64, step: U64 };
type RangeIter => Iterable<U64>;
type RangeIter => IteratorRemaining;

let .remaining(self: RangeIter): U64 = (
   (self.len - self.i) / self.step
);

let .next(vp: RangeIter[]): Maybe<U64> = (
   let v = open(vp);
   let res = if v.i < v.len {
      let idx = v.i;
      vp.i = v.i + v.step;
      Some { idx }
   } else {
      None :: Maybe<U64>
   };
   vp[0] = v;
   res
);

let range(len: U64, step: U64): RangeIter = (
   RangeIter { 0, len, step }
);

let range(len: U64): RangeIter = (
   range(len, 1)
);

type SkipIterator<i+Iterator<t>> = SkipIterator { ii: i, to_skip: U64 };
type SkipIterator<i+Iterator<t>> => Iterator<t>;
type SkipIterator<i+Iterator<t>+IteratorRemaining> => IteratorRemaining;

let .remaining(self: SkipIterator<i+Iterator<t>+IteratorRemaining>): U64 = (
   self.ii.remaining() - self.to_skip
);

let .skip(iter: i+Iterator<t>, amount: U64): SkipIterator<i> = (
   SkipIterator { iter.ii, iter.to_skip + amount }
);

let .next(vp: SkipIterator<i+Iterator<t>>[]): Maybe<t> = (
   let v = open(vp);
   if v.to_skip > 0 {
      v.ii = v.ii.skip(v.to_skip);
      v.to_skip = 0;
   };
   let val = (&v.ii).next();
   vp[0] = v;
   val
);

type LimitIterator<i+Iterator<t>> = LimitIterator { ii: i, idx: U64, limit: U64 };
type LimitIterator<Iterator<t>> => Iterator<t>;
type LimitIterator<Iterator<t>> => IteratorRemaining;

let .remaining(self: LimitIterator<t>): U64 = (
   self.limit - self.idx
);

let .next(vp: LimitIterator<i+Iterator<t>>[]): Maybe<t> = (
   let v = open(vp);
   let val = if v.idx < v.limit {
      v.idx = v.idx + 1;
      (&v.ii).next()
   } else {
      None :: Maybe<t>
   };
   vp[0] = v;
   val
);

# the resulting iter has at most <amount> elements
let .limit(iter: i+Iterator<t>, amount: U64): LimitIterator<i> = (
   LimitIterator { iter, 0, amount }
);

type ZipIterator<ai+Iterator<at>, bi+Iterator<bt>> = ZipIterator { aii: ai, bii: bi };
type ZipIterator<Iterator<at>, Iterator<bt>> => Iterator<Tuple<at,bt>>;
type ZipIterator<Iterator<at>+IteratorRemaining, Iterator<bt>+IteratorRemaining> => IteratorRemaining;

let .remaining(self: ZipIterator<Iterator<at>+IteratorRemaining, Iterator<bt>+IteratorRemaining>): U64 = (
   min(self.aii.remaining(), self.bii.remaining())
);

let .next(p: ZipIterator<ai+Iterator<at>, bi+Iterator<bt>>[]): Maybe<Tuple<at,bt>> = (
   let v = open(p);
   let av = (&v.aii).next();
   let bv = (&v.bii).next();

   let res = if av.is-some() && bv.is-some() {
      Some { Tuple { av.get-or-panic(), bv.get-or-panic() } } :: Maybe<Tuple<at,bt>>
   } else {
      None :: Maybe<Tuple<at,bt>>
   };

   p[0] = v;

   res
);

let .zip(ai: Iterator<at>, bi: Iterator<bt>): ZipIterator<ai,bi> = (
   ZipIterator { ai, bi }
);

type EnumerateIterator<i+Iterator<t>> = EnumerateIterator { ii: i, idx: U64 };
type EnumerateIterator<Iterator<t>> => Iterator<Tuple<U64,t>>;
type EnumerateIterator<Iterator<t>+IteratorRemaining> => IteratorRemaining;

let .remaining(self: EnumerateIterator<Iterator<t>+IteratorRemaining>): U64 = (
   self.ii.remaining()
);

let .next(p: EnumerateIterator<i+Iterator<t>>[]): Maybe<Tuple<U64, t>> = (
   let v = open(p);
   let iv = (&v.ii).next();

   let res = match iv {
      Some { content=content } => (
         let oldv = v.idx;
         v.idx = v.idx + 1;
         Some { Tuple { oldv, content } } :: Maybe<Tuple<at,bt>>
      );

      None {} => (
         None :: Maybe<Tuple<at,bt>>
      );
   };

   p[0] = v;

   res
);

let .enumerate(i: Iterator<t>): EnumerateIterator<i> = (
   EnumerateIterator { i, 0_u64 }
);

type CollectionIteratorBase<c+Collection<t>> = CollectionIteratorBase { coll: c, idx: U64 };
type CollectionIteratorBase<Collection<t>> => Iterator<t>;
type CollectionIteratorBase<Collection<t>> => IteratorRemaining;

let .remaining(self: CollectionIteratorBase<c+Collection<t>>): U64 = (
   self.coll.length() - self.idx
);

let .skip(self: CollectionIteratorBase<c>, num: U64): CollectionIteratorBase<c> = (
   CollectionIteratorBase { self.coll, self.idx + num }
);

let .next(p: CollectionIteratorBase<Collection<t>>[]): Maybe<t> = (
   let v = p[0];
   if v.idx < v.coll.length() {
      let val = v.coll[v.idx];
      v.idx = v.idx + 1;
      p[0] = v;
      Some { val } :: Maybe<t>
   } else {
      None :: Maybe<t>
   }
);

let cmp(ls: Collection<a>, rs: Collection<b>): Ord = (
   let diff = Equal;

   let lslen = ls.length();
   let rslen = rs.length();

   let li = 0_u64;
   let ri = 0_u64;

   while is(diff, Equal) && li < lslen && ri < rslen {
      diff = cmp(ls[li], rs[ri]);
      li = li + 1;
      ri = ri + 1;
   };
   if not(is(diff,Equal)) then diff else
   if li == lslen && ri != rslen then LessThan else
   if li != lslen && ri == rslen then GreaterThan else
   Equal
);

let .contains(self: Iterable<t>, value: t): U64 = (
   let ok = false;
   for x in self.unsafe-iter() {
      if x == value {
         ok = true;
      };
   };
   ok
);

let .has-prefix-at(self: Iterable<t>, off: U64, seq: Iterable<t>): U64 = (
   if (self.length() - off) < seq.length() {
      false
   } else {
      let ok = true;
      for pair in self.unsafe-iter().skip(off).zip(seq.unsafe-iter()) {
         if pair.first != pair.second {
            ok = false;
         };
      };
      ok
   }
);

let .has-prefix(self: Iterable<t>, seq: Iterable<t>): U64 = (
   self.has-prefix-at(0, seq);
);

let .has-suffix(self: Iterable<t>+Collection<t>, seq: Iterable<t>+Collection<t>): U64 = (
   if seq.length() > self.length() {
      false
   } else {
      remaining-eq(self.unsafe-iter().skip(self.length() - seq.length()), seq.unsafe-iter())
   };
);

let .find-first(self: Iterable<t>, seq: Iterable<t>): Maybe<U64> = (
   let found = false;
   let i = 0_u64;
   while i < self.length() && not(found) {
      if self.has-prefix-at(i, seq) {
         found = true;
      } else {
         i = i + 1;
      };
   };
   if found {
      Some { i }
   } else {
      None {} :: Maybe<U64>
   };
);

let .contains(self: Iterable<t>, seq: Iterable<t>): U64 = (
   self.find-first(seq).is-some()
);

let .join(self: Iterable<t>, sep: String, prefix: String, suffix: String): String = (
   let out = prefix;
   for iv in self.unsafe-iter().enumerate() {
      if iv.first != 0 {
         out = out + sep;
      };
      out = out + to-smart-string(iv.second);
   };
   if suffix.length() > 0 {
      out = out + suffix;
   };
   out
);

let .join(self: Iterable<t>, sep: String): String = (
   self.join(sep, "", "")
);

# should not be used
let .join(self: Iterable<t>, sep: CString): CString = (
   untern(self.join(intern(sep), "", ""))
);

let to-smart-string(ls: Iterable<t>): String = (
   ls.join(", ", "[", "]")
);

# TODO: use iterators in the following 3 functions

let .find-first(list: Collection<t>, elem: e): Maybe<U64> = (
   let found = false;

   let i = 0_u64;
   let where = 0_u64;
   let len = list.length();
   while i < len {
      if list[i] == elem {
         found = true;
         where = i;
         i = len; # break
      } else {
         i = i + 1;
      };
   };

   if found {
      Some{where}
   } else {
      None{} :: Maybe<U64>
   }
);

let .find-first-with-indent(list: Collection<t>, elem: e, up: Collection<uv>, down: Collection<dv>): Maybe<U64> = (
   let found = false;

   let ind = 0_u64;
   let i = 0_u64;
   let where = 0_u64;
   let len = list.length();
   while i < len {
      if up.contains(list[i]) {
         ind = ind + 1;
         i = i + 1;
      } else {
         if down.contains(list[i]) {
            if ind == 0 {
               fail("unopened parentheses");
            };
            ind = ind - 1;
            i = i + 1;
         } else {
            match list[i] {
               elem => (
                  if ind == 0 {
                     found = true;
                     where = i;
                     i = len; # break
                  } else {
                     i = i + 1;
                  };
               );
      
               other => (
                  i = i + 1;
               );
            };
         };
      };
   };

   if ind != 0_u64 {
      fail("unclosed parentheses");
   };

   if found {
      Some{where}
   } else {
      None{} :: Maybe<U64>
   }
);

let .collect(x: Iterator<t>): Vector<t> = (
   x.collect(type(Vector<t>))
);

type UniqueIter<t,i+Iterator<t>> = UniqueIter { set: Hashset<t>, ii: i };
type UniqueIter<t,i> => Iterator<t>;

let .next(vp: UniqueIter<t,i>[]): Maybe<t> = (
   let v = open(vp);

   let out = None {} :: Maybe<t>;
   let loop = true;
   while loop {
      let val = (&v.ii).next();
      match val {
         Some { content=content } => (
            (v.set, let nok) = v.set.contains-or-put(content);
            if nok {
               loop = false;
               out = Some { content };
            };
         );

         None {} => (
            loop = false;
         );
      };
   };

   vp[0] = v; 
   out
);

let .unique(self: i+Iterator<t>): UniqueIter<t,i> = (
   UniqueIter { mk-hashset(type(t)), self }
);

type SplitWithIndentIter<t,sp,uv,dv> = SplitWithIndentIter { data: Vector<t>, split: sp, up: Vector<uv>, down: Vector<dv> };
type SplitWithIndentIter<t,sp,uv,dv> => Iterator<Vector<t>>;

let .next(vp: SplitWithIndentIter<t,sp,uv,dv>[]): Maybe<Vector<t>> = (
   let v = open(vp);

   if v.data.length() > 0 {
      let idx-of-sep = v.data.find-first-with-indent(v.split, v.up, v.down);
      let val = match idx-of-sep {
         Some { content=content } => (
            let r = vp.data.unsafe-iter().limit(content).collect();
            vp.data = vp.data.remove-front(content+1);
            r
         );

         None {} => (
            let t = vp.data;
            vp.data = mk-vector(type(t), 0);
            t
         );
      };
      vp[0] = v;
      val
   } else {
      None {} :: Maybe<Vector<t>>
   }
);

let split-with-indent(self: Collection<t>, split: sp, up: Collection<uv>, down: Collection<dv>): SplitWithIndentIter<t,sp,uv,dv> = (
   SplitWithIndentIter { self.unsafe-iter().collect(), split, up.unsafe-iter().collect(), down.unsafe-iter().collect() }
);

let .find-last(list: Collection<t>, elem: e): Maybe<U64> = (
   let found = false;
   let found_idx = 0_u64;

   let i = 0_u64;
   let len = list.length();
   while i < len {
      if list[i] == elem {
         found = true;
         found_idx = i;
      };
      i = i + 1;
   };

   if found {
      Some{found_idx}
   } else {
      None{} :: Maybe<U64>
   }
);

let .repeat(self: Iterable<t>, times: U64): Vector<t> = (
   let out = mk-vector(type(t), times);
   while times > 0 {
      for x in self {
         out = out.push(x);
      };
      times = times - 1;
   };
   out
);

let .to-vector(l: Iterable<t>): Vector<t> = (
   let v = mk-vector(type(t), 0);
   v = v.push-all(l);
   v
);

let concat-to-vector( vl: Iterable<t>, vr: Iterable<t> ): t = (
   let v = mk-vector(type(t), 0);

   for x in vl.unsafe-iter() {
      v = v.push(x);
   };

   for x in vr.unsafe-iter() {
      v = v.push(x);
   };

   v
);

let .pad-left(self: Collection<t>, value: t, minlen: U64): Vector<t> = (
   if self.length() > minlen {
      minlen = self.length();
   };

   let out = mk-vector(type(t), minlen);

   let i = 0_u64;
   while i < (minlen - self.length()) {
      out = out.push(value);
   };

   i = 0_u64;
   while i < self.length() {
      out = out.push(self[i]);
   };

   out
);

let .pad-right(self: Iterable<t>, value: t, minlen: U64): Vector<t> = (
   if self.length() > minlen {
      minlen = self.length();
   };

   let out = mk-vector(type(t), minlen);

   let i = 0_u64;
   while i < self.length() {
      out = out.push(self[i]);
   };

   i = 0_u64;
   while i < (minlen - self.length()) {
      out = out.push(value);
   };

   out
);

# TODO: OnceIterable (from iterator)
