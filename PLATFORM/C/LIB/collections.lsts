
interface Collection<t> {
   let .length(self: Collection<t>): U64;
   let $"[]"(self: Collection<t>, idx: U64): t;
};

interface Iterator<t> {
   let .next(self: Iterator<t>[]): Maybe<t>;
};

interface Iterable<t> {
   let .iter(): Iterator<t>;
   let .unsafe-iter(): Iterator<t>;
};

interface FromVector<t> {
   let .move-to(self: Vector<t>, out: Type<FromVector<t>>): FromVector<t>;
};

let remaining-eq(a: Iterator<at>, b: Iterator<bt>): U64 = (
   let ok = true;
   while ok {
      let av = (&a).next();
      let bv = (&b).next();
      if av != bv {
         ok = false;
      };
   };
   ok
);

let .skip(self: Iterator<t>, num: U64): Iterator<t> = (
   while num > 0 {
      (&self).next();
      num = num - 1;
   };
   self
);

type SkipIterator<i+Iterator<t>> = SkipIterator { ii: i, to_skip: U64 };

let .skip(iter: SkipIterator<i>, amount: U64): SkipIterator<i> = (
   SkipIterator { iter.ii, iter.to_skip + amount }
);

let .next(vp: SkipIterator<i+Iterator<t>>[]): Maybe<t> = (
   let v = open(vp);
   if v.to_skip > 0 {
      v.ii = v.ii.skip(v.to_skip);
      v.to_skip = 0;
   };
   let val = (&v.ii).next();
   vp[0] = v;
   val
);

type ZipIterator<ai+Iterator<at>, bi+Iterator<bt>> = ZipIterator { aii: ai, bii: bi };

let .next(p: ZipIterator<ai+Iterator<at>, bi+Iterator<bt>>[]): Maybe<Tuple<at,bt>> = (
   let v = open(p);
   let av = (&v.aii).next();
   let bv = (&v.bii).next();

   let res = if av.is-some() && bv.is-some() {
      Some { Tuple { av.get-or-panic(), bv.get-or-panic() } } :: Maybe<Tuple<at,bt>>
   } else {
      None :: Maybe<Tuple<at,bt>>
   };

   p[0] = v;

   res
);

let .zip(ai+Iterator<at>, bi+Iterator<bt>): ZipIterator<ai,bi> = (
   ZipIterator { ai, bi }
);

type EnumerateIterator<i+Iterator<t>> = EnumerateIterator { ii: i, idx: U64 };

let .next(p: EnumerateIterator<i+Iterator<t>>[]): Maybe<Tuple<U64, i>> = (
   let v = open(p);
   let iv = (&v.ii).next();

   let res = match iv {
      Some { content=content } => (
         let oldv = v.idx;
         v.idx = v.idx + 1;
         Some { Tuple { oldv, content } } :: Maybe<Tuple<at,bt>>
      );

      None {} => (
         None :: Maybe<Tuple<at,bt>>
      );
   };

   p[0] = v;

   res
);

let .enumerate(i+Iterator<t>): EnumerateIterator<i> = (
   EnumerateIterator { i, 0_u64 }
);

let cmp(ls: Collection<a>, rs: Collection<b>): Ord = (
   let diff = Equal;

   let lslen = ls.length();
   let rslen = rs.length();

   let li = 0_u64;
   let ri = 0_u64;

   while is(diff, Equal) && li < lslen && ri < rslen {
      diff = cmp(ls[li], rs[ri]);
      li = li + 1;
      ri = ri + 1;
   };
   if not(is(diff,Equal)) then diff else
   if li == lslen && ri != rslen then LessThan else
   if li != lslen && ri == rslen then GreaterThan else
   Equal
);

let .contains(self: Iterable<t>, value: t): U64 = (
   let ok = false;
   for x in self.unsafe-iter() {
      if x == value {
         ok = true;
      };
   };
   ok
);

# TODO: generic Collection<t> impl for Iterable<t>

let .has-prefix-at(self: Iterable<t>, off: U64, seq: Iterable<t>): Bool = (
   if (self.length() - off) < seq.length() {
      false
   } else {
      let ok = true;
      for pair in self.unsafe-iter().skip(off).zip(seq.unsafe-iter()) {
         if pair.first != pair.second {
            ok = false;
         };
      };
      ok
   }
);

let .has-prefix(self: Iterable<t>, seq: Iterable<t>): Bool = (
   self.has-prefix-at(0, seq);
);

let .has-suffix(self: Iterable<t>, seq: Iterable<t>): Bool = (
   if seq.length() > self.length() {
      false
   } else {
      remaining-eq(self.unsafe-iter().skip(self.length() - seq.length()), seq.unsafe-iter())
   };
);

let .find-first(self: Iterable<t>, seq: Iterable<t>): Maybe<U64> = (
   let found = false;
   let i = 0_u64;
   while i < self.length() && not(found) {
      if self.has-prefix-at(i, seq) {
         found = true;
      } else {
         i = i + 1;
      };
   };
   if found {
      Some { i }
   } else {
      None {} :: Maybe<U64>
   };
);

let .contains(self: Iterable<t>, seq: Iterable<t>): U64 = (
   self.find-first(seq).is-some()
);

let .join(self: Iterable<t>, sep: String, prefix: String, suffix: String): String = (
   let out = prefix;
   for iv in self.unsafe-iter().enumerate() {
      if iv.first != 0 {
         out = out + sep;
      };
      out = out + to-smart-string(iv.second);
   };
   if suffix.length() > 0 {
      out = out + suffix;
   };
   out
);

let .join(self: Iterable<t>, sep: String): String = (
   self.join(sep, "", "")
);

# should not be used
let .join(self: Iterable<t>, sep: CString): CString = (
   untern(self.join(intern(sep), "", ""))
);

let to-smart-string(ls: Iterable<t>): String = (
   ls.join(", ", "[", "]")
);

# TODO: use iterators in the following two functions

let .find-first(list: Collection<t>, elem: e): Maybe<U64> = (
   let found = false;

   let i = 0_u64;
   let where = 0_u64;
   let len = list.length();
   while i < len {
      if list[i] == elem {
         found = true;
         where = i;
         i = len; # break
      } else {
         i = i + 1;
      };
   };

   if found {
      Some{where}
   } else {
      None{} :: Maybe<U64>
   }
);

let .find-last(list: Collection<t>, elem: e): Maybe<U64> = (
   let found = false;
   let found_idx = 0_u64;

   let i = 0_u64;
   let len = list.length();
   while i < len {
      if list[i] == elem {
         found = true;
         found_idx = i;
      };
      i = i + 1;
   };

   if found {
      Some{found_idx}
   } else {
      None{} :: Maybe<U64>
   }
);

let .repeat(self: Iterable<t>, times: U64): Vector<t> = (
   let out = mk-vector(type(t), times);
   while times > 0 {
      for x in self {
         out = out.push(x);
      }
      times = times - 1;
   };
   out
);

let .to-vector(l: Iterable<t>): Vector<t> = (
   let v = mk-vector(type(t), 0);
   v = v.push-all(l);
   v
);

let concat-to-vector( vl: Iterable<t>, vr: Iterable<t> ): t = (
   let v = mk-vector(type(t), 0);

   for x in vl.unsafe-iter() {
      v = v.push(x);
   };

   for x in vr.unsafe-iter() {
      v = v.push(x);
   };

   v
);

let .pad-left(self: Collection<t>, value: t, minlen: U64): Vector<t> = (
   if self.length() > minlen {
      minlen = self.length();
   };

   let out = mk-vector(type(t), minlen);

   let i = 0_u64;
   while i < (minlen - self.length()) {
      out = out.push(value);
   };

   i = 0_u64;
   while i < self.length() {
      out = out.push(self[i]);
   };

   out
);

let .pad-right(self: Iterable<t>, value: t, minlen: U64): Vector<t> = (
   if self.length() > minlen {
      minlen = self.length();
   };

   let out = mk-vector(type(t), minlen);

   let i = 0_u64;
   while i < self.length() {
      out = out.push(self[i]);
   };

   i = 0_u64;
   while i < (minlen - self.length()) {
      out = out.push(value);
   };

   out
);
