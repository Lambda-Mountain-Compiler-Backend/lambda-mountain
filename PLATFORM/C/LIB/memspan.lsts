## MemSpan represents a re-allocatable, contiguous, mutable, owned memory block.
## It provides a safe interface to libc's realloc and handles ownership of inner elements.
type MemSpan<t> = MemSpan { data: t[], length: U32 };

let mk-memspan(type: Type<t>, size: U64): MemSpan<t> = (
   let ptr = if (size == 0_u64) then (0_u64 as t[]) else (safe-alloc(size, type(t)));
   MemSpan { ptr, size as U32 }
);

let mk-memspan(ty: Type<t>): MemSpan<t> = (
   mk-memspan(ty, 0_u64)
);

## Reallocates the memory to the target size
## Does not destroy old elements
let .realloc(span: MemSpan<t>, target-size: U64): MemSpan<t> = (
   let newp = if (target-size == 0_u64) then (0_u64 as t[]) else (safe-realloc(span.data, target-size, type(t)));
   MemSpan { newp, target-size as U32 }
);

## Get element at index
let $"[]"(span: MemSpan<t>, i: U64): t = (
   if i >= (span.length as U64) {
      fail("MemSpan Index Out of Bounds");
   };
   span.data[i]
);

## Set element at index
let $"set[]"(span: MemSpan<t>, i: U64, val: t): Nil = (
   if i >= (span.length as U64) {
      fail("MemSpan Index Out of Bounds");
   };
   span.data[i] = val;
   ()
);

## Get the size of the span
let .length(span: MemSpan<t>): U64 = (
   span.length as U64
);