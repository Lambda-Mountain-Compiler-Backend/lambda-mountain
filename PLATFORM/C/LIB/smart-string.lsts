
type SmartString => Collection<U8>;
type SmartString => Iterable<U8>;

let .iter(self: SmartString): CollectionIteratorBase<SmartString> = (
   CollectionIteratorBase { self, 0_u64 }
);

let .unsafe-iter(self: SmartString): CollectionIteratorBase<SmartString> = (
   self.iter()
);

let cmp(l: CString, r: String): Ord = (
   cmp( intern(l), r )
);
let $"=="(l: CString, r: String): U64 = cmp(l, r) == Equal;
let $"!="(l: CString, r: String): U64 = cmp(l, r) != Equal;
let $"<"(l: CString, r: String): U64 = cmp(l, r)  <  Equal;
let $"<="(l: CString, r: String): U64 = cmp(l, r) <= Equal;
let $">"(l: CString, r: String): U64 = cmp(l, r)  >  Equal;
let $">="(l: CString, r: String): U64 = cmp(l, r) >= Equal;

let cmp(l: String, r: CString): Ord = (
   cmp( l, intern(r) )
);
let $"=="(l: String, r: CString): U64 = cmp(l, r) == Equal;
let $"!="(l: String, r: CString): U64 = cmp(l, r) != Equal;
let $"<"(l: String, r: CString): U64 = cmp(l, r)  <  Equal;
let $"<="(l: String, r: CString): U64 = cmp(l, r) <= Equal;
let $">"(l: String, r: CString): U64 = cmp(l, r)  >  Equal;
let $">="(l: String, r: CString): U64 = cmp(l, r) >= Equal;

let cmp(x: String, y: String): Ord = (
   let r = Equal;
   if not(is( x, y )) {
      let x-start = x.start;
      let y-start = y.start;
      while x-start < x.end && y-start < y.end {
         if x-start[0_u64] < y-start[0_u64] {
            r = LessThan;
            x-start = x.end;
            y-start = y.end;
         } else if x-start[0_u64] > y-start[0_u64] {
            r = GreaterThan;
            x-start = x.end;
            y-start = y.end;
         } else {
            x-start = x-start + 1_u64;
            y-start = y-start + 1_u64;
         }
      };
      if x-start < x.end { r = GreaterThan };
      if y-start < y.end { r = LessThan };
   };
   r
);

let print(io: IO::File, x: SmartString): Nil = (
   let start = x.start;
   while start != x.end {
      fwrite(start, 1_u64, 1_u64, stdout());
      start = start + 1_u64;
   };
);

let .pad-left-str(self: String, value: U8, minlen: U64): String = (
   self.pad-left(value, minlen).move-to(type(String))
);

let .pad-right-str(self: String, value: U8, minlen: U64): String = (
   self.pad-right(value, minlen).move-to(type(String))
);

let .count-left-spaces(self: String): U64 = (
   let num = 0_u64;

   let i = 0_u64;
   while i < self.length() {
      if self[i].is-space() {
         num = num + 1;
      } else {
         i = self.length(); # break
      };
      i = i + 1;
   };

   num
);

let .count-right-spaces(self: String): U64 = (
   self.length() - self.trim-right().length()
);

let .trim-right(self: String): String = (
   while self.length() > 0 && self.last().is-space() {
      let l = self.length() - 1;
      self = self[:l];
   };
   self
);

let .trim-left(self: String): String = (
   let n = self.count-left-spaces();
   self[n:]
);

let .trim(self: String): String = (
   self.trim-left().trim-right()
);
