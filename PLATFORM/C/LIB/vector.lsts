
type Vector<t> = Vector { data: t[], length: U64, capacity: U64 };

let mk-vector(type: Type<t>, capacity: U64): Vector<t> = (
   let data-sz = sizeof(t) * capacity;
   Vector { (malloc(data-sz) as t[]), 0_u64, capacity }
);

let fill-vector(value: t, len: U64): Vector<t> = (
   let v = mk-vector(type(t), len);
   while len > 0 {
      v[len-1] = value;
      len = len - 1;
   };
   v
);

# does not change length!
let .realloc(v: Vector<t>, target-capacity: U64): Vector<t> = (
   let data-sz = sizeof(t) * target-capacity;
   let newp = realloc(v.data as ?[], data-sz) as t[];
   Vector { newp, v.length, target-capacity }
);

let .push(v: Vector<t>, i: t): Vector<t> = (
   if v.length >= v.capacity {
      let new-cap = if v.capacity == 0 {
         4
      } else { # mul 1.5
         (v.capacity << 1) + v.capacity
      };
      v = v.realloc(new-cap);
   };
   v.data[v.length] = i;
   v.length = v.length + 1_u64;
   v
);

# shrinks the vector if it has way too many elements. shouldn't be called manually
let .shrink(v: Vector<t>): Vector<t> = (
    let too-much = v.capacity - v.length;
    let minimum = (v.length << 1) + v.length; # mul 1.5
    if too-much > minimum {
       v = v.realloc(minimum);
    };
    v
);

let .remove-front(v: Vector<t>, num: U64): Vector<t> = (
    if num > v.length() {
        fail("tried to remove \{num} elements from vector, but only have \{v.length()}");
    };

    let i = num;
    while i < v.length() {
        v[i-num] = v[i];
        i = i + 1;
    };
    v.length = v.length - num;

    v.shrink();
);

let .remove-back(v: Vector<t>, num: U64): Vector<t> = (
    if num > v.length() {
        fail("tried to remove \{num} elements from vector, but only have \{v.length()}");
    };

    v.length = v.length - num;

    v.shrink();
);

let .pop(v: Vector<t>): Tuple<Vector<t>, t> = (
    if v.length() == 0 {
        fail("Tried to pop from empty Vector.");
    };

    let lasti = v.length - 1;
    let last = v[lasti];
    v = v.remove-back(1);

    Tuple { v, last }
);

let .to-vector(l: List<t>): Vector<t> = (
   let v = mk-vector(type(t), l.length);
   for i in l {
      v = v.push(i);
   };
   v
);

let $"[]"( v: Vector<t>, i: U64 ): t = (
   if i >= v.length {
      fail("Vector Index Out of Bounds");
   };
   v.data[i]
);

let $"+"( vl: Vector<t>, vr: Vector<t> ): t = (
   let v = mk-vector(type(t), vl.length + vr.length);

   for x in vl.unsafe-iter() {
      v = v.push(x);
   };

   for x in vr.unsafe-iter() {
      v = v.push(x);
   };

   v
);

let $"set[]"( v: Vector<t>, i: U64, val: t ): Nil = (
   if i >= v.length {
      fail("Vector Index Out of Bounds");
   };
   v.data[i] = val; 
   ()
);

type VectorIter<t> = VectorIter { vec: Vector<t>, idx: U64 };

# for safety, we clone the vector
# All modifications done to the vector after creating the iterator will not be seen
let .iter(v: Vector<t>): VectorIter<t> = (
   let clone = mk-vector(type(t), v.length);
   let i = 0_u64;
   while i < v.length {
      clone = clone.push(v[i]);
      i = i + 1;
   };

   clone.unsafe-iter()
);

# If you modify the vector after creating the iterator, weird things will happen
let .unsafe-iter(v: Vector<t>): VectorIter<t> = (
   VectorIter { v, 0_u64 }
);

let .next(p: Array<VectorIter<t>,?>): Maybe<t> = (
   let v = p[0];
   if v.idx < v.vec.length {
      let val = v.vec[v.idx];
      v.idx = v.idx + 1;
      p[0] = v;
      Some { val } :: Maybe<t>
   } else {
      None :: Maybe<t>
   }
);

let .sort(v: Vector<t>): Vector<t> = (
   let n = v.length;
   let i = 0_u64;
   while i < n - 1_u64 {
      let swapped = 0;
      let j = 0;
      while j < n - i - 1_u64 {
         if v[j + 1_u64] < v[j] {
            let tmp = v[j];
            v[j] = v[j + 1_u64];
            v[j + 1_u64] = tmp;
            swapped = 1;
         };
         j = j + 1_u64;
      };
      i = i + 1_u64;
      if not(swapped) {
         i = n;
      };
   };
   v
);

let print(v: Vector<x>): Nil = (
   print(untern(to-smart-string(v)));
);

# MAKES INPUT VECTOR INVALID
let .move-to-cstring(self: Vector<U8>): CString = (
   self = self.push(0_u8);
   (self.data as U8[]) as CString
);

# MAKES INPUT VECTOR INVALID
let .move-to-smart-string(self: Vector<U8>): SmartString = (
   intern(self.move-to-cstring())
);

let .as-cstring(self: Vector<U8>): CString = (
   let cpy = malloc(self.length + 1) as U8[];

   let i = 0_u64;
   while i < self.length {
      cpy[i] = self.data[i];
      i = i + 1;
   };
   cpy[i] = 0_u8;

   cpy as CString
);

let .as-smart-string(self: Vector<U8>): SmartString = (
   intern(self.as-cstring());
);
