
## Preferred over [type(List<t>)] for all use cases. Provides O(1) append/remove operations and contiguous memory layout.
type Vector<t> = Vector { span: MemSpan<t>, length: U32 };
type Vector<t> implements Collection<t>;

let .length(v: Vector<t>): U64 = (
   v.length as U64
);

let .capacity(v: Vector<t>): U64 = (
   v.span.length()
);

let mk-vector(type: Type<t>, capacity: U64): Vector<t> = (
   Vector { mk-memspan(type, capacity), 0_u32 }
);

let mk-vector(ty: Type<t>): Vector<t> = (
   mk-vector(ty, 0_u64)
);

## generate a [type(Vector<t>)], in which each element is [value]
let fill-vector(value: t, len: U64): Vector<t> = (
   let v = mk-vector(type(t), len);
   while len > 0 {
      v[len-1] = value;
      len = len - 1;
   };
   v.length = len as U32;
   v
);

## does not change the length or destroy old elements!
let .realloc(v: Vector<t>, target-capacity: U64): Vector<t> = (
   Vector { v.span.realloc(target-capacity), v.length }
);

## reserve additional num elements to the current length
let .reserve-additional(v: Vector<t>, additional: U64): Vector<t> = (
   if (v.capacity() - v.length()) < additional {
      v.realloc(v.length() + additional)
   } else {
      v
   }
);

## INPUT VECTOR GETS POISONED
let .push(v: Vector<t>, i: t): Vector<t> = (
   let vec = if v.length >= (v.span.length() as U32) {
      let new-cap = if v.span.length() == 0 {
         4_u64
      } else {
         let current = v.span.length() as U64;
         (current * 3_u64) / 2_u64  # grow by 1.5x
      };
      v.realloc(new-cap)
   } else {
      v
   };
   vec.span[vec.length as U64] = i;
   vec.length = vec.length + 1_u32;
   vec
);

let .into(l: List<t>, out: Type<Vector<t>>): Vector<t> = (
   let v = mk-vector(type(t), l.length);
   for i in l {
      v = v.push(i);
   };
   v
);

## shrinks the vector if it has way too many elements. shouldn't be called manually
let .shrink(v: Vector<t>): Vector<t> = (
    let too-much = v.capacity() - v.length();
    let minimum = (v.length() * 3_u64) / 2_u64; # mul 1.5
    if too-much > minimum {
       v.realloc(minimum)
    } else {
       v
    }
);

## INPUT VECTOR GETS POISONED
let .remove-front(v: Vector<t>, num: U64): Vector<t> = (
    if num > v.length() {
        fail("tried to remove \{num} elements from vector, but only have \{v.length()}");
    };

    let i = num;
    while i < v.length() {
        v.span[i-num] = v.span[i];
        i = i + 1;
    };
    v.length = v.length - (num as U32);

    v.shrink()
);

## INPUT VECTOR GETS POISONED
let .remove-back(v: Vector<t>, num: U64): Vector<t> = (
    if num > v.length() {
        fail("tried to remove \{num} elements from vector, but only have \{v.length()}");
    };

    v.length = v.length - (num as U32);
    v.shrink()
);

## INPUT VECTOR GETS POISONED
let .pop-front(v: Vector<t>): Tuple<t, Vector<t>> = (
    if v.length() == 0 {
        fail("Tried to pop from empty Vector.");
    };

    let x = v[0];
    v = v.remove-front(1);

    Tuple { v, x }
);

## INPUT VECTOR GETS POISONED
let .pop(v: Vector<t>): Tuple<Vector<t>, t> = (
    if v.length() == 0 {
        fail("Tried to pop from empty Vector.");
    };

    let lasti = v.length - 1;
    let last = v[lasti as U64];
    v = v.remove-back(1);

    Tuple { v, last }
);

let $"[]"( v: Vector<t>, i: U64 ): t = (
   v.span[i]
);

let $"+"( vl: Vector<t>, vr: Vector<t> ): Vector<t> = (
   let v = mk-vector(type(t), vl.span.length() + vr.span.length());
   let vi = 0_u64;
   while vi < vl.span.length() { v = v.push(vl[vi]); vi = vi + 1; };
   vi = 0_u64;
   while vi < vr.span.length() { v = v.push(vr[vi]); vi = vi + 1; };
   v
);

let $"set[]"( v: Vector<t>, i: U64, val: t ): Nil = (
   v.span[i] = val;
   ()
);

let .reverse-self(v: Vector<t>): Nil = (
   let i = 0_u64;
   let span = v.span;
   while i < (span.length >> 1) {
      let ri = span.length - i - 1;
      let temp = span[i];
      span[i] = span[ri];
      span[ri] = temp;
      i = i + 1;
   };
);

let .sort(v: Vector<t>): Vector<t> = (
   let span = v.span;
   let n = span.length;
   let i = 0_u64;
   while i < n - 1_u64 {
      let swapped = 0;
      let j = 0;
      while j < n - i - 1_u64 {
         if span[j + 1_u64] < span[j] {
            let tmp = span[j];
            span[j] = span[j + 1_u64];
            span[j + 1_u64] = tmp;
            swapped = 1;
         };
         j = j + 1_u64;
      };
      i = i + 1_u64;
      if not(swapped) {
         i = n;
      };
   };
   v
);

let print(v: Vector<x>): Nil = (
   let vi = 0_u64;
   let span = v.span;
   print(c"[");
   while vi < span.length {
      if vi > 0_u64 then print(c",");
      print(span[vi]);
      vi = vi + 1_u64;
   };
   print(c"]");
);

## does not destory input vec
let .into(in: Vector<U8>, res: Type<CString>): CString = (
   let out = mk-vector(type(U8), in.span.length()+1);
   let i = 0_u64;
   while i < in.span.length() { out = out.push(in[i]); i = i + 1; };
   out = out.push(0_u8);
   ((out.span.data as U8[]) as CString)
);

## does not destory input vec
let .into(self: Vector<U8>, res: Type<SmartString>): SmartString = (
   intern(self.into(type(CString)))
);
