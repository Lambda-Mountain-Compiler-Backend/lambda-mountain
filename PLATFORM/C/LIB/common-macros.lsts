
typed macro macro::let(lhs: lazy, rhs: lazy): lazy = (
   (fn(lhs) = ()) (rhs)
);

typed macro macro::set(lhs: lazy, rhs: lazy): lazy = (
   mov(rhs, lhs)
);

#typed macro macro::set(base field: macro::lhs-field, rhs: lazy): lazy = (
#   macro::concat(l"set.", field) (base, rhs)
#);

#typed macro macro::set(base index: macro::lhs-index, rhs: lazy): lazy = (
#   $"set[]"( macro::lhs-as-rhs(base), index, rhs )
#   macro::concat(l"set.", field) (base, rhs)
#);

#typed macro macro::lhs-as-rhs(v: macro::variable): lazy = (
#   v
#);

#typed macro macro::lhs-as-rhs(_: macro::literal<"&">, v: lazy): lazy = (
#   &v
#);

#typed macro macro::lhs-as-rhs(base field: macro::lhs-index): lazy = (
#   macro::concat(l".", field)(base)
#);

#typed macro macro::lhs-index(base: lazy, field: lazy): lazy = (
#   base; field
#);

typed macro macro::for(item: lazy, iter: List<?>, loop: lazy): lazy = (
   let uuid(iter-term) = iter;
   while uuid(iter-term).has-head { match uuid(iter-term) {
      [item.. uuid(tl)] => (
         loop; uuid(iter-term) = uuid(tl);
      );
   }}
);

typed macro macro::for(item: lazy, iter: Vector<?>, loop: lazy): lazy = (
   let uuid(iter-term) = iter;
   let uuid(iter-i) = 0_u64;
   let uuid(iter-length) = uuid(iter-term).length;
   while uuid(iter-i) < uuid(iter-length) { match uuid(iter-term)[uuid(iter-i)] {
      item => (
         loop; uuid(iter-i) = uuid(iter-i) + 1;
      );
   }}
);

typed macro macro::while(cond: lazy, body: lazy): lazy = (
   $"primitive::while"( body as Nil, into-branch-conditional(cond) )
);
