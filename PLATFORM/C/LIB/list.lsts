
# TODO: use .iter() for iter and don't make list a iter itself

let $"[]"(tt: List<x>, idx: U64): x = (
   while idx > 0 {
      if not(tt.has-head()) {
         fail("index \{idx} is out of bounds for list of length \{tt.length()}");
      };
      tt = tail(tt);
   };
   head(tt)
);

let .unique(ls: List<x>): List<x> = (
   let rs = [] :: List<x>;
   for l in ls {
      if not(rs.contains(l)) {
         rs = cons(l, rs);
      }
   };
   rs
);

let .next(ls: Array<List<x>,?>): Maybe<x> = (
   match open(ls) {
      [i.. rst] => (
         ls[0_u64] = rst;
         Some(i)
      );
      [] => (None :: Maybe<x>);
   };
);

let .lookup(ls: List<Tuple<k,v>>, key: k, default: v): v = (
   let found = false;
   for Tuple{lkey=first, rval=second} in ls {
      if not(found) && key==lkey { default=rval; found=true; }
   };
   default;
);
let .lookup(ls: List<Tuple<k,v1,v2>>, key: k, default: Tuple<v1,v2>): Tuple<v1,v2> = (
   let found = false;
   for Tuple{lkey=first, val1=second, val2=third} in ls {
      if not(found) && key==lkey { default=Tuple{val1,val2}; found=true; }
   };
   default;
);
