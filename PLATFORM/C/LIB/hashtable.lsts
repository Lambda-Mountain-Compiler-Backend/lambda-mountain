
type HashtableEq<k,v> = HashtableEq { occupied: U64, capacity: U64, contents: Tuple<k,v>[] }
                      | HashtableEqEOF;

type HashtableEq<k,v> => Iterable<Tuple<k,v>>;

let .clone(self: HashtableEq<k,v>): HashtableEq<k,v> = (
   match self {
      HashtableEq { occupied=occupied } => (
         let contents = (self as Tag::HashtableEq).contents;
         let new-sz = sizeof(Tuple<k,v>) * occupied;
         let cpy = malloc(new-sz) as Tuple<k,v>[];

         let i = 0;
         while i < occupied {
            cpy[i] = contents[i];
            i = i + 1;
         };

         HashtableEq { occupied, occupied, cpy }
      );

      HashtableEqEOF {} => (HashtableEqEOF :: HashtableEq<k,v>);
   }
);

type HashtableEqIter<k,v> = HashtableEqIter { table: HashtableEq<k,v>, idx: U64 };
type HashtableEqIter<k,v> => Iterator<Tuple<k,v>>;

# for safety, we clone the table
# All modifications done to the vector after creating the iterator will not be seen
let .iter(self: HashtableEq<k,v>): HashtableEqIter<k,v> = (
   let clone = self.clone();
   clone.unsafe-iter()
);

# If you modify the table after creating the iterator, weird things will happen
let .unsafe-iter(self: HashtableEq<k,v>): HashtableEqIter<k,v> = (
   HashtableEqIter { self, 0_u64 }
);

let .next(p: Array<HashtableEqIter<k,v>,?>): Maybe<Tuple<k,v>> = (
   let v = open(p);
   match v.table {
     HashtableEq { occupied=occupied } => (
        if v.idx < occupied {
           let contents = (v.table as Tag::HashtableEq).contents;
           let val = contents[v.idx];
           v.idx = v.idx + 1;
           p[0] = v;
           Some { val } :: Maybe<Tuple<k,v>>
        } else {
           None :: Maybe<Tuple<k,v>>
        }
     );

     HashtableEqEOF {} => (
        None :: Maybe<Tuple<k,v>>
     );
   };
);

let .lookup(table: HashtableEq<k,v>, key: k, default: v): v = (
   let capacity = (table as Tag::HashtableEq).capacity;
   if capacity > 0_u64 {
      let contents = (table as Tag::HashtableEq).contents;
      let replacing = false;
      let ki = deep-hash(key) % capacity;
      let old-kv = contents[ki];
      if mem-is-non-zero(old-kv) && old-kv.first==key { replacing = true; };
      while mem-is-non-zero(old-kv) && not(replacing) {
         ki = (ki + 1_u64) % capacity;
         old-kv = contents[ki];
         if mem-is-non-zero(old-kv) && old-kv.first==key { replacing = true; };
      };
      if replacing { default = old-kv.second; };
   };
   default
);

##[DEPRECATED .contains]
let .has(table: HashtableEq<k,v>, key: k): U64 = (
   table.contains(key)
);

let .contains(table: HashtableEq<k,v>, key: k): U64 = (
   let capacity = (table as Tag::HashtableEq).capacity;
   let replacing = false;
   if capacity > 0_u64 {
      let contents = (table as Tag::HashtableEq).contents;
      let ki = deep-hash(key) % capacity;
      let old-kv = contents[ki];
      if mem-is-non-zero(old-kv) && old-kv.first==key { replacing = true; };
      while mem-is-non-zero(old-kv) && not(replacing) {
         ki = (ki + 1_u64) % capacity;
         old-kv = contents[ki];
         if mem-is-non-zero(old-kv) && old-kv.first==key { replacing = true; };
      };
   };
   replacing
);

##[DEPRECATED .put]
let .bind(table: HashtableEq<k,v>, key: k, value: v): HashtableEq<k,v> = (
   table.put(key, value)
);

let .put(table: HashtableEq<k,v>, key: k, value: v): HashtableEq<k,v> = (
   if is(table, (HashtableEqEOF :: HashtableEq<k,v>)) {
      table = HashtableEq { 0_u64, 0_u64, (0_u64 as Tuple<k,v>[]) };
   };
   let occupied = (table as Tag::HashtableEq).occupied;
   let capacity = (table as Tag::HashtableEq).capacity;
   let contents = (table as Tag::HashtableEq).contents;
   if occupied * 3 >= capacity {
      let new-capacity = max( 1000_u64, occupied * 30_u64 );
      let new-sizeof = sizeof(Tuple<k,v>) * new-capacity;
      let new-contents = malloc(new-sizeof) as Tuple<k,v>[]; 
      memset( new-contents, 0_u32, new-sizeof );
      let old-i = 0_u64;
      while old-i < capacity {
         let old-kv = contents[old-i];
         if mem-is-non-zero(old-kv) {
             new-contents.bind-eq( new-capacity, old-kv.first, old-kv.second );
         };
         old-i = old-i + 1_u64;
      };
      contents = new-contents;
      capacity = new-capacity;
   };
   let replacing = contents.bind-eq( capacity, key, value );
   if not(replacing) { occupied = occupied + 1_u64; };
   HashtableEq { occupied, capacity, contents } 
);

let .bind-eq(contents: Tuple<k,v>[], capacity: U64, key: k, value: v): U64 = (
   let replacing = false;
   let ki = deep-hash(key) % capacity;
   let old-kv = contents[ki];
   if mem-is-non-zero(old-kv) && old-kv.first==key { replacing = true; };
   while mem-is-non-zero(old-kv) && not(replacing) {
      ki = (ki + 1_u64) % capacity;
      old-kv = contents[ki];
      if mem-is-non-zero(old-kv) && old-kv.first==key { replacing = true; };
   };
   contents[ki] = Tuple { key, value };
   replacing
);

