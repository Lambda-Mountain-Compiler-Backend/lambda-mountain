
.text := (
   # internal strlen (%rdi: *char)
   _strlen:                    \n
   \t xor %rcx, %rcx           \n
   _strlen_loop:               \n
   \t cmpb $0, 0(%rdi)         \n
   \t jz _strlen_exit          \n
   \t inc %rcx                 \n
   \t inc %rdi                 \n
   \t jmp  _strlen_loop        \n
   _strlen_exit:               \n
   \t ret                      \n
   # result is stored in %rcx

   # entry points
   print_s:                    \n
   __print_this:               \n

   # if .atom != NULL
   __print_this_atom:          \n
   \t cmp $0, %r8              \n
   \t je __print_this_cons     \n
   \t mov %r8, %rdi            \n
   \t call _strlen             \n
   \t mov %r8, %rsi            \n   # address of string to output
   \t mov %rcx, %rdx           \n   # length is %rcx
   \t mov $1, %rax             \n   # system call 1 is write
   \t mov $1, %rdi             \n   # file handle 1 is stdout
   \t syscall                  \n   # invoke operating system to do the write
   \t ret                      \n

   __print_this_cons:          \n
   # if .head != NULL && .tail != NULL
   \t cmp $0, %r9              \n
   \t je __print_this_nil      \n
   # TODO print .head / .tail
   \t ret                      \n

   __print_this_nil:           \n
   \t mov $1, %rax             \n   # system call 1 is write
   \t mov $1, %rdi             \n   # file handle 1 is stdout
   \t mov $__nil_literal, %rsi \n   # address of string to output
   \t mov $2, %rdx             \n   # nil is 2 bytes
   \t syscall                  \n   # invoke operating system to do the write
   \t ret                      \n
);

.data := (
                               \n
  __cons_counter:              \n
  \t .zero 8                   \n
  __cons_section:              \n
  \t .zero 65536               \n
  __nil_literal:               \n
  \t .ascii "()"               \n
  \t .zero 1                   \n
);
