
::text := (
   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   '_strlen:                     \n
   \t 'xor \s '%rbx, \s '%rbx          \n
   '_strlen_loop:                \n
   \t 'cmpb \s '$0, \s 0 \[ %rax \]        \n
   \t 'jz \s '_strlen_exit           \n
   \t 'inc \s '%rax                  \n
   \t 'inc \s '%rbx                  \n
   \t 'jmp \s '_strlen_loop         \n
   '_strlen_exit:                \n
   \t 'ret                       \n
   # result is stored in %rcx

   # print-s
   'print_s:                     \n
   \t 'mov \s '$0, \s '%r9               \n
   \t 'jmp \s '__print_this          \n

   'print_d:                     \n
   \t 'mov \s '$1, \s '%r9               \n
   \t 'jmp \s '__print_this          \n

   'dump_i:                      \n
   \t 'mov \s '%r12, \s '%r8             \n
   \t 'mov \s '$__dump_i, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n

   \t 'mov \s '$__dump_i, \s '%r11       \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[0]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '0 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[1]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '1 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[2]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '2 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[3]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '3 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[4]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '4 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[5]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '5 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[6]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '6 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[7]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '7 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[8]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '8 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[9]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '9 \[ %r11 \]        \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[10]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '10 \[ %r11 \]       \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[11]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '11 \[ %r11 \]       \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[12]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '12 \[ %r11 \]       \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[13]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '13 \[ %r11 \]       \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[14]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '14 \[ %r11 \]       \n
   \t 'rol \s '$4, \s '%r8               \n   # %r8[15]
   \t 'call \s 'put8                 \n
   \t 'mov \s '%cl, \s '15 \[ %r11 \]       \n
   \t 'ret                       \n

   #move ascii representation of lower byte of %r8 into %cl
   'put8:                        \n
   \t 'mov \s '%r8b, \s '%al             \n # lower byte of %r11 goes into %rax
   \t 'and \s '$0xf, \s '%al             \n # only show lower 4 bits
   \t 'mov \s '$__hex_buffer, \s '%r10   \n # %r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b            \n # %r10 is index into char in hex buffer
   \t 'mov \s '0 \[ %r10 \] , \s '%cl        \n # %cl is a hexadecimal char
   \t 'ret                       \n

   'inc:                         \n
   \t 'inc \s '%r12                  \n
   \t 'ret                       \n

   'dec:                         \n
   \t 'dec \s '%r12                  \n
   \t 'ret                       \n

   'mul:                               \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'mul_err                  \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'je \s 'mul_err                  \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax   \n
   \t 'mov \s '0 \[ '%r14 \] , '%rbx   \n
   \t 'imul \s '%rax, \s '%rbx         \n
   \t 'mov \s '%rbx, \s '%r12          \n
   \t 'ret                             \n
   'mul_err:                           \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n

   'add:                               \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'add_err                  \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'je \s 'add_err                  \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax   \n
   \t 'mov \s '0 \[ '%r14 \] , '%rbx   \n
   \t 'add \s '%rax, \s '%rbx          \n
   \t 'mov \s '%rbx, \s '%r12          \n
   \t 'ret                             \n
   'add_err:                           \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n
 
   '__print_this:                \n
   # if .atom != NULL
   '__print_this_atom:           \n
   \t 'cmp \s '$0, \s '%r12              \n
   \t 'je \s '__print_this_cons      \n
   \t 'mov \s '%r12, \s '%rax            \n
   \t 'call \s '_strlen              \n   # %rbx is length of string
   \t 'mov \s '%r12, \s '%rsi            \n   # address of string to output
   \t 'mov \s '%rbx, \s '%rdx            \n   # length is %rcx
   \t 'mov \s '$1, \s '%rax              \n   # system call 1 is write
   \t 'mov \s '$1, \s '%rdi              \n   # file handle 1 is stdout
   \t 'syscall                   \n   # invoke operating system to do the write
   \t 'ret                       \n

   # if .head != NULL && .tail != NULL
   '__print_this_cons:           \n
   \t 'cmp \s '$0, \s '%r13              \n
   \t 'je \s '__print_this_nil       \n
   \t 'cmp \s '$0, \s '%r14              \n
   \t 'je \s '__print_this_nil       \n
   ::push-this
   ::show-lparen
   \t 'mov \s '%r13, \s '%rsi            \n
   ::open-this
   \t 'call \s '__print_this         \n
   ::pop-this
   ::show-space
   \t 'mov \s '%r14, \s '%rsi            \n
   ::open-this
   \t 'call \s '__print_this         \n
   ::show-rparen
   \t 'ret                       \n

   '__print_this_nil:            \n
   \t 'mov \s '$1, \s '%rax              \n   # system call 1 is write
   \t 'mov \s '$1, \s '%rdi              \n   # file handle 1 is stdout
   \t 'mov \s '$__nil_literal, \s '%rsi  \n   # address of string to output
   \t 'mov \s '$2, \s '%rdx              \n   # nil is 2 bytes
   \t 'syscall                   \n   # invoke operating system to do the write
   \t 'ret                       \n

   'head:                        \n
   \t 'cmp \s '$0, \s '%r13              \n
   \t 'je \s '__head_is_nil          \n
   ::head
   \t 'ret                       \n
   '__head_is_nil:               \n
   ::yield-nil
   \t 'ret                       \n

   'tail:                        \n
   \t 'cmp \s '$0, \s '%r14              \n
   \t 'je \s '__tail_is_nil          \n
   ::tail
   \t 'ret                       \n
   '__tail_is_nil:               \n
   ::yield-nil
   \t 'ret                       \n

   'not:                         \n
   \t 'cmp \s '$0, \s '%r12              \n
   \t 'jne \s '__not_is_some         \n
   \t 'cmp \s '$0, \s '%r13              \n
   \t 'jne \s '__not_is_some         \n
   \t 'cmp \s '$0, \s '%r14              \n
   \t 'jne \s '__not_is_some         \n
   (::yield-atom __true)
   \t 'ret                       \n
   '__not_is_some:               \n
   ::yield-nil
   \t 'ret                       \n

   'eq:                          \n
   \t 'cmp \s '$0, \s '%r13              \n
   \t 'je \s '__equal_nil            \n
   \t 'cmp \s '$0, \s '%r14              \n
   \t 'je \s '__equal_nil            \n
   \t 'mov \s '0 \[ %r13 \] , \s '%rax         \n # mov x.atom into %rax
   \t 'mov \s '0 \[ %r14 \] , \s '%rbx         \n # mov y.atom into %rbx
   \t 'cmp \s '$0, \s '%rax              \n
   \t 'je \s '__equal_nil            \n
   \t 'cmp \s '$0, \s '%rbx              \n
   \t 'je \s '__equal_nil            \n
   \t 'call \s '_streq               \n
   \t 'ret                       \n
   '__equal_nil:                 \n
   ::yield-nil
   \t 'ret                       \n

   # _streq (%rax: *char, %rbx: *char) -> 
   # internal, not a call-convention function
   '_streq:                      \n
   '__streq_loop:                \n
   \t 'cmp \s '$0, \s '%rax              \n
   \t 'je \s '__streq_false          \n
   \t 'cmp \s '$0, \s '%rbx              \n
   \t 'je \s '__streq_false          \n
   \t 'mov \s '0 \[ %rax \] , \s '%cl        \n
   \t 'mov \s '0 \[ %rbx \] , \s '%dl        \n

   \t 'cmp \s '%cl, \s '%dl              \n
   \t 'jne \s '__streq_false         \n
   \t 'cmp \s '$0, \s '%cl               \n
   \t 'je \s '__streq_true           \n
   \t 'inc \s '%rax                  \n
   \t 'inc \s '%rbx                  \n
   \t 'jmp \s '__streq_loop          \n
   '__streq_true:                \n
   ::yield-true
   \t 'ret                       \n
   '__streq_false:               \n
   ::yield-nil
   \t 'ret                       \n


   'clone_rope:                  \n
   \t 'mov \s '$__a_section, \s '%r8     \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '0 \[ %r10 \] , \s '%r11       \n
   \t 'add \s '%r11, \s '%r8             \n
   \t 'mov \s '%r8, \s '%r9              \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   \t 'call \s '__clone_rope         \n
   \t 'movb \s '$0, \s '0 \[ %r9 \]         \n
   \t 'inc \s '%r9                   \n
   \t 'mov \s '$__a_section, \s '%r10    \n
   \t 'sub \s '%r10, \s '%r9             \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '%r9, \s '0 \[ %r10 \]        \n
   \t 'mov \s '%r8, \s '%r12             \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n
   \t 'ret                       \n

   '__clone_rope:                \n
   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13              \n
   \t 'je \s 'clone_rope_notcons     \n
   \t 'cmp \s '$0, \s '%r14              \n
   \t 'je \s 'clone_rope_notcons     \n
   ::push-this
   ::head
   \t 'call \s '__clone_rope         \n
   ::pop-this
   ::tail
   ::push-this
   \t 'call \s '__clone_rope         \n
   ::pop-this
   \t 'jmp \s 'clone_rope_end        \n

   #if not cons, concat
   'clone_rope_notcons:          \n

   #if nil, return
   \t 'cmp \s '$0, \s '%r12              \n
   \t 'je \s 'clone_rope_end         \n

   #if atom, break into characters and concat
   'clone_rope_small:            \n
   \t 'cmpb \s '$0, \s '0 \[ %r12 \]        \n
   \t 'je \s 'clone_rope_end         \n
   \t 'movb \s '0 \[ %r12 \] , \s '%bl       \n
   \t 'movb \s '%bl, \s '0 \[ %r9 \]        \n
   \t 'inc \s '%r12                  \n
   \t 'inc \s '%r9                   \n
   \t 'jmp \s 'clone_rope_small      \n

   'clone_rope_end:              \n
   \t 'ret                       \n

   'write_file:                  \n
   #open file
   \t 'mov \s '0 \[ %r13 \] , \s '%rdi        \n # file name
   \t 'pushq \s '0 \[ %r14 \]             \n # data to write
   \t 'mov \s '$2, \s '%rax               \n # syscall open
   \t 'mov \s '$577, \s %rsi                 \n
   \t 'mov \s '$420, \s '%rdx             \n # mode
   \t 'syscall                   \n
   \t 'mov \s '%rax, \s '%r8             \n # r8 now holds file descriptor

   #write to file
   \t 'pop \s '%rax                  \n
   \t 'mov \s '%rax, \s '%r9             \n
   \t 'call \s '_strlen              \n
   \t 'mov \s '%rbx, \s '%rdx            \n # length to write
   \t 'mov \s '%r9, \s '%rsi             \n # data to write
   \t 'mov \s '%r8, \s '%rdi             \n # file descriptor
   \t 'mov \s '$1, \s '%rax              \n # 'write' system call
   \t 'syscall                   \n

   #close file
   \t 'mov \s '%r8, \s '%rdi             \n # file descriptor
   \t 'mov \s '$3, \s '%rax              \n # close
   \t 'syscall                   \n
   \t 'ret                       \n

   'load_file:                   \n

   # open file
   \t 'mov \s '$2, \s '%rax              \n # syscall open
   \t 'mov \s '%r12, \s '%rdi            \n # file name
   \t 'mov \s '$0, \s '%rsi              \n # read-only mode
   \t 'syscall                   \n
   # file descriptor is in %rax

   \t 'cmp \s '$0, \s '%rax              \n
   # if return value is positive then open was a success
   \t 'jge \s 'load_file_contents    \n

   \t 'mov \s '$__err_fopen, \s '%r12    \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n
   \t 'ret                       \n

   'load_file_contents:          \n
   \t 'mov \s '$__a_section, \s '%r8     \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '0 \[ %r10 \] , \s '%r11       \n
   \t 'add \s '%r11, \s '%r8             \n
   \t 'mov \s '%r8, \s '%r9              \n
   \t 'mov \s '$0, \s '%r10              \n
   \t 'mov \s '$load_file_buf, \s '%r11  \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   #r10 holds amount of data on buffer currently
   #r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:              \n
   \t 'cmp \s '$0, \s '%r10              \n
   \t 'je \s 'load_file_bufempty     \n
   \t 'movb \s '0 \[ %r11 \] , \s '%bl       \n
   \t 'mov \s '%bl, \s '0 \[ %r9 \]         \n
   \t 'inc \s '%r9                   \n
   \t 'inc \s '%r11                  \n
   \t 'dec \s '%r10                  \n
   \t 'jmp \s 'load_file_loop        \n

   # read file
   'load_file_bufempty:          \n
   \t 'push \s '%rax                 \n
   \t 'mov \s '%rax, \s '%rdi            \n # file descriptor
   \t 'mov \s '$0, \s '%rax              \n # read
   \t 'mov \s '$load_file_buf, \s '%rsi  \n # buffer
   \t 'mov \s '$load_file_bsz, \s '%rdx  \n
   \t 'mov \s '0 \[ %rdx \] , \s '%rdx       \n # buffer size
   \t 'syscall                   \n
   \t 'mov \s '%rax, \s '%r10            \n
   \t 'pop \s '%rax                  \n
   \t 'mov \s '$load_file_buf, \s '%r11  \n
   \t 'cmp \s '$0, \s '%r10              \n
   \t 'jne \s 'load_file_loop        \n

   # close file
   \t 'mov \s '%rax, \s '%rdi            \n # file descriptor
   \t 'mov \s '$3, \s '%rax              \n # close
   \t 'syscall                   \n
   
   \t 'movb \s '$0, \s '0 \[ %r9 \]         \n
   \t 'inc \s '%r9                   \n
   \t 'sub \s '%r8, \s '%r9              \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '%r9, \s '0 \[ %r10 \]        \n
   \t 'mov \s '%r8, \s '%r12             \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n
   \t 'ret                       \n
);

::data := (
                                \n
  'load_file_bsz:                \n
  \t '.quad \s '1024                 \n
  'load_file_buf:                \n
  \t '.zero \s '1024                 \n
  '__nil:                        \n
  \t '.zero \s '32                   \n
  '__argv:                       \n
  \t '.zero \s '32                   \n
  '__s_counter:                  \n
  \t '.zero \s '8                    \n
  '__s_section:                  \n
  \t '.zero \s '268435456            \n
  '__a_counter:                  \n
  \t '.zero \s '8                    \n
  '__a_section:                  \n
  \t '.zero \s '268435456            \n
  '__nil_literal:                \n
  \t '.ascii \s '" \[ \] "              \n
  \t '.zero \s '1                    \n
  '__hex_buffer:                 \n
  \t '.ascii \s '"0123456789abcdef"  \n 
  '__put64_buffer:               \n
  \t '.ascii \s '"0x"                \n
  '__put64_write_buffer:         \n
  \t '.ascii \s '"0000000000000000 \s " \n
  \t '.zero \s '1                    \n
  '__newline:                    \n
  \t '.ascii \s '"\n"                \n
  '__lparen:                     \n
  \t '.ascii \s '" \[ "                \n
  '__rparen:                     \n
  \t '.ascii \s '" \] "                \n
  '__space:                      \n
  \t '.ascii \s '" \s "                \n
  '__true:                       \n
  \t '.ascii \s '"True"              \n
  \t '.zero \s '1                    \n
  '__dump_i:                     \n
  \t '.ascii \s '"0000000000000000"  \n
  \t '.zero \s '1                    \n
  '__err_fopen:                  \n
  \t '.ascii \s '"Could \s 'not \s 'open \s 'file." \n
  \t '.zero \s '1                    \n
);
