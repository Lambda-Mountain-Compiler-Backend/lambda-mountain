
::text := (
   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   '_strlen:                     \n
   \t 'xor '%rbx, '%rbx          \n
   '_strlen_loop:                \n
   \t 'cmpb '$0, 0\[%rax\]        \n
   \t 'jz '_strlen_exit           \n
   \t 'inc '%rax                  \n
   \t 'inc '%rbx                  \n
   \t 'jmp '_strlen_loop         \n
   '_strlen_exit:                \n
   \t 'ret                       \n
   # result is stored in %rcx

   # print-s
   'print_s:                     \n
   \t 'mov '$0, '%r9               \n
   \t 'jmp '__print_this          \n

   'print_d:                     \n
   \t 'mov '$1, '%r9               \n
   \t 'jmp '__print_this          \n

   'dump_i:                      \n
   \t 'mov '%r12, '%r8             \n
   \t 'mov '$__dump_i, '%r12       \n
   \t 'mov '$0, '%r13              \n
   \t 'mov '$0, '%r14              \n
   \t 'mov '$0, '%r15              \n

   \t 'mov '$__dump_i, '%r11       \n
   \t 'rol '$4, '%r8               \n   # %r8[0]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '0\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[1]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '1\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[2]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '2\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[3]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '3\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[4]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '4\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[5]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '5\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[6]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '6\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[7]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '7\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[8]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '8\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[9]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '9\[%r11\]        \n
   \t 'rol '$4, '%r8               \n   # %r8[10]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '10\[%r11\]       \n
   \t 'rol '$4, '%r8               \n   # %r8[11]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '11\[%r11\]       \n
   \t 'rol '$4, '%r8               \n   # %r8[12]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '12\[%r11\]       \n
   \t 'rol '$4, '%r8               \n   # %r8[13]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '13\[%r11\]       \n
   \t 'rol '$4, '%r8               \n   # %r8[14]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '14\[%r11\]       \n
   \t 'rol '$4, '%r8               \n   # %r8[15]
   \t 'call 'put8                 \n
   \t 'mov '%cl, '15\[%r11\]       \n
   \t 'ret                       \n

   #move ascii representation of lower byte of %r8 into %cl
   'put8:                        \n
   \t 'mov '%r8b, '%al             \n # lower byte of %r11 goes into %rax
   \t 'and '$0xf, '%al             \n # only show lower 4 bits
   \t 'mov '$__hex_buffer, '%r10   \n # %r10 is index into hex buffer
   \t 'add '%al, '%r10b            \n # %r10 is index into char in hex buffer
   \t 'mov '0\[%r10\], '%cl        \n # %cl is a hexadecimal char
   \t 'ret                       \n

   'inc:                         \n
   \t 'inc '%r12                  \n
   \t 'ret                       \n
 
   '__print_this:                \n
   # if .atom != NULL
   '__print_this_atom:           \n
   \t 'cmp '$0, '%r12              \n
   \t 'je '__print_this_cons      \n
   \t 'mov '%r12, '%rax            \n
   \t 'call '_strlen              \n   # %rbx is length of string
   \t 'mov '%r12, '%rsi            \n   # address of string to output
   \t 'mov '%rbx, '%rdx            \n   # length is %rcx
   \t 'mov '$1, '%rax              \n   # system call 1 is write
   \t 'mov '$1, '%rdi              \n   # file handle 1 is stdout
   \t 'syscall                   \n   # invoke operating system to do the write
   \t 'ret                       \n

   # if .head != NULL && .tail != NULL
   '__print_this_cons:           \n
   \t 'cmp '$0, '%r13              \n
   \t 'je '__print_this_nil       \n
   \t 'cmp '$0, '%r14              \n
   \t 'je '__print_this_nil       \n
   ::push-this
   ::show-lparen
   \t 'mov '%r13, '%rsi            \n
   ::open-this
   \t 'call '__print_this         \n
   ::pop-this
   ::show-space
   \t 'mov '%r14, '%rsi            \n
   ::open-this
   \t 'call '__print_this         \n
   ::show-rparen
   \t 'ret                       \n

   '__print_this_nil:            \n
   \t 'mov '$1, '%rax              \n   # system call 1 is write
   \t 'mov '$1, '%rdi              \n   # file handle 1 is stdout
   \t 'mov '$__nil_literal, '%rsi  \n   # address of string to output
   \t 'mov '$2, '%rdx              \n   # nil is 2 bytes
   \t 'syscall                   \n   # invoke operating system to do the write
   \t 'ret                       \n

   'head:                        \n
   \t 'cmp '$0, '%r13              \n
   \t 'je '__head_is_nil          \n
   ::head
   \t 'ret                       \n
   '__head_is_nil:               \n
   ::yield-nil
   \t 'ret                       \n

   'tail:                        \n
   \t 'cmp '$0, '%r14              \n
   \t 'je '__tail_is_nil          \n
   ::tail
   \t 'ret                       \n
   '__tail_is_nil:               \n
   ::yield-nil
   \t 'ret                       \n

   'not:                         \n
   \t 'cmp '$0, '%r12              \n
   \t 'jne '__not_is_some         \n
   \t 'cmp '$0, '%r13              \n
   \t 'jne '__not_is_some         \n
   \t 'cmp '$0, '%r14              \n
   \t 'jne '__not_is_some         \n
   (::yield-atom __true)
   \t 'ret                       \n
   '__not_is_some:               \n
   ::yield-nil
   \t 'ret                       \n

   'eq:                          \n
   \t 'cmp '$0, '%r13              \n
   \t 'je '__equal_nil            \n
   \t 'cmp '$0, '%r14              \n
   \t 'je '__equal_nil            \n
   \t 'mov '0\[%r13\], '%rax         \n # mov x.atom into %rax
   \t 'mov '0\[%r14\], '%rbx         \n # mov y.atom into %rbx
   \t 'cmp '$0, '%rax              \n
   \t 'je '__equal_nil            \n
   \t 'cmp '$0, '%rbx              \n
   \t 'je '__equal_nil            \n
   \t 'call '_streq               \n
   \t 'ret                       \n
   '__equal_nil:                 \n
   ::yield-nil
   \t 'ret                       \n

   # _streq (%rax: *char, %rbx: *char) -> 
   # internal, not a call-convention function
   '_streq:                      \n
   '__streq_loop:                \n
   \t 'cmp '$0, '%rax              \n
   \t 'je '__streq_false          \n
   \t 'cmp '$0, '%rbx              \n
   \t 'je '__streq_false          \n
   \t 'mov '0\[%rax\], '%cl        \n
   \t 'mov '0\[%rbx\], '%dl        \n

   \t 'cmp '%cl, '%dl              \n
   \t 'jne '__streq_false         \n
   \t 'cmp '$0, '%cl               \n
   \t 'je '__streq_true           \n
   \t 'inc '%rax                  \n
   \t 'inc '%rbx                  \n
   \t 'jmp '__streq_loop          \n
   '__streq_true:                \n
   ::yield-true
   \t 'ret                       \n
   '__streq_false:               \n
   ::yield-nil
   \t 'ret                       \n


   'clone_rope:                  \n
   \t 'mov '$__a_section, '%r8     \n
   \t 'mov '$__a_counter, '%r10    \n
   \t 'mov '0\[%r10\], '%r11       \n
   \t 'add '%r11, '%r8             \n
   \t 'mov '%r8, '%r9              \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   \t 'call '__clone_rope         \n
   \t 'movb '$0, '0\[%r9\]         \n
   \t 'inc '%r9                   \n
   \t 'mov '$__a_section, '%r10    \n
   \t 'sub '%r10, '%r9             \n
   \t 'mov '$__a_counter, '%r10    \n
   \t 'mov '%r9, '0\[%r10\]        \n
   \t 'mov '%r8, '%r12             \n
   \t 'mov '$0, '%r13              \n
   \t 'mov '$0, '%r14              \n
   \t 'mov '$0, '%r15              \n
   \t 'ret                       \n

   '__clone_rope:                \n
   #if this is a cons, recurse
   \t 'cmp '$0, '%r13              \n
   \t 'je 'clone_rope_notcons     \n
   \t 'cmp '$0, '%r14              \n
   \t 'je 'clone_rope_notcons     \n
   ::push-this
   ::head
   \t 'call '__clone_rope         \n
   ::pop-this
   ::tail
   ::push-this
   \t 'call '__clone_rope         \n
   ::pop-this
   \t 'jmp 'clone_rope_end        \n

   #if not cons, concat
   'clone_rope_notcons:          \n

   #if nil, return
   \t 'cmp '$0, '%r12              \n
   \t 'je 'clone_rope_end         \n

   #if atom, break into characters and concat
   'clone_rope_small:            \n
   \t 'cmpb '$0, '0\[%r12\]        \n
   \t 'je 'clone_rope_end         \n
   \t 'movb '0\[%r12\], '%bl       \n
   \t 'movb '%bl, '0\[%r9\]        \n
   \t 'inc '%r12                  \n
   \t 'inc '%r9                   \n
   \t 'jmp 'clone_rope_small      \n

   'clone_rope_end:              \n
   \t 'ret                       \n

   'write_file:                  \n
   #open file
   \t 'mov '0\[%r13\], '%rdi        \n # file name
   \t 'pushq '0\[%r14\]             \n # data to write
   \t 'mov '$2, '%rax               \n # syscall open
   \t 'mov $577, %rsi                 \n
   \t 'mov '$420, '%rdx             \n # mode
   \t 'syscall                   \n
   \t 'mov '%rax, '%r8             \n # r8 now holds file descriptor

   #write to file
   \t 'pop '%rax                  \n
   \t 'mov '%rax, '%r9             \n
   \t 'call '_strlen              \n
   \t 'mov '%rbx, '%rdx            \n # length to write
   \t 'mov '%r9, '%rsi             \n # data to write
   \t 'mov '%r8, '%rdi             \n # file descriptor
   \t 'mov '$1, '%rax              \n # 'write' system call
   \t 'syscall                   \n

   #close file
   \t 'mov '%r8, '%rdi             \n # file descriptor
   \t 'mov '$3, '%rax              \n # close
   \t 'syscall                   \n
   \t 'ret                       \n

   'load_file:                   \n

   # open file
   \t 'mov '$2, '%rax              \n # syscall open
   \t 'mov '%r12, '%rdi            \n # file name
   \t 'mov '$0, '%rsi              \n # read-only mode
   \t 'syscall                   \n
   # file descriptor is in %rax

   \t 'cmp '$0, '%rax              \n
   # if return value is positive then open was a success
   \t 'jge 'load_file_contents    \n

   \t 'mov '$__err_fopen, '%r12    \n
   \t 'mov '$0, '%r13              \n
   \t 'mov '$0, '%r14              \n
   \t 'mov '$0, '%r15              \n
   \t 'ret                       \n

   'load_file_contents:          \n
   \t 'mov '$__a_section, '%r8     \n
   \t 'mov '$__a_counter, '%r10    \n
   \t 'mov '0\[%r10\], '%r11       \n
   \t 'add '%r11, '%r8             \n
   \t 'mov '%r8, '%r9              \n
   \t 'mov '$0, '%r10              \n
   \t 'mov '$load_file_buf, '%r11  \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   #r10 holds amount of data on buffer currently
   #r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:              \n
   \t 'cmp '$0, '%r10              \n
   \t 'je 'load_file_bufempty     \n
   \t 'movb '0\[%r11\], '%bl       \n
   \t 'mov '%bl, '0\[%r9\]         \n
   \t 'inc '%r9                   \n
   \t 'inc '%r11                  \n
   \t 'dec '%r10                  \n
   \t 'jmp 'load_file_loop        \n

   # read file
   'load_file_bufempty:          \n
   \t 'push '%rax                 \n
   \t 'mov '%rax, '%rdi            \n # file descriptor
   \t 'mov '$0, '%rax              \n # read
   \t 'mov '$load_file_buf, '%rsi  \n # buffer
   \t 'mov '$load_file_bsz, '%rdx  \n
   \t 'mov '0\[%rdx\], '%rdx       \n # buffer size
   \t 'syscall                   \n
   \t 'mov '%rax, '%r10            \n
   \t 'pop '%rax                  \n
   \t 'mov '$load_file_buf, '%r11  \n
   \t 'cmp '$0, '%r10              \n
   \t 'jne 'load_file_loop        \n

   # close file
   \t 'mov '%rax, '%rdi            \n # file descriptor
   \t 'mov '$3, '%rax              \n # close
   \t 'syscall                   \n
   
   \t 'movb '$0, '0\[%r9\]         \n
   \t 'inc '%r9                   \n
   \t 'sub '%r8, '%r9              \n
   \t 'mov '$__a_counter, '%r10    \n
   \t 'mov '%r9, '0\[%r10\]        \n
   \t 'mov '%r8, '%r12             \n
   \t 'mov '$0, '%r13              \n
   \t 'mov '$0, '%r14              \n
   \t 'mov '$0, '%r15              \n
   \t 'ret                       \n
);

::data := (
                                \n
  'load_file_bsz:                \n
  \t '.quad '1024                 \n
  'load_file_buf:                \n
  \t '.zero '1024                 \n
  '__nil:                        \n
  \t '.zero '32                   \n
  '__argv:                       \n
  \t '.zero '32                   \n
  '__s_counter:                  \n
  \t '.zero '8                    \n
  '__s_section:                  \n
  \t '.zero '268435456            \n
  '__a_counter:                  \n
  \t '.zero '8                    \n
  '__a_section:                  \n
  \t '.zero '268435456            \n
  '__nil_literal:                \n
  \t '.ascii '"\[\]"              \n
  \t '.zero '1                    \n
  '__hex_buffer:                 \n
  \t '.ascii '"0123456789abcdef"  \n 
  '__put64_buffer:               \n
  \t '.ascii '"0x"                \n
  '__put64_write_buffer:         \n
  \t '.ascii '"0000000000000000 " \n
  \t '.zero '1                    \n
  '__newline:                    \n
  \t '.ascii '"\n"                \n
  '__lparen:                     \n
  \t '.ascii '"\["                \n
  '__rparen:                     \n
  \t '.ascii '"\]"                \n
  '__space:                      \n
  \t '.ascii '"\s"                \n
  '__true:                       \n
  \t '.ascii '"True"              \n
  \t '.zero '1                    \n
  '__dump_i:                     \n
  \t '.ascii '"0000000000000000"  \n
  \t '.zero '1                    \n
  '__err_fopen:                  \n
  \t '.ascii '"Could 'not 'open 'file." \n
  \t '.zero '1                    \n
);
