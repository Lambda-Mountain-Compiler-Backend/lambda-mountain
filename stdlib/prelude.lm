
.text := (
   # internal strlen (%rdi: *char)
   _strlen:                     \n
   \t xor %rcx, %rcx            \n
   _strlen_loop:                \n
   \t cmpb $0, 0(%rdi)          \n
   \t jz _strlen_exit           \n
   \t inc %rcx                  \n
   \t inc %rdi                  \n
   \t jmp  _strlen_loop         \n
   _strlen_exit:                \n
   \t ret                       \n
   # result is stored in %rcx

   # print-s
   print_s:                     \n
   __print_this:                \n

   # if .atom != NULL
   __print_this_atom:           \n
   \t cmp $0, %r12              \n
   \t je __print_this_cons      \n
   \t mov %r12, %rdi            \n
   \t call _strlen              \n
   \t mov %r12, %rsi            \n   # address of string to output
   \t mov %rcx, %rdx            \n   # length is %rcx
   \t mov $1, %rax              \n   # system call 1 is write
   \t mov $1, %rdi              \n   # file handle 1 is stdout
   \t syscall                   \n   # invoke operating system to do the write
   \t ret                       \n

   # if .head != NULL && .tail != NULL
   __print_this_cons:           \n
   \t cmp $0, %r13              \n
   \t je __print_this_nil       \n
   \t cmp $0, %r14              \n
   \t je __print_this_nil       \n
   ::show-lparen
   ::push-this
   \t mov %r13, %rsi            \n
   ::open-this
   \t call __print_this         \n
   ::pop-this
   ::show-space
   ::push-this
   \t mov %r14, %rsi            \n
   ::open-this
   \t call __print_this         \n
   ::pop-this
   ::show-rparen
   \t ret                       \n

   __print_this_nil:            \n
   \t mov $1, %rax              \n   # system call 1 is write
   \t mov $1, %rdi              \n   # file handle 1 is stdout
   \t mov $__nil_literal, %rsi  \n   # address of string to output
   \t mov $2, %rdx              \n   # nil is 2 bytes
   \t syscall                   \n   # invoke operating system to do the write
   \t ret                       \n

   head:                        \n
   \t cmp $0, %rdi              \n
   \t je __head_is_nil          \n
   ::head
   \t ret                       \n
   __head_is_nil:               \n
   ::yield-nil
   \t ret                       \n

   tail:                        \n
   \t cmp $0, %rdi              \n
   \t je __tail_is_nil          \n
   ::tail
   \t ret                       \n
   __tail_is_nil:               \n
   ::yield-nil
   \t ret                       \n

   not:                         \n
   \t cmp $0, %r12              \n
   \t jne __not_is_some         \n
   \t cmp $0, %r13              \n
   \t jne __not_is_some         \n
   \t cmp $0, %r14              \n
   \t jne __not_is_some         \n
   (::yield-atom __true)
   \t ret                       \n
   __not_is_some:               \n
   ::yield-nil
   \t ret                       \n
);

.data := (
                                \n
  __cons_counter:               \n
  \t .zero 64                   \n
  __cons_section:               \n
  \t .zero 65536                \n
  __nil_literal:                \n
  \t .ascii "()"                \n
  \t .zero 1                    \n
  __hex_buffer:                 \n
  \t .ascii "0123456789abcdef"  \n 
  __put64_buffer:               \n
  \t .ascii "0x"                \n
  __put64_write_buffer:         \n
  \t .ascii "0000000000000000 " \n
  \t .zero 1                    \n
  __newline:                    \n
  \t .ascii "\n"                \n
  __lparen:                     \n
  \t .ascii "\lparen"           \n
  __rparen:                     \n
  \t .ascii "\rparen"           \n
  __space:                      \n
  \t .ascii "\space"            \n
  __true:                       \n
  \t .ascii "True"              \n
  \t .zero 1                    \n
);
