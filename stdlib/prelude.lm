
.text := (
   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   _strlen:                     \n
   \t xor %rbx, %rbx            \n
   _strlen_loop:                \n
   \t cmpb $0, 0\(%rax\)          \n
   \t jz _strlen_exit           \n
   \t inc %rax                  \n
   \t inc %rbx                  \n
   \t jmp _strlen_loop         \n
   _strlen_exit:                \n
   \t ret                       \n
   # result is stored in %rcx

   # print-s
   print_s:                     \n
   __print_this:                \n
   ::callee-save-registers
 
   # if .atom != NULL
   __print_this_atom:           \n
   \t cmp $0, %r12              \n
   \t je __print_this_cons      \n
   \t mov %r12, %rax            \n
   \t call _strlen              \n   # %rbx is length of string
   \t mov %r12, %rsi            \n   # address of string to output
   \t mov %rbx, %rdx            \n   # length is %rcx
   \t mov $1, %rax              \n   # system call 1 is write
   \t mov $1, %rdi              \n   # file handle 1 is stdout
   \t syscall                   \n   # invoke operating system to do the write
   ::callee-restore-registers
   \t ret                       \n

   # if .head != NULL && .tail != NULL
   __print_this_cons:           \n
   \t cmp $0, %r13              \n
   \t je __print_this_nil       \n
   \t cmp $0, %r14              \n
   \t je __print_this_nil       \n
   ::push-this
   ::show-lparen
   \t mov %r13, %rsi            \n
   ::open-this
   \t call __print_this         \n
   ::pop-this
   ::show-space
   \t mov %r14, %rsi            \n
   ::open-this
   \t call __print_this         \n
   ::show-rparen
   ::callee-restore-registers
   \t ret                       \n

   __print_this_nil:            \n
   \t mov $1, %rax              \n   # system call 1 is write
   \t mov $1, %rdi              \n   # file handle 1 is stdout
   \t mov $__nil_literal, %rsi  \n   # address of string to output
   \t mov $2, %rdx              \n   # nil is 2 bytes
   \t syscall                   \n   # invoke operating system to do the write
   ::callee-restore-registers
   \t ret                       \n

   head:                        \n
   \t cmp $0, %r13              \n
   \t je __head_is_nil          \n
   ::head
   \t ret                       \n
   __head_is_nil:               \n
   ::yield-nil
   \t ret                       \n

   tail:                        \n
   \t cmp $0, %r14              \n
   \t je __tail_is_nil          \n
   ::tail
   \t ret                       \n
   __tail_is_nil:               \n
   ::yield-nil
   \t ret                       \n

   not:                         \n
   ::callee-save-registers
   \t cmp $0, %r12              \n
   \t jne __not_is_some         \n
   \t cmp $0, %r13              \n
   \t jne __not_is_some         \n
   \t cmp $0, %r14              \n
   \t jne __not_is_some         \n
   ::callee-restore-registers
   (::yield-atom __true)
   \t ret                       \n
   __not_is_some:               \n
   ::callee-restore-registers
   ::yield-nil
   \t ret                       \n

   equal:                       \n
   \t cmp $0, %r13              \n
   \t je __equal_nil            \n
   \t cmp $0, %r14              \n
   \t je __equal_nil            \n
   \t mov 0\(%r13\), %rax         \n # mov x.atom into %rax
   \t mov 0\(%r14\), %rbx         \n # mov y.atom into %rbx
   \t cmp $0, %rax              \n
   \t je __equal_nil            \n
   \t cmp $0, %rbx              \n
   \t je __equal_nil            \n
   \t call _streq               \n
   \t ret                       \n
   __equal_nil:                 \n
   ::yield-nil
   \t ret                       \n

   inequal:                     \n
   \t call equal                \n
   \t call not                  \n
   \t ret                       \n

   # _streq (%rax: *char, %rbx: *char) -> 
   # internal, not a call-convention function
   _streq:                      \n
   __streq_loop:                \n
   \t cmp $0, %rax              \n
   \t je __streq_false          \n
   \t cmp $0, %rbx              \n
   \t je __streq_false          \n
   \t mov 0\(%rax\), %cl          \n
   \t mov 0\(%rbx\), %dl          \n

   \t cmp %cl, %dl              \n
   \t jne __streq_false         \n
   \t cmp $0, %cl               \n
   \t je __streq_true           \n
   \t inc %rax                  \n
   \t inc %rbx                  \n
   \t jmp __streq_loop          \n
   __streq_true:                \n
   ::yield-true
   \t ret                       \n
   __streq_false:               \n
   ::yield-nil
   \t ret                       \n
);

.data := (
                                \n
  __s_counter:               \n
  \t .zero 64                   \n
  __s_section:               \n
  \t .zero 65536                \n
  __nil_literal:                \n
  \t .ascii "\nil"                \n
  \t .zero 1                    \n
  __hex_buffer:                 \n
  \t .ascii "0123456789abcdef"  \n 
  __put64_buffer:               \n
  \t .ascii "0x"                \n
  __put64_write_buffer:         \n
  \t .ascii "0000000000000000 " \n
  \t .zero 1                    \n
  __newline:                    \n
  \t .ascii "\n"                \n
  __lparen:                     \n
  \t .ascii "\lparen"           \n
  __rparen:                     \n
  \t .ascii "\rparen"           \n
  __space:                      \n
  \t .ascii "\space"            \n
  __true:                       \n
  \t .ascii "True"              \n
  \t .zero 1                    \n
);

kv-merge := Î»l r. match (l r) (
   ()
   (((x KV) (() KV)) (x KV))
   (((() KV) (y KV)) (y KV))
);

/*
pub fn kv_add(kv: &S, k: &S, v: &S) -> S {
   s_cons( s_cons(k.clone(),v.clone()), kv.clone() )
}

pub fn kv_ctx(s: &S) -> HashMap<String,S> {
   let mut ctx = HashMap::new();
   for (k,v) in kv_iter(s) {
      let k = k.to_string();
      ctx.insert( k, v );
   }
   ctx
}

pub fn kv_lookup(ctx: &S, key: &S, default: &S) -> S {
   for (k,v) in kv_iter(ctx) {
      if k==*key { return v.clone(); }
   }
   default.clone()
}

pub fn kv_s(ctx: &HashMap<String,S>) -> S {
   kv(&ctx.iter().map(|(k,v)| (s_atom(&k),v.clone())).collect::<Vec<(S,S)>>())
}

pub fn destructure(ctx: &mut HashMap<String,S>, pattern: S, value: S) -> bool {
   if pattern==value { return true; }
   if !is_cons(&pattern) { return false; }
   if head(&pattern)==s_atom("variable") {
      let k = tail(&pattern).to_string();
      ctx.insert( k, value );
      return true;
   }
   if !is_cons(&value) { return false; }
   if is_atom(&head(&pattern)) && head(&pattern).to_string()=="lambda" {
      return false;
   }
   if is_atom(&head(&pattern)) && head(&pattern).to_string()=="regex" {
      if !is_atom(&head(&value)) || head(&value).to_string()!="literal" { return false; }
      let value = tail(&value).to_string();
      let re = Regex::new(&tail(&pattern).to_string()).unwrap();
      return if let Some(c) = re.captures(&value) {
         for (ci,cm) in c.iter().enumerate() {
            if let Some(m) = cm.map(|m| m.as_str()) {
               let k = "{".to_string() + &format!("{}",ci) + "}";
               ctx.insert( k, literal(m) );
            }
         }
         true
      } else { false }
   }
   if is_atom(&head(&pattern)) && head(&pattern).to_string()=="kv" &&
      is_atom(&head(&value)) && head(&value).to_string()=="kv" {
      for (lk,lv) in kv_iter(&tail(&pattern)) {
         let mut found = false;
         for (rk,rv) in kv_iter(&tail(&value)) {
            if lk==rk {
               if !destructure(ctx, lv, rv) { return false; }
               found = true;
               break;
            }
         }
         if !found { return false; }
      }
      return true;
   }
   destructure(ctx, head(&pattern), head(&value)) &&
   destructure(ctx, tail(&pattern), tail(&value))
}
fn restructure(ctx: &HashMap<String,S>, value: S) -> S {
   if !is_cons(&value) { return value; }
   if head(&value)==s_atom("variable") {
      let k = tail(&value).to_string();
      return if let Some(v) = ctx.get(&k) { v.clone() }
      else { value };
   }
   value
}
pub fn map(lhs: S, v: S, rhs: S) -> S {
   let mut ctx = HashMap::new();
   if destructure(&mut ctx, lhs, v) {
      restructure(&ctx, rhs)
   } else { s_nil() }
}
*/
