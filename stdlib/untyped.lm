
# LM provides a concept of open vs closed structures
# a closed structure may always be referred to by a single pointer
# a closed structure may exist on the stack or the heap or even a file or mapped network resource
# an open structure by comparison is thought to exist in the registers
# multiple structures may be open at the same time as long as they don't conflict
# fields of open structures are referred to by their ordered position $0, $1, $2
# a mapping of registers is then applied to these field positions
# x.$0 = %rdi
# y.$3 = %r10
# etc.

# for the bootstrap compiler, only one expression will be open at a time

# S-Expressions are a common datastructure used heavily in the bootstrap compiler
# Not all structures need to be S-Expressions, but they will always be available
# Aside from the usual Cons,Atom,Nil information there is also a reference counter and some flags
#
# struct S {
#   $0 ref_counter : u64
#   $1 atom        : *char
#   $2 head        : *S
#   $3 tail        : *S
#   $4 flags       : bool[64]
# }


::yield-nil := λ_. (
                         # $_.$0 ref_counter is unnecessary when open
                         # open structures must be completely "owned" by the current context
   \t mov $0, %r8    \n # $_.$1 = 0, .atom
   \t mov $0, %r9    \n # $_.$2 = 0, .head
   \t mov $0, %r10   \n # $_.$3 = 0, .tail
   \t mov $0, %r11   \n # $_.$4 = 0, .flags
);

print-this := λ_. (
   # entry point
   __print_this:              \n

   # if .atom != NULL
   __print_this_atom:         \n
   \t cmp $0, %r8             \n
   \t je print_this_cons      \n
   # TODO print .atom
   \t ret                     \n

   __print_this_cons:
   # if .head != NULL && .tail != NULL
   \t cmp $0, %r9             \n
   \t je __print_this_nil     \n
   # TODO print .head / .tail
   \t ret                     \n

   __print_this_nil:          \n
   \t mov $1, %rax            \n   # system call 1 is write
   \t mov $1, %rdi            \n   # file handle 1 is stdout
   \t mov $nil_literal, %rsi  \n   # address of string to output
   \t mov $2, %rdx            \n   # nil is 2 bytes
   \t syscall                 \n   # invoke operating system to do the write
   \t ret                     \n
);

::yield-program := λprogram. (
   .global _start        \n
   .text                 \n
   _start:               \n
   (::yield-nil ())         # mov nil into $_
   \t call __print_this  \n # print $_
   \t mov $0 , %rdi      \n # set exit status to 0
   \t mov $60 , %rax     \n # system call 60 is exit
   \t syscall            \n # invoke operating system
   .data                 \n
   nil_literal:          \n
   \t .ascii "()"        \n
   \t .zero 1            \n
);

::yield-expression := λblock. (
   TODO implement yield-expression
);

::safe-compile-expression := λexpr rett. (
   ::yield-expression ()
);

::safe-compile-program := λsymbols rett. (
   ::yield-program ()
);
