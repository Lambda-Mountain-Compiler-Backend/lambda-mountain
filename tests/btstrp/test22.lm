
import STDLIB/default-instruction-set.lm;
import STDLIB/default-primitives.lm;
import STDLIB/default-stdlib.lm;
import STDLIB/default-rules.lm;

type Type TAny | (TVar String) | (TGround( String , TypeList[] )) | (TAnd( Type[] , Type[] ));
type TypeList TypeEOF | (TypeSeq( TypeList[] , Type ));

type AST ASTEOF | ASTNil | (App( AST[] , AST[] )) | (Var( String )) | (Lit( String )) | (Abs( AST[] , AST[] ))
                | (Seq( AST[] , AST[] )) | (Glb( String , AST[] )) | (ASTType( AST[] , AST[] )) | (Fragment( String , AST[] ))
                | (Asc( AST[] , Type[] ));

type ASTList ASTLEOF | (ASTSeq( ASTList[] , AST ));

type StringStringList SSEOF | (SSSeq( StringStringList[] , String , String ));

type Used Used | Unused | Tail | Return;

type Context CtxEOF | CtxNil | (CtxBind( Context[] , String , AST[] ));
type TContext TCtxEOF | (TCtxBind( TContext[] , String , Type ));
type Pair (Pair( AST , AST ));
type CPair (CPair( Context , Context ));
type TPair (TPair( Type , Type ));
type TCPair (TCPair( TContext , TContext ));
type UPair (UPair( Used , Used ));

type TypeConstructorList (TConEOF) | (TConSeq( TypeConstructorList[] , String , Type ));

typecheck-type-constructors := (: TConEOF TypeConstructorList);
typecheck-classes-of-tag := (: TConEOF TypeConstructorList);
typecheck-fragment-types := (: TypeEOF TypeList);

type TypeSizeList (TSzEOF) | (TSzSeq( TypeSizeList[] , String , U64 ));

typecheck-type-sizes := (: TSzEOF TypeSizeList);

== := λ(: lterm AST)(: rterm AST). (: (tail(
   (let r 0_u64)
   (match (Pair( lterm rterm )) (
      ()
      ( (Pair( ASTEOF ASTEOF )) (set r 1_u64) )
      ( (Pair( ASTNil ASTNil )) (set r 1_u64) )
      ( (Pair( (Var lv) (Var rv) )) (
         (if (==( (as lv U64) (as rv U64) )) (
            (set r 1_u64)
         ) ())
      ))
      ( (Pair( (Lit lv) (Lit rv) )) (
         (if (==( (as lv U64) (as rv U64) )) (
            (set r 1_u64)
         ) ())
      ))
      ( _ (
        (if (==( (.0 lterm) (.0 rterm) )) (
           (if (==( (as (.1 (as lterm App)) U64) (as (.1 (as rterm App)) U64) )) (
              (if (==( (as (.2 (as lterm App)) U64) (as (.2 (as rterm App)) U64) )) (set r 1_u64) () )
           ) ())
        ) ())
      ))
   ))
   r
)) U64);

typecheck-lookup := λ(: term AST). (: (tail(
   (let found TAny)
   (let tctx typecheck-term-type-list)
   (while (non-zero tctx) (match tctx (
      ()
      ( (TTSeq( rst (*( t tt )) )) (
         (if (==( t term )) (tail(
            (set found tt)
            (set tctx TTEOF)
         )) (
            (set tctx rst)
         ))
      ))
   )))
   (close found)
)) Type[]);

typecheck-ascript := λ(: t AST)(: tt Type). (: (
   (if (non-zero tt) (tail(
      (let ot-normal (maybe-deref(normalize(maybe-deref(typecheck-lookup t)))))
      (if (non-zero ot-normal) (
         (if (is-arrow tt) () (tail(
            (let tt2 (maybe-deref(typecheck-annotate-size tt)))
            (let tt-normal (maybe-deref(normalize( tt2 ))))
            (let ot-supernormal (maybe-deref(without-tag ot-normal)))
            (let tt-supernormal (maybe-deref(without-tag tt-normal)))
            (if (==( ot-supernormal tt-supernormal )) () (tail(
               (print ot-supernormal)
               (print '\s!=\s_s)
               (print tt-supernormal)
               (print '\n_s)
               (exit-error( 'Type\sAscription\sInequality_s t ))
            )))
         )))
      ) (tail(
         (let stt (maybe-deref(typecheck-annotate-size tt)))
         (set typecheck-term-type-list (TTSeq(
            (close typecheck-term-type-list)
            t stt
         )))
         (set typecheck-types-have-changed True_u8)
      )))
   )) ())
) Nil);

type TermTypeList TTEOF | (TTSeq( TermTypeList[] , AST , Type ));
type STypeList STEOF | (STSeq( STypeList[] , S , Type ));

non-zero := λ(: t TermTypeList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TTEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

non-zero := λ(: t STypeList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( STEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

non-zero := λ(: t Type). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TAny (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

typecheck-term-type-list := (: TTEOF TermTypeList);

normalize := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TGround( 'Constant_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Literal_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'StackVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'LocalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'GlobalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg8_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg16_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg32_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg64_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Sized_s _ )) (set tt TAny) )
      ( (TAnd( lt rt )) (tail(
         (let lt1 (maybe-deref(normalize lt )))
         (let rt1 (maybe-deref(normalize rt )))
         (match (TPair( lt1 rt1 )) (
            ()
            ( (TPair( TAny rt2 )) (set tt rt2) )
            ( (TPair( lt2 TAny )) (set tt lt2) )
            ( (TPair( lt2 rt2 )) (tail(
               (let tt-2 (maybe-deref(tand( lt2 rt2 ))))
               (set tt tt-2)
            )))
         ))
      )))
      ( _ () )
   ))
   (close tt)
)) Type[]);

is-arrow := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (if (is-arrow lt) (
            (set r 1_u64)
         ) (
            (set r (is-arrow rt))
         ))
      ))
      ( (TGround( '->_s _ )) (set r 1_u64) )
      ( _ () )
   ))
   r
)) U64);

typecheck-annotate-size := λ(: tt Type). (: (tail(
   ()
   (if (typecheck-is-sized tt) () (
      (if (==( (typecheck-is-sized tt) typecheck-do-not-size )) () (tail(
         (let sz (typecheck-annotate-size-inner tt))
         (let tt2 (maybe-deref(typecheck-annotate-size-recurse tt)))
         (let tt3 (maybe-deref(tand(
            tt2
            (TGround(
               'Sized_s
               (close (TypeSeq(
                  (close TypeEOF)
                  (TGround(
                     (to-string sz)
                     (close TypeEOF)
                  ))
               )))
            ))
         ))))
         (set tt tt3)
      )))
   ))
   (close tt)
)) Type[]);

without-tag := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt1 (maybe-deref(without-tag lt )))
         (let rt1 (maybe-deref(without-tag rt )))
         (match (TPair( lt1 rt1 )) (
            ()
            ( (TPair( TAny rt2 )) (set tt rt2) )
            ( (TPair( lt2 TAny )) (set tt lt2) )
            ( (TPair( lt2 rt2 )) (tail(
               (let tt-2 (maybe-deref(tand( lt2 rt2 ))))
               (set tt tt-2)
            )))
         ))
      )))
      ( (TGround( possibly-tag-name _ )) (tail(
         #if this is a tag and not a class, then remove from normal form
         (let class-type (maybe-deref(typecheck-classof-tag possibly-tag-name)))
         (let iso False_u8)
         (match class-type (
            ()
            ( (TGround( class-name _ )) (
               (if (==( possibly-tag-name class-name )) (
                  (set iso True_u8)
               ) ())
            ))
            ( _ () )
         ))
         (if (non-zero class-type) (
            (if (==( iso True_u8 )) () (set tt TAny))
         ) ())
      )))
   ))
   (close tt)
)) Type[]);

exit-error := λ(: msg String)(: t AST). (: (tail(
   (print msg)
   (print '\n_s)
   (exit 1_u64)
)) Nil);

typecheck-types-have-changed := True_u8;

tand := λ(: lt Type)(: rt Type). (: (tail(
   (if (non-zero lt) (tail(
      (let only-rt (maybe-deref(right-if-not-left( lt rt ))))
      (if (non-zero only-rt) (
         (set lt (TAnd(
            (close lt)
            (close only-rt)
         )))
      ) ())
   )) (set lt rt))
   (close lt)
)) Type[]);

right-if-not-left := λ(: lt Type)(: rt Type). (: (tail(
   (match (TPair( lt rt )) (
      ()
      ( (TPair( _ (TGround( '->_s _ )) )) () )
      ( (TPair( (TGround( ltag _ )) (TGround( rtag _ )) )) (
         (if (==( ltag rtag )) (set rt TAny) ())
      ))
      ( (TPair( (TAnd( lt1 lt2 )) (TGround( rtag _ )) )) (tail(
         (let llt1 (maybe-deref(right-if-not-left( lt1 rt ))))
         (let llt2 (maybe-deref(right-if-not-left( lt2 rt ))))
         (if (non-zero llt1) () (set rt TAny))
         (if (non-zero llt2) () (set rt TAny))
      )))
      ( (TPair( _ (TAnd( rt1 rt2 )) )) (tail(
         (let rrt1 (maybe-deref(right-if-not-left( lt rt1 ))))
         (let rrt2 (maybe-deref(right-if-not-left( lt rt2 ))))
         (if (non-zero rrt1) (
            (if (non-zero rrt2) (
               (set rt (TAnd(
                  (close rrt1)
                  (close rrt2)
               )))
            ) (
               (set rt rrt1)
            ))
         ) (
            (if (non-zero rrt2) (
               (set rt rrt2)
            ) (
               (set rt TAny)
            ))
         ))
      )))
      ( _ () )
   ))
   (close rt)
)) Type[]);

typecheck-do-not-size := 99999_u64;
typecheck-is-sized := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( TAny (set r typecheck-do-not-size) )
      ( (TGround( 'Cons_s _ )) (set r typecheck-do-not-size) )
      ( (TGround( '->_s _ )) (set r typecheck-do-not-size) )
      ( (TAnd( lt rt )) (
         (set r (max(
            (typecheck-is-sized lt)
            (typecheck-is-sized rt)
         )))
      ))
      ( (TGround( 'Sized_s _ )) (set r 1_u64) )
      ( _ () )
   ))
   r
)) U64);

typecheck-annotate-size-inner := λ(: tt Type). (: (tail(
   (let sz 0_u64)
   (match tt (
      ()
      ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF _ )) TAny )) )) (set sz 8_u64) )
      ( (TGround( tag _ )) (set sz (typecheck-get-size tag)) )
      ( (TAnd( lt rt )) (
         (set sz (max(
            (typecheck-annotate-size-inner lt)
            (typecheck-annotate-size-inner rt)
         )))
      ))
      ( _ () )
   ))
   sz
)) U64);

typecheck-annotate-size-recurse := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (maybe-deref(typecheck-annotate-size-recurse lt)))
         (let rt2 (maybe-deref(typecheck-annotate-size-recurse rt)))
         (let tt-2 (maybe-deref(tand( lt2 rt2 ))))
         (set tt tt-2)
      )))
      ( (TGround( _ TypeEOF )) () )
      ( (TGround( tag (TypeSeq( TypeEOF pt1 )) )) (tail(
         (let pt1t (maybe-deref(typecheck-annotate-size pt1)))
         (set tt (TGround( tag (
            (close(TypeSeq(
               (close TypeEOF)
               pt1t
            )))
         ))))
      )))
      ( (TGround( tag (TypeSeq( (TypeSeq( TypeEOF pt1 )) pt2 )) )) (tail(
         (let pt1t (maybe-deref(typecheck-annotate-size pt1)))
         (let pt2t (maybe-deref(typecheck-annotate-size pt2)))
         (set tt (TGround( tag (
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  pt1t
               )))
               pt2t
            )))
         ))))
      )))
      ( _ () )
   ))
   (close tt)
)) Type[]);

to-string := λ(: i U64). (: (tail(
   (let r SNil)
   (let c 0_u8)
   (while (not(==( i 0_u64 ))) (
      (let ci (+( (%( i 10_u64 )) 48_u64 )))
      (set i (/( i 10_u64 )))
      (mov( ci R8 ))
      (mov( R8B c ))
      (set r (SCons(
         (close(SAtom(clone-rope c)))
         (close r)
      )))
   ))
   (if (non-zero r) () (
      (set r (SAtom '0_s))
   ))
   (clone-rope r)
)) String);

typecheck-classof-tag := λ(: tag String). (: (tail(
   (let r TAny)
   (let tag-list typecheck-classes-of-tag)
   (while (non-zero tag-list) (match tag-list (
      ()
      ( (TConSeq( rst (*( k kt )) )) (
         (if (==( k tag )) (tail(
            (set r kt)
            (set tag-list TConEOF)
         )) (
            (set tag-list rst)
         ))
      ))
   )))
   (close r)
)) Type[]);

max := λ(: l U64)(: r U64). (: (tail(
   (if (<( l r )) (set l r) ())
   l
)) U64);

typecheck-get-size := λ(: tag String). (: (tail(
   (let sz 0_u64)
   (let sizes typecheck-type-sizes)
   (while (non-zero sizes) (match sizes (
      ()
      ( (TSzSeq( rst (*( kt ks )) )) (tail(
         (if (==( kt tag )) (
            (set sz ks)
         ) ())
         (set sizes rst)
      )))
   )))
   sz
)) U64);

non-zero := λ(: t TypeSizeList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TSzEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

close := λ(: x TypeConstructorList). (: (tail(
   (mov( (malloc(sizeof TypeConstructorList)) R8 ))
   (mov( x 0_u64 (as R8 TypeConstructorList[]) ))
   (as R8 TypeConstructorList[])
)) TypeConstructorList[]);

close := λ(: x TypeSizeList). (: (tail(
   (mov( (malloc(sizeof TypeSizeList)) R8 ))
   (mov( x 0_u64 (as R8 TypeSizeList[]) ))
   (as R8 TypeSizeList[])
)) TypeSizeList[]);

non-zero := λ(: t ASTList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( ASTLEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

non-zero := λ(: t TypeList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TypeEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

non-zero := λ(: t Context). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( CtxEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

close := λ(: x AST). (: (tail(
   (mov( (malloc(sizeof AST)) R8 ))
   (mov( x 0_u64 (as R8 AST[]) ))
   (as R8 AST[])
)) AST[]);

close := λ(: x ASTList). (: (tail(
   (mov( (malloc(sizeof ASTList)) R8 ))
   (mov( x 0_u64 (as R8 ASTList[]) ))
   (as R8 ASTList[])
)) ASTList[]);

close := λ(: x TypeList). (: (tail(
   (mov( (malloc(sizeof TypeList)) R8 ))
   (mov( x 0_u64 (as R8 TypeList[]) ))
   (as R8 TypeList[])
)) TypeList[]);

close := λ(: x Type). (: (tail(
   (mov( (malloc(sizeof Type)) R8 ))
   (mov( x 0_u64 (as R8 Type[]) ))
   (as R8 Type[])
)) Type[]);

== := λ(: lt Type)(: rt Type). (: (tail(
   (let r 0_u64)
   (match (TPair( lt rt )) (
      ()
      ( (TPair( TAny TAny )) (set r 1_u64) )
      ( (TPair( (TVar lv) (TVar rv) )) (set r (==( lv rv ))) )
      ( (TPair( (TAnd( llt rlt )) (TAnd( lrt rrt )) )) (
         (if (==( llt lrt )) (
            (if (==( rlt rrt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (TPair( (TGround( ln TypeEOF )) (TGround( rn TypeEOF )) )) (
         (set r (==( ln rn )))
      ))
      ( (TPair( (TGround( ln (TypeSeq( TypeEOF lt1 )) )) (TGround( rn (TypeSeq( TypeEOF rt1 )) )) )) (
         (if (==( ln rn )) (
            (if (==( lt1 rt1 )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (TPair( (TGround( ln (TypeSeq( (TypeSeq( TypeEOF lt1 )) lt2 )) )) (TGround( rn (TypeSeq( (TypeSeq( TypeEOF rt1 )) rt2 )) )) )) (
         (if (==( ln rn )) (
            (if (==( lt1 rt1 )) (
               (if (==( lt2 rt2 )) (
                  (set r 1_u64)
               ) ())
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

print := λ(: tt Type). (: (match tt (
   ()
   ( TAny (print '?_s) )
   ( (TVar( vn )) (tail( (print '`_s) (print vn) )) )
   ( (TGround( tag TypeEOF )) (print tag) )
   ( (TGround( tag (TypeSeq( TypeEOF p1 )) )) (tail(
      (print tag)
      (print '<_s)
      (print p1)
      (print '>_s)
   )))
   ( (TGround( tag (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (tail(
      (print tag)
      (print '<_s)
      (print p1)
      (print ',_s)
      (print p2)
      (print '>_s)
   )))
   ( (TGround( tag (TypeSeq( (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) p3 )) )) (tail(
      (print tag)
      (print '<_s)
      (print p1)
      (print ',_s)
      (print p2)
      (print ',_s)
      (print p3)
      (print '>_s)
   )))
   ( (TAnd( (TGround( '->_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) rt )) (tail(
      (print '-><_s)
      (print p1)
      (print ',_s)
      (print p2)
      (print '>\n_s)
      (print rt)
   )))
   ( (TAnd( lt (TGround( '->_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) )) (tail(
      (print lt)
      (print '\n_s)
      (print '-><_s)
      (print p1)
      (print ',_s)
      (print p2)
      (print '>_s)
   )))
   ( (TAnd( lt rt )) (tail(
      (print lt)
      (print '\s+\s_s)
      (print rt)
   )))
)) Nil);

close := λ(: x TermTypeList). (: (tail(
   (mov( (malloc(sizeof TermTypeList)) R8 ))
   (mov( x 0_u64 (as R8 TermTypeList[]) ))
   (as R8 TermTypeList[])
)) TermTypeList[]);

close := λ(: x STypeList). (: (tail(
   (mov( (malloc(sizeof STypeList)) R8 ))
   (mov( x 0_u64 (as R8 STypeList[]) ))
   (as R8 STypeList[])
)) STypeList[]);

non-zero := λ(: t TypeConstructorList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TConEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

main := λ. (: (tail(
   (let x (Var 'x_s))
   (let xt (TGround( 'X_s (close TypeEOF) )))
   (let y (Var 'y_s))
   (let yt (TGround( 'Y_s (close TypeEOF) )))
   (typecheck-ascript( x xt ))
   (typecheck-ascript( y yt ))
   (print(maybe-deref(typecheck-lookup( x ))))
   (print(maybe-deref(typecheck-lookup( y ))))
)) Nil);
