
# Static Globals

cli-config                               := ();
parse-parsed-program                     := ();

# Cli Entry Point

main := (
   (local inputs)
   (set inputs ('tests/data/file1.txt ('tests/data/file2.txt ())))

   (parse-program  (tokenize (load-file 'tests/data/file1.txt)  ))
   (parse-program  (tokenize (load-file 'tests/data/file2.txt)  ))

   (print-s parse-parsed-program))
);

# Tokenizer 

tokenize := λtext . (tail(
   (print-s (Tokenize text))
   (local program)
   (local buffer)
   (local in_comment)
   (local char)

   (while text (
      (set char (head-string text))
      (set text (tail-string text))
   (match char (      
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (Tokenized program)
   (reverse-list program)
));

# Parser

parse-program := λtoks . (tail(
   (print-s (Parse toks))
   (local program)
   (local pme)
   (local pme2)
   (match toks (
      ()
      (remainder (tail(
         (set pme (parse-many-expressions remainder))
         (print-s (PME pme))
         (local ge)
         (set ge (Gexpr (head pme)))
         (print-s ge)
         (print-s (PP parse-parsed-program))
         (set parse-parsed-program (parse-parsed-program ge))
         (print-s parse-parsed-program)
         (set toks (tail pme))
      )))
   ))
   program
));

parse-unexpect := λt . fail (UnexpectedToken t);
parse-expect := λt ts . ();

parse-one-expression := λtoks . (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \] r ) (
         (parse-unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (parse-expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks . (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks . (parse-many-expressions toks);

# Utility Functions

fail := λmsg . (print-s msg) (exit 1);

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

label-case := λk . (tail(
   (local nk)
   (while k (match (head-string k) (
      ()
      (() ())
      ('- (
         (set nk (nk '_))
         (set k (tail-string k))
      ))
      ('$ (
         (set nk (nk '_I_))
         (set k (tail-string k))
      ))
      (c (
         (set nk (nk (clone-rope c)))
         (set k (tail-string k))
      ))
   )))
   (clone-rope nk)
));

is-variable := λv . (match (head-string v) (
   ()
   ('$ True )
   ('_ True )
   ('a True )
   ('b True )
   ('c True )
   ('d True )
   ('e True )
   ('f True )
   ('g True )
   ('h True )
   ('i True )
   ('j True )
   ('k True )
   ('l True )
   ('m True )
   ('n True )
   ('o True )
   ('p True )
   ('q True )
   ('r True )
   ('s True )
   ('t True )
   ('u True )
   ('v True )
   ('w True )
   ('x True )
   ('y True )
   ('z True )
));

