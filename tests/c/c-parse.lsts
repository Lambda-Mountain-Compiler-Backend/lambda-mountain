
import LIB/default.lsts;
import SRC/unit-ast.lsts;
import SRC/unit-drivers.lsts;
import SRC/unit-globals.lsts;
import SRC/unit-inference.lsts;
import SRC/unit-fragments.lsts;
import SRC/unit-orphans.lsts;
import SRC/unit-error.lsts;
import PLUGINS/FRONTEND/C/index-index.lm;
import PLUGINS/FRONTEND/C/index-index.lm;

# helpers
if true then { 
   let tokens = std-c-tokenize-string("[+]", "+");
   assert( tokens.length == 1 );
   assert( is(tokens, std-c-take-maybe(tokens, "-")) );
   assert( std-c-can-take(tokens, "-") == false );
   assert( std-c-can-take(tokens, "+") == true );
   assert( is(tail(tokens), std-c-take-expect(tokens, "+")) );
   assert( is(tail(tokens), std-c-take-maybe(tokens, "+")) );
};

# assignment operators
if true then { 
   let abc = std-c-tokenize-string("ab", "ab");
   assert( std-c-parse-assignment-operator(abc).first == None :: Maybe<String> );
   if true then {
      let tokens = std-c-tokenize-string("[=]", "=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[*=]", "*=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"*="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[/=]", "/=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"/="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[%=]", "%=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"%="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[+=]", "+=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"+="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[-=]", "-=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"-="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[<<=]", "<<=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"<<="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[>>=]", ">>=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{">>="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[&=]", "&=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"&="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[^=]", "^=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"^="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[|=]", "|=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{"|="} );
   };
};

if true then { 
   let abc = std-c-tokenize-string("ab", "ab");
   assert( std-c-parse-unary-operator(abc).first == None :: Maybe<String> );
   if true then {
      let tokens = std-c-tokenize-string("[&]", "&");
      assert( std-c-parse-unary-operator(tokens).first == Some{"&"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[*]", "*");
      assert( std-c-parse-unary-operator(tokens).first == Some{"*"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[+]", "+");
      assert( std-c-parse-unary-operator(tokens).first == Some{"+"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[-]", "-");
      assert( std-c-parse-unary-operator(tokens).first == Some{"-"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[~]", "~");
      assert( std-c-parse-unary-operator(tokens).first == Some{"~"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[!]", "!");
      assert( std-c-parse-unary-operator(tokens).first == Some{"!"} );
   };
};

if true then { 
   let abc = std-c-tokenize-string("ab", "ab");
   assert( std-c-parse-struct-or-union(abc).first == None :: Maybe<String> );
   if true then {
      let tokens = std-c-tokenize-string("[struct]", "struct");
      assert( std-c-parse-struct-or-union(tokens).first == Some{"struct"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[union]", "union");
      assert( std-c-parse-struct-or-union(tokens).first == Some{"union"} );
   };
};

if true then { 
   if true then {
      let tokens = std-c-tokenize-string("[abc]", "ab");
      assert( std-c-parse-identifier(tokens).first == Some{"ab"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[ABC]", "AB");
      assert( std-c-parse-identifier(tokens).first == Some{"AB"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("_0", "_0");
      assert( std-c-parse-identifier(tokens).first == Some{"_0"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[int]", "int");
      assert( std-c-parse-identifier(tokens).first == None :: Maybe<String> );
   };
};

if true then { 
   let abc = std-c-tokenize-string("ab", "ab");
   assert( std-c-parse-constant(abc).first == None :: Maybe<CConstant> );
   if true then {
      let tokens = std-c-tokenize-string("[0123456789]", "0123456789");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0123456789"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[0x0123456789aAbBcCdDeEfF]", "0x0123456789aAbBcCdDeEfF");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0x0123456789aAbBcCdDeEfF"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[0b01]", "0b01");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0b01"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[0ulwb]", "0ulwb");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0ulwb"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[0UllWB]", "0UllWB");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0UllWB"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[0ULLWB]", "0ULLWB");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0ULLWB"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[0ULWB]", "0ULWB");
      assert( std-c-parse-constant(tokens).first == Some{CConstantInteger{"0ULWB"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("'a'", "'a'");
      assert( std-c-parse-constant(tokens).first == Some{CConstantCharacter{"'a'"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("u8'\\''", "u8'\\''");
      assert( std-c-parse-constant(tokens).first == Some{CConstantCharacter{"u8'\\''"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("L'\\0'", "L'\\0'");
      assert( std-c-parse-constant(tokens).first == Some{CConstantCharacter{"L'\\0'"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("u'\\u123'", "u'\\u123'");
      assert( std-c-parse-constant(tokens).first == Some{CConstantCharacter{"u'\\u123'"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("0.2", "0.2");
      assert( std-c-parse-constant(tokens).first == Some{CConstantFloating{"0.2"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("1e2f", "1e2f");
      assert( std-c-parse-constant(tokens).first == Some{CConstantFloating{"1e2f"}} );
   };
   if true then {
      let tokens = std-c-tokenize-string("0x3p2", "0x3p2");
      assert( std-c-parse-constant(tokens).first == Some{CConstantFloating{"0x3p2"}} );
   };
};
