
import LIB/default.lsts;
import SRC/unit-ast.lsts;
import SRC/unit-drivers.lsts;
import SRC/unit-globals.lsts;
import SRC/unit-inference.lsts;
import SRC/unit-fragments.lsts;
import SRC/unit-orphans.lsts;
import SRC/unit-error.lsts;
import PLUGINS/FRONTEND/C/index-index.lm;
import PLUGINS/FRONTEND/C/index-index.lm;

# helpers
if true then { 
   let tokens = std-c-tokenize-string("[+]", "+");
   assert( tokens.length == 1 );
   assert( is(tokens, std-c-take-maybe(tokens, "-")) );
   assert( std-c-can-take(tokens, "-") == false );
   assert( std-c-can-take(tokens, "+") == true );
   assert( is(tail(tokens), std-c-take-expect(tokens, "+")) );
   assert( is(tail(tokens), std-c-take-maybe(tokens, "+")) );
};

# assignment operators
if true then { 
   let abc = std-c-tokenize-string("abc", "abc");
   assert( std-c-parse-assignment-operator(abc).first == None :: Maybe<CString> );
   if true then {
      let tokens = std-c-tokenize-string("[=]", "=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[*=]", "*=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"*="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[/=]", "/=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"/="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[%=]", "%=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"%="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[+=]", "+=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"+="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[-=]", "-=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"-="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[<<=]", "<<=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"<<="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[>>=]", ">>=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c">>="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[&=]", "&=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"&="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[^=]", "^=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"^="} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[|=]", "|=");
      assert( std-c-parse-assignment-operator(tokens).first == Some{c"|="} );
   };
};

if true then { 
   let abc = std-c-tokenize-string("abc", "abc");
   assert( std-c-parse-unary-operator(abc).first == None :: Maybe<CString> );
   if true then {
      let tokens = std-c-tokenize-string("[&]", "&");
      assert( std-c-parse-unary-operator(tokens).first == Some{c"&"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[*]", "*");
      assert( std-c-parse-unary-operator(tokens).first == Some{c"*"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[+]", "+");
      assert( std-c-parse-unary-operator(tokens).first == Some{c"+"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[-]", "-");
      assert( std-c-parse-unary-operator(tokens).first == Some{c"-"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[~]", "~");
      assert( std-c-parse-unary-operator(tokens).first == Some{c"~"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[!]", "!");
      assert( std-c-parse-unary-operator(tokens).first == Some{c"!"} );
   };
};

if true then { 
   let abc = std-c-tokenize-string("abc", "abc");
   assert( std-c-parse-struct-or-union(abc).first == None :: Maybe<CString> );
   if true then {
      let tokens = std-c-tokenize-string("[struct]", "struct");
      assert( std-c-parse-struct-or-union(tokens).first == Some{c"struct"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[union]", "union");
      assert( std-c-parse-struct-or-union(tokens).first == Some{c"union"} );
   };
};

if true then { 
   if true then {
      let tokens = std-c-tokenize-string("[abc]", "abc");
      assert( std-c-parse-identifier(tokens).first == Some{c"abc"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[ABC]", "ABC");
      assert( std-c-parse-identifier(tokens).first == Some{c"ABC"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("_0", "_0");
      assert( std-c-parse-identifier(tokens).first == Some{c"_0"} );
   };
   if true then {
      let tokens = std-c-tokenize-string("[int]", "int");
      assert( std-c-parse-identifier(tokens).first == None :: Maybe<CString> );
   };
};

if true then { 
   let abc = std-c-tokenize-string("abc", "abc");
   assert( std-c-parse-constant(abc).first == None :: Maybe<CString> );
   if true then {
      let tokens = std-c-tokenize-string("[0123456789]", "0123456789");
      assert( std-c-parse-struct-or-union(tokens).first == Some{CConstantInteger{c"0123456789"}} );
   };
}
