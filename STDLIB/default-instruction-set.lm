
type Reg8  AL  | BL  | CL  | DL  | SIL | DIL | BPL | SPL | R8B | R9B | R10B | R11B | R12B | R13B | R14B | R15B;
type Reg16 AX  | BX  | CX  | DX  | SI  | DI  | BP  | SP  | R8W | R9W | R10W | R11W | R12W | R13W | R14W | R15W;
type Reg32 EAX | EBX | ECX | EDX | ESI | EDI | EBP | ESP | R8D | R9D | R10D | R11D | R12D | R13D | R14D | R15D;
type Reg64 RAX | RBX | RCX | RDX | RSI | RDI | RBP | RSP | R8  | R9  | R10  | R11  | R12  | R13  | R14  | R15;

fragment syscall := λ. (: (.program( \t 'syscall \n )) Nil);

fragment push := λ(: l Constant+U64). (: ( (.program( \t 'pushq \t '$ l \n)) ) Nil);
fragment push := λ(: l Constant+I64). (: ( (.program( \t 'pushq \t '$ l \n)) ) Nil);

fragment cdecl::return := λ(: l Nil). (: () Nil);
fragment cdecl::return := λ(: l Reg8). (: (  (.program( \t 'mov \t '% (.expression l) , '%al \n))  (.expression 'al)  ) Nil);
fragment cdecl::return := λ(: l Reg16). (: (  (.program( \t 'mov \t '% (.expression l) , '%ax \n))  (.expression 'ax)  ) Nil);
fragment cdecl::return := λ(: l Reg32). (: (  (.program( \t 'mov \t '% (.expression l) , '%eax \n))  (.expression 'eax)  ) Nil);
fragment cdecl::return := λ(: l Reg64). (: (  (.program( \t 'mov \t '% (.expression l) , '%rax \n))  (.expression 'rax)  ) Nil);

fragment mov := λ(: src LocalVariable)(: dst Constant+Reg64). (: ( (.program( \t 'mov \t (.expression src) \[ '%rbp \] , \s '% (.expression dst) \n)) ) Nil);
fragment mov := λ(: src LocalVariable)(: dst Constant+Reg64). (: ( (.program( \t 'mov \t (.expression src) \[ '%rbp \] , \s '% (.expression dst) \n)) ) Nil);

fragment mov := λ(: src Constant+U8)(: dst LocalVariable). (: (.program( \t 'movb '$ src , \s (.expression dst) \[ '%rbp \] \n )) Nil);

fragment cmp := λ(: imm Constant+U64)(: r Constant+Reg64). (: (.program( \t 'cmp \s '$ imm , '% (.expression r) \n )) Nil);
fragment cmp := λ(: imm Constant+I64)(: r Constant+Reg64). (: (.program( \t 'cmp \s '$ imm , '% (.expression r) \n )) Nil);

fragment jge := λ(: dst Label). (: (.program( \t 'jge \s (.expression dst) \n )) Nil);
