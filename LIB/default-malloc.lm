
# type MallocBlock = {
#    block-size : U64
#    block-prev : *MallocBlock
#    block-next : *MallocBlock
#    [data] : U8[block-size]
# }

.block-size := λ(: b MallocBlock[]). (: (
   (let r ([]( (as b U64[]) 0_u64 )))
   r
) U64);
.block-prev := λ(: b MallocBlock[]). (: (
   (let r ([]( (as b U64[]) 1_u64 )))
   (as r MallocBlock[])
) MallocBlock[]);
.block-next := λ(: b MallocBlock[]). (: (
   (let r ([]( (as b U64[]) 2_u64 )))
   (as r MallocBlock[])
) MallocBlock[]);
.block-data := λ(: b MallocBlock[]). (: (
   (as (+( (as b U64) 24_u64 )) ?[])
) ?[]);

set.block-size := λ(: b MallocBlock[])(: sz U64). (: (
   (mov( sz 0_u64 (as b U64[]) ))
) Nil);
set.block-prev := λ(: b MallocBlock[])(: n MallocBlock[]). (: (
   (mov( (as n U64) 1_u64 (as b U64[]) ))
) Nil);
set.block-next := λ(: b MallocBlock[])(: n MallocBlock[]). (: (
   (mov( (as n U64) 2_u64 (as b U64[]) ))
) Nil);

malloc-block-head := 0_u64;
malloc-block-tail := 0_u64;
malloc-first-free := 0_u64;
malloc-page-tail := 0_u64;

malloc-new-page := λ. (: (
   (mov( 12_u64 RAX ))
   (mov( 0_u64 RDI ))
   (syscall())

   (mov( RAX R8 )) #current page break in R8
   (set malloc-block-head (as R8 U64))
   (set malloc-block-tail (as R8 U64))

   # 8 GB
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (add( 1073741824_u64 R8 ))
   (mov( 12_u64 RAX ))
   (mov( R8 RDI ))
   (syscall())

   (set malloc-page-tail (as R8 U64))

   # sys_brk initially zeroes memory for each process
   # so the first MallocBlock::header will be zero initialized
) Nil);

# increase size of data of previous allocated memory
mextend := λ (: sz U64). (: (
   # add parameter for base data pointer that should be extended
   # if room to bump before next block, then do bump
   # else fail

   (let data malloc-block-tail)
   (set malloc-block-tail (+( malloc-block-tail sz )))
   (as data ?[])
) ?[]);

can-fit := λ(: head MallocBlock[])(: sz U64). (: (
   (let fit 0_u64)
   (if (==( (as (.block-next head) U64) 0_u64 )) (
      (set fit 1_u64) # if there is no next block, then there is always room to extend memory
   ) (
      (set fit (<=(
         (+(
            (as head U64)
            (+(
               (+( 24_u64 (.block-size head) ))
               (+( 24_u64 sz ))
            ))
         ))
         (as (.block-next head) U64)
      )))
   ))
   fit
) U64);

print-count-malloc := 0_u64;

malloc := λ (: sz U64) . (: (
   (if (==( malloc-block-head 0_u64 )) (malloc-new-page()) ())

   #(let scan-head (as malloc-first-free MallocBlock[]))
   #(if (==( (as scan-head U64) 0_u64 )) (set scan-head (as malloc-block-head MallocBlock[])) ())
   (let scan-head (as malloc-block-head MallocBlock[]))

   (while (not(can-fit( (as scan-head MallocBlock[]) sz ))) (
      (print 'Cant\sFit\n_s)
      (print 'Block\sHead:\s_s)(print (as scan-head U64))(print '\n_s)
      (print 'Block\sSize:\s_s)(print (.block-size scan-head))(print '\n_s)
      (print 'Block\sPrev:\s_s)(print (as (.block-prev scan-head) U64))(print '\n_s)
      (print 'Block\sNext:\s_s)(print (as (.block-next scan-head) U64))(print '\n_s)
      (set scan-head (.block-next scan-head))
   ))

   (print 'Can\sFit\n_s)
   (print 'Block\sHead:\s_s)(print (as scan-head U64))(print '\n_s)
   (print 'Block\sSize:\s_s)(print (.block-size scan-head))(print '\n_s)
   (print 'Block\sPrev:\s_s)(print (as (.block-prev scan-head) U64))(print '\n_s)
   (print 'Block\sNext:\s_s)(print (as (.block-next scan-head) U64))(print '\n_s)

   (if (<( print-count-malloc 5_u64 )) (
      (set print-count-malloc (+( print-count-malloc 1_u64 )))
   ) (
      (exit 1_u64)
   ))

   # scan for existing free space starting from malloc-first-free | malloc-block-head
   # if no free space, then add new page to end
   # create new block
   #    block-size = sz
   #    block-prev = prev
   #    block-next = next
   # update prev.block-next = this
   # update next.block-prev = this
   # update malloc-first-free

   (let misalignment (%( malloc-block-tail 8_u64 )))
   (let alignment (%( (-( 8_u64 misalignment )) 8_u64 )))
   (set malloc-block-tail (+( malloc-block-tail alignment )))
   (print 'Tail\s_s)(print malloc-block-tail)(print '\n_s)
   (let block (as malloc-block-tail MallocBlock[]))
   (let data (+( (as block U64) 24_u64 )))
   (set malloc-block-tail (+( data sz )))

   (print 'Tail\s_s)(print malloc-block-tail)(print '\n_s)
   (print 'Block\s_s)(print (as block U64))(print '\n_s)

   # initialize block
   (set.block-next( scan-head block ))
   (set.block-size( block sz ))
   (set.block-next( block (as 0_u64 MallocBlock[]) ))
   (set.block-prev( block scan-head ))

   (as data ?[])
) ?[]);
