
type BTreeIs<k,v> (BTreeISBranch( U64 , k , v , BTreeIs<k,v>[] , BTreeIs<k,v>[] )) | BTreeIsEOF;
type BTreeEq<k,v> (BTreeEqBranch( U64 , k , v , BTreeEq<k,v>[] , BTreeEq<k,v>[] )) | BTreeEqEOF;

.lookup := 位(: index BTreeIs<k,v>)(: k k)(: default v). (: (tail(
   (let th (hash k))
   (let continue True_u8)
   (while (==( continue True_u8 )) (
      (let ih (.5 (as index BTreeIsBranch)))
      (if (==( th ih )) (
         (if (is( k (.4 (as index BTreeIsBranch)) )) (tail(
            (set default (.3 (as index BTreeIsBranch)))
            (set continue False_u8)
         )) ())
      ) ())
      (if (==( continue True_u8 )) (
         (if (<( ih th )) (
            (if (==( (as (.1 (as index BTreeIsBranch)) U64) 0_u64 )) (
               (set continue False_u8)
            ) (
               (set index (maybe-deref(.1 (as index BTreeIsBranch))))
            ))
         ) (
            (if (==( (as (.2 (as index BTreeIsBranch)) U64) 0_u64 )) (
               (set continue False_u8)
            ) (
               (set index (maybe-deref(.2 (as index BTreeIsBranch))))
            ))
         ))
      ) ())
   ))
   default
)) v);

.lookup := 位(: index BTreeEq<k,v>)(: k k)(: default v). (: (tail(
   (let th (hash k))
   (let continue True_u8)
   (while (==( continue True_u8 )) (
      (let ih (.5 (as index BTreeEqBranch)))
      (if (==( th ih )) (
         (if (==( k (.4 (as index BTreeEqBranch)) )) (tail(
            (set default (.3 (as index BTreeEqBranch)))
            (set continue False_u8)
         )) ())
      ) ())
      (if (==( continue True_u8 )) (
         (if (<( ih th )) (
            (if (==( (as (.1 (as index BTreeEqBranch)) U64) 0_u64 )) (
               (set continue False_u8)
            ) (
               (set index (maybe-deref(.1 (as index BTreeEqBranch))))
            ))
         ) (
            (if (==( (as (.2 (as index BTreeEqBranch)) U64) 0_u64 )) (
               (set continue False_u8)
            ) (
               (set index (maybe-deref(.2 (as index BTreeEqBranch))))
            ))
         ))
      ) ())
   ))
   default
)) v);

.bind := 位(: index BTreeIs<k,v>[])(: k k)(: v v). (: (tail(
   (let ht (hash k))
   (let continue True_u8)
   (let cell (close(BTreeIsBranch( ht k v (as 0_u64 BTreeIs<k,v>[]) (as 0_u64 BTreeIs<k,v>[]) ))))
   (while (==( continue True_u8 )) (tail(
      (let flat-index (maybe-deref index))
      (if (<( (.5 (as flat-index BTreeIsBranch)) ht )) (
         (if (==( (as (.1 (as flat-index BTreeIsBranch)) U64) 0_u64 )) (tail(
            (mov( (as cell U64) R8 ))
            (set[]( (as index Field<Sized<8>,1>[]) 1_u64 R8 ))
            (set continue False_u8)
         )) (
            (set index (.1 (as flat-index BTreeIsBranch)))
         ))
      ) (
         (if (==( (as (.2 (as flat-index BTreeIsBranch)) U64) 0_u64 )) (tail(
            (mov( (as cell U64) R8 ))
            (set[]( (as index Field<Sized<8>,1>[]) 2_u64 R8 ))
            (set continue False_u8)
         )) (
            (set index (.2 (as flat-index BTreeIsBranch)))
         ))
      ))
   )))
)) Nil);


.bind := 位(: index BTreeEq<k,v>[])(: k k)(: v v). (: (tail(
   (let ht (deep-hash k))
   (let continue True_u8)
   (let cell (close(BTreeEqBranch( ht k v (as 0_u64 BTreeEq<k,v>[]) (as 0_u64 BTreeEq<k,v>[]) ))))
   (while (==( continue True_u8 )) (tail(
      (let flat-index (maybe-deref index))
      (if (<( (.5 (as flat-index BTreeEqBranch)) ht )) (
         (if (==( (as (.1 (as flat-index BTreeEqBranch)) U64) 0_u64 )) (tail(
            (mov( (as cell U64) R8 ))
            (set[]( (as index Field<Sized<8>,1>[]) 1_u64 R8 ))
            (set continue False_u8)
         )) (
            (set index (.1 (as flat-index BTreeEqBranch)))
         ))
      ) (
         (if (==( (as (.2 (as flat-index BTreeEqBranch)) U64) 0_u64 )) (tail(
            (mov( (as cell U64) R8 ))
            (set[]( (as index Field<Sized<8>,1>[]) 2_u64 R8 ))
            (set continue False_u8)
         )) (
            (set index (.2 (as flat-index BTreeEqBranch)))
         ))
      ))
   )))
)) Nil);

