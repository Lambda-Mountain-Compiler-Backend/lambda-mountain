
type HashtableEq<k,v> (HashtableEq( occupied:U64 , capacity:U64 , contents:Tuple<k,v>[] ));

.bind := λ(: table HashtableEq<k,v>)(: key k)(: value v). (: (
   (let occupied (.3 table))
   (let capacity (.2 table))
   (let contents (.1 table))
   (if (>=( (*( occupied 3_u64 )) capacity )) (
      (print 'TODO\sGrow\sTable\n_s)(exit 1_u64)
   ) ())
  (print 'TODO\sinsert\skey-value\n_s)(exit 1_u64)
  table
) HashtableEq<k,v>);

.lookup := λ(: table HashtableEq<k,v>)(: key k)(: default v). (: (
   default
) v);

type HashtableIs<k,v> (HashtableIs( occupied:U64 , capacity:U64 , contents:Tuple<k,v>[] ));

.bind := λ(: table HashtableIs<k,v>)(: key k)(: value v). (: (
   (let occupied (.3 table))
   (let capacity (.2 table))
   (let contents (.1 table))
   (if (>=( (*( occupied 2_u64 )) capacity )) (
      (let new-capacity (max( 1000_u64 (*( occupied 3_u64 )) )))
      (let new-sizeof (*( (sizeof Tuple<k,v>) new-capacity )))
      (let new-contents (as (malloc new-sizeof) Tuple<k,v>[]))
      (memset( new-contents 0_u8 new-sizeof ))
      (let old-i 0_i64)
      (while (<( old-i capacity )) (
         (let old-kv ([]( contents old-i )))
         (if (mem-is-nonzero old-kv) (
            (match old-kv (
               ()
               ( (Tuple( old-k old-v )) (
                  (.bind( new-contents old-k old-v ))
               ))
            ))
         ) ())
         (set old-i (+( old-i 1_u64 )))
      ))
      (set contents new-contents)
   ) ())
   (print 'TODO\sinsert\skey-value\n_s)(exit 1_u64)
   table
) HashtableIs<k,v>);

.bind := λ(: table Tuple<k,v>[])(: key k)(: value v). (: (
   (print 'TODO\sInsert\n_s)(exit 1_u64)
) Nil);

.lookup := λ(: table HashtableIs<k,v>)(: key k)(: default v). (: (
   default
) v);
