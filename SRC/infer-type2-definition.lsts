
let visit-field-template(field-name: CString, base-type: Type, field-type: Type): Nil = (
   print("Expand field template: \{field-name} \{base-type} . \{field-type}\n");
);


let infer-type2-definition(term: AST): Nil = (
   match term { Typedef2{} => (); };
   let lhs-type = (term as Tag::Typedef2).lhs-type;
   let implies = (term as Tag::Typedef2).implies;
   let implements = (term as Tag::Typedef2).implements;
   let constraints = (term as Tag::Typedef2).constraints;
   let size = (term as Tag::Typedef2).size;
   let alias = (term as Tag::Typedef2).alias;
   let opaque-alias = (term as Tag::Typedef2).opaque-alias;
   let cases = (term as Tag::Typedef2).cases;
   for vector rhs-type in implies {
      add-quick-prop(lhs-type, lhs-type, rhs-type);
      add-weaken-quick-prop(lhs-type, lhs-type, rhs-type);
   };
   for vector rhs-type in implements {
      add-quick-prop(lhs-type, lhs-type, rhs-type);
      add-weaken-quick-prop(lhs-type, lhs-type, rhs-type);
      interface-implementors = cons( (lhs-type, rhs-type, term), interface-implementors );
   };
   for vector Tuple{v=first, ct=second} in constraints {
      print("Constraint: \{lhs-type} where \{v} : \{ct}\n");
   };
   if non-zero(size) then print("sizeof(\{lhs-type}) = \{size}\n");
   if non-zero(alias) then add-type-alias(lhs-type, alias);
   if non-zero(opaque-alias) then add-opaque-type-alias(lhs-type, opaque-alias);
   for vector Tuple{ case-tag=first, case-fields=second } in cases {
      print("Case '\{case-tag}'\n");
      for vector Tuple{ field-name=first, field-type=second } in case-fields {
         let guard = lhs-type && (if non-zero(case-tag) then t1(c"Tag::"+case-tag) else TAny);
         let field-wrapped-type = t2(c"Field::"+field-name, field-type);
         add-quick-prop(lhs-type, guard, field-wrapped-type);
         add-weaken-quick-prop(lhs-type, guard, field-wrapped-type);
         visit-field-template(field-name, guard, field-type);
      };
   };
);
