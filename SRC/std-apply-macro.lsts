
let std-apply-macro(tctx: Maybe<TContext>, t: AST): (TContext?, AST) = (
   match t {
      App{left:Var{mname=key}, margs=right} => (
         std-apply-macro(tctx, mname, margs);
      );
   }
);

let std-apply-macro(tctx: Maybe<TContext>, mname: CString, margs: AST): (TContext?, AST) = std-apply-macro(tctx, mname, margs, true);
let std-apply-macro-weak(tctx: Maybe<TContext>, mname: CString, margs: AST): (TContext?, AST) = std-apply-macro(tctx, mname, margs, false);

let std-apply-macro(tctx: Maybe<TContext>, mname: CString, margs: AST, strong: Bool): (TContext?, AST) = (
   let row = index-macro-table.lookup(mname, [] :: List<(Type,Type,AST)>);
   let peep-holes = TAny;
   let peeped = TAny;
   for Tuple{mtype=first, peep=second, mterm=third} in row {
      if non-zero(peep-holes) {
         if peep-holes != peep then fail("Error: Macros must have the same pre-inference expectation.\n\{mname} : \{peeped}\n\{mname} : \{mtype}\n");
      } else {
         peep-holes = peep;
         peeped = mtype;
      };
   };
   (let peeped-type, margs) = std-infer-peeped-arguments(tctx, margs, peep-holes);

   let matched = [] :: List<(Type,AST)>;
   for Tuple{mtype=first, mterm=third} in row {
      if can-unify(mtype, peeped-type) then matched = cons( (mtype,mterm), matched );
   }; 

   let dominant-type = TAny;
   let candidates = [] :: List<(Type,AST)>;
   for Tuple{mtype=first, mterm=second} in matched {
      if non-zero(dominant-type) {
         if can-unify(mtype,dominant-type) && can-unify(dominant-type,mtype) {
            candidates = cons( (mtype,mterm), candidates );
         } else if can-unify(dominant-type,mtype) {
            dominant-type = mtype;
            candidates = [(mtype,mterm)];
         } else if can-unify(mtype,dominant-type) { # existing is dominant, keep existing and ignore new
         } else fail("Conflicting type candidates encountered during macro specialization:\n\{mname} : \{dominant-type}\n\{mname} : \{mtype}\n");
      } else {
         dominant-type = mtype;
         candidates = [(mtype,mterm)];
      }
   };
   (tctx, let result) = std-apply-macro-candidates(tctx, mname, margs, candidates);
   if strong && not(non-zero(result)) then exit-error("Failed to Apply Macro: \{mname}", margs);
   if strong then (tctx, result) = std-infer-expr(tctx, result, false, Used, TAny);
   (tctx, result)
);

let std-infer-peeped-arguments(tctx: Maybe<TContext>, t: AST, peep: Type): (Type, AST) = (
   match peep {
      TGround{tag:c"Cons", parameters:[p2.. p1..]} => (
         match t {
            App{is-cons=is-cons, left=left, right=right} => (
               (let lt, let new-left) = std-infer-peeped-arguments(tctx, left, p1);
               (let rt, let new-right) = std-infer-peeped-arguments(tctx, right, p2);
               if not(is(left,new-left)) || not(is(right,new-right))
               then t = mk-cons-or-app(is-cons,new-left,new-right);
               (t3(c"Cons",lt,rt), t)
            );
            _ => fail("std-infer-peeped-arguments expected cons term: \{t}\n");
         }
      );
      TAny{} => (ta, t);
      TVar{} => (ta, t);
      _ => (
         (_, t) = std-infer-expr(tctx, t, false, Used, TAny);
         (typeof(t), t);
      );
   }
);
