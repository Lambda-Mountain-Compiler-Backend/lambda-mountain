
infer-global-context := λ(: td AST). (: (tail(
   (match td (
      ()
      ( (Typedef( (Lit base-type) case-constructors )) (tail(
         (let bt (maybe-deref(parse-type base-type)))
         (let size (infer-type-definition( bt case-constructors )))
         (match bt (
            ()
            ( (TGround( class TypeEOF )) (index-size-of-class( class size )) )
            ( _ () )
         ))
      )))
      ( (Glb( k (Abs( lhs (App( (Lit ':_s) (App( rhs (AType rhst) )) )) tlt )) )) (tail(
         (let lt (maybe-deref(typeof-lhs lhs)))
         (let return-type (maybe-deref(without-representation rhst)))
         (let return-type-2 (maybe-deref(guess-representation return-type)))
         (let ft (t3( 'Arrow_s lt return-type-2 )))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            td
         )))
      )))
      ( (Frg( k (Abs( lhs (App( (Lit ':_s) (App( rhs (AType rhst) )) )) atlt )) tlt )) (tail(
         (let lt (maybe-deref(typeof-lhs lhs)))
         (let ft (t3( 'Arrow_s lt rhst )))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            ASTEOF
         )))
      )))
      ( (Glb( k (App( (Lit ':_s) (App( rhs (AType rhst) )) )) )) (tail(
         (let kt (maybe-deref(tand( rhst (maybe-deref(t1 'GlobalVariable_s)) ))))
         (set global-type-context (TCtxBind(
            (close global-type-context) k kt ASTEOF
         )))
      )))
      ( (Frg( k (App( (Lit ':_s) (App( rhs (AType rhst) )) )) tlt )) (
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            rhst ASTEOF
         )))
      ))
      ( (Glb( k _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( (Frg( k _ tlt )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( _ () )
   ))
   ()
)) Nil);

assert-well-typed := λ(: term AST). (: (
   (match term (
      ()
      ( ASTEOF (assert-one-typed term) )
      ( ASTNil (assert-one-typed term) )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (
            (assert-well-typed v)
         ))
      ))
      ( (Frg( k v tlt )) (
         (assert-one-typed v)
      ))
      ( (Typedef( _ _ )) () )
      ( (App( (Abs( (Var lname) ASTNil tlt )) rhs )) (tail(
         (assert-well-typed rhs)
         (assert-one-typed term)
      )))
      ( (App( (Var 'gensym-label_s) _ )) () )
      ( (App( (Var 'label_s) (Var _) )) () )
      ( (App( (App( (Var 'while_s) cond )) body )) (tail(
         (assert-well-typed cond)
         (assert-well-typed body)
         (assert-one-typed term)
      )))
      ( (App( (App( (App( (Var 'if_s) cond )) t )) f )) (tail(
         (assert-well-typed cond)
         (assert-well-typed t)
         (assert-well-typed f)
         (assert-one-typed term)
      )))
      ( (App( (App( (Var 'set_s) lhs )) rhs )) (tail(
         (assert-well-typed rhs)
         (assert-one-typed term)
      )))
      ( (AType _) () )
      ( (App( (Var 'tail_s) (App( lterm rterm )) )) (tail(
         (assert-well-typed lterm)
         (assert-well-typed rterm)
         (assert-one-typed term)
      )))
      ( (App( (Var 'maybe-deref_s) rterm )) (tail(
         (assert-well-typed rterm)
         (assert-one-typed term)
      )))
      ( (App( (Var 'scope_s) rterm )) (tail(
         (assert-well-typed rterm)
         (assert-one-typed term)
      )))
      ( (Lit l) (assert-one-typed term) )
      ( (Var l) (assert-one-typed term) )
      ( (Abs( lhs rhs tlt )) (tail(
         (assert-well-typed rhs)
         (assert-one-typed term)
      )))
      ( (App( l r )) (tail(
         (assert-well-typed l)
         (assert-well-typed r)
         (assert-one-typed term)
      )))
      ( (Seq( l r )) (tail(
         (assert-well-typed l)
         (assert-well-typed r)
      )))
      ( term (tail(
         (print 'Typecheck\sAssert\sComplete\n_s)
         (exit 1_u64)
      )))
   ))
) Nil);

assert-one-typed := λ(: term AST). (: (
   (if (non-zero(maybe-deref(typeof term))) () (
      (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s term ))
   ))
) Nil);

annotate-fields := λ(: tt Type). (: (tail(
   (match (slot( tt 'Fields_s )) (
      ()
      ( (TGround( 'Fields_s _ )) () )
      ( _ (tail(
         (let class (with-only-class tt))
         (let tag (with-only-tag tt))
         (if (&&( (non-zero tag) (non-zero class) )) (tail(
            (let ft (fields-of-tag( tag class )))
            (set tt (TAnd( (close tt) (close ft) )))
         )) ())
      )))
   ))
   tt
)) Type);

infer-expr := λ(: tctx TContext)(: term AST)(: used IsUsed)(: hint Type). (: (tail(
   (match term (
      ()
      ( ASTNil (ascript-normal( term (maybe-deref(t1 'Nil_s)) )) )
      ( ASTEOF (ascript-normal( term (maybe-deref(t1 'Nil_s)) )) )
      ( (Seq( l r )) (tail(
         (infer-expr( tctx l used TAny ))
         (infer-expr( tctx r used TAny ))
      )))
      ( (Typedef( _ _ )) () )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (
            (infer-expr( tctx v Used TAny ))
         ))
      ))
      ( (Frg( k v tlt )) (
         (ascript-normal( v (maybe-deref(typeof term)) ))
      ))
      ( (App( (Lit ':_s) (App( (Lit _) (AType tt) )) )) (
         (match term (
            ()
            ( (App( _ (App( t _ )) )) (tail(
               (match (slot( tt 'String_s )) (
                  ()
                  ( (TGround( 'String_s _ )) () )
                  ( _ (infer-expr( tctx t used tt )) )
               ))
               (let it (maybe-deref(typeof t)))
               (if (non-zero it) (tail(
                  (let it-2 (maybe-deref(tand( it tt ))))
                  (set it it-2)
               )) (tail(
                  (set it tt)
                  (ascript-normal( t it ))
               )))
               (ascript-normal( term it ))
               (match term (
                  ()
                  ( (App( las ras )) (tail(
                     (ascript-normal( las it ))
                     (ascript-normal( ras it ))
                  )))
               ))
            )))
         ))
      ))
      ( (App( (Lit ':_s) (App( t (AType tt) )) )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx t used tt ))))
         (set tctx tctx2)
         (let inner-tt (maybe-deref(typeof t)))
         (if (non-zero inner-tt) (tail(
            (let nn (with-only-representation inner-tt))
            (if (non-zero nn) (tail(
               (let tt-2 (maybe-deref(tand(
                  tt
                  nn
               ))))
               (set tt tt-2)
            )) ())
            (ascript-normal( t tt ))
            (ascript-normal( term tt ))
            (match term (
               ()
               ( (App( las ras )) (tail(
                  (ascript-normal( las tt ))
                  (ascript-normal( ras tt ))
               )))
            ))
         )) ())
      )))
      ( (App( (Var 'gensym-label_s) (Var lname) )) (tail(
         (let tctx2 (TCtxBind(
            (close tctx)
            lname
            (t1 'Label_s)
            ASTEOF
         )))
         (set tctx tctx2)
         (ascript-normal( term (maybe-deref(t1 'Nil_s)) ))
      )))
      ( (App( (App( (Var 'set_s) (Var v) )) rhs )) (tail(
         (infer-expr( tctx rhs Used TAny ))
         (ascript-normal( rhs (maybe-deref(typeof-var( term tctx v ))) ))
         (ascript-normal( term (maybe-deref(t1 'Nil_s)) ))
      )))
      ( (App( (Var 'label_s) (Var lname) )) (
         (ascript-normal( term (maybe-deref(t1 'Nil_s)) ))
      ))
      ( (App( (App( (App( (Var 'if_s) cond )) t )) f )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx cond Used TAny ))))
         (let tctx3 (maybe-deref(infer-expr( tctx2 t Used TAny ))))
         (set tctx tctx3)
         (infer-expr( tctx f Used TAny ))
         (ascript-normal( term (maybe-deref(typeof t)) ))
      )))
      ( (App( (App( (Var 'while_s) cond )) body )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx cond Used TAny ))))
         (set tctx tctx2)
         (infer-expr( tctx body Used TAny ))
         (ascript-normal( term (maybe-deref(t1 'Nil_s)) ))
      )))
      ( (App( (Var 'tail_s) (App( l r )) )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx l Unused TAny ))))
         (let tctx3 (maybe-deref(infer-expr( tctx2 r used TAny ))))
         (set tctx tctx3)
         (ascript-normal( term (maybe-deref(typeof r)) ))
      )))
      ( (App( (Var 'as_s) (App( t (AType tt) )) )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx t used TAny ))))
         (set tctx tctx2)
         (let inner-tt (maybe-deref(typeof t)))
         (if (non-zero inner-tt) (tail(
            (let nn (with-only-representation inner-tt))
            (if (non-zero nn) (tail(
               (let tt-2 (maybe-deref(tand(
                  tt
                  nn
               ))))
               (set tt tt-2)
            )) ())
            (let nn (maybe-deref(with-only-class inner-tt)))
            (if (non-zero nn) (tail(
               (let tt-2 (maybe-deref(tand(
                  tt
                  nn
               ))))
               (set tt tt-2)
            )) ())
            (set tt (annotate-fields( tt )))
            (ascript-normal( term tt ))
            (match term (
               ()
               ( (App( a b )) (tail( (ascript-normal( a tt )) (ascript-normal( b tt )) )) )
            ))
         )) ())
      )))
      ( (App( (Var 'sizeof_s) (AType _) )) (tail(
         (let tt (maybe-deref(as-constant(maybe-deref(parse-type 'U64_s)))))
         (ascript-normal( term tt ))
         (match term (
            ()
            ( (App( s _ )) (ascript-normal( s tt )) )
         ))
      )))
      ( (App( (Var 'scope_s) r )) (tail(
         (infer-expr( tctx r used TAny ))
         (ascript-normal( term (typeof r) ))
      )))
      ( (App( (Var 'maybe-deref_s) r )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx r used TAny ))))
         (set tctx tctx2)
         (let deref-type (maybe-deref(typeof r)))
         (match (slot( deref-type 'Array_s )) (
            ()
            ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF TAny )) _ )) )) () )
            ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF array-base )) TAny )) )) (tail(
               (let deref-type-2 (maybe-deref(tand( array-base (t1 'StackVariable_s) ))))
               (set deref-type deref-type-2)
            )))
            ( _ () )
         ))
         (ascript-normal( term deref-type ))
      )))
      ( (App( (Abs( (Var lname) ASTNil tlt )) rhs )) (tail(
         (infer-expr( tctx rhs Used TAny ))
         (let tt (maybe-deref(typeof rhs)))
         (let rt (maybe-deref(as-local-variable(tt))))
         (if (non-zero tt) () (
            (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s rhs ))
         ))
         (if (non-zero rt) () (
            (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s rhs ))
         ))
         (set tctx (TCtxBind(
            (close tctx)
            lname
            rt
            ASTEOF
         )))
         (ascript-normal( term (maybe-deref(t1 'Nil_s)) ))
      )))
      ( (App( l r )) (tail(
         (let tctx2 (maybe-deref(infer-expr( tctx l Used TAny ))))
         (let tctx3 (maybe-deref(infer-expr( tctx2 r Used TAny ))))
         (set tctx tctx3)
         (let rt (maybe-deref(apply-hard(
            term
            (maybe-deref(typeof l))
            (maybe-deref(typeof r))
         ))))
         (ascript-normal( term rt ))
      )))
      ( (Abs( lhs rhs tlt )) (tail(
         (let tctx2 (maybe-deref(infer-ctx( tctx lhs ))))
         (set tctx tctx2)
         (infer-expr( tctx rhs Used TAny ))
         (let lt (maybe-deref(typeof-lhs lhs)))
         (let rt (maybe-deref(typeof rhs)))
         (ascript-normal( term (t3( 'Arrow_s lt rt )) ))
      )))
      ( (Var v) (
         (ascript-normal( term (maybe-deref(typeof-var( term tctx v ))) ))
      ))
      ( (Lit l) (
         (if (non-zero(typeof term)) () (tail(
            (let tt (maybe-deref(typeof-tag l)))
            (if (non-zero tt) (tail(
               (if (non-zero hint) (
                  (set tt (unify-hint( hint tt )))
               ) ())
               (ascript-normal( term tt ))
            )) ())
         )))
      ))
      ( _ (tail(
         (print 'Unknown\sTerm\sIn\sType\sInference\n_s)
         (print term)
         (print '\n_s)
         (exit 1_u64)
      )))
   ))
   (close tctx)
)) TContext[]);

apply-plural := λ(: sloc AST)(: many Type)(: pt Type). (: (tail(
   (let tt (apply-plural( sloc many pt True_u8 )))
   tt
)) Type);

apply-plural := λ(: sloc AST)(: many Type)(: pt Type)(: do-specialize U8). (: (tail(
   (let r TAny)
   (match many(
      ()
      ( (TAnd( t1 t2 )) (tail(
         (let r1 (maybe-deref(apply-plural( sloc t1 pt do-specialize ))))
         (if (non-zero r1) (set r r1) (tail(
            (let r2 (maybe-deref(apply-plural( sloc t2 pt do-specialize ))))
            (set r r2)
         )))
      )))
      ( (TGround( 'Arrow_s _ )) (tail(
         (let r1 (maybe-deref(apply-hard( sloc many pt do-specialize ))))
         (set r r1)
      )))
      ( _ () )
   ))
   r
)) Type);

apply-hard := λ(: sloc AST)(: ft Type)(: pt Type). (: (tail(
   (let tt (apply-hard( sloc ft pt True_u8 )))
   tt
)) Type[]);

apply-hard := λ(: sloc AST)(: ft Type)(: pt Type)(: do-specialize U8). (: (tail(
   (let key '_s)
   (match sloc (
      ()
      ( (App( (Var k) _ )) (set key k) )
      ( _ () )
   ))
   (let rt TAny)
   (if (is-arrow ft) (
      (match ft (
         ()
         ( (TAnd( ft1 ft2 )) (tail(
            (let rt1 (maybe-deref(apply-hard( sloc ft1 pt ))))
            (if (non-zero rt1) (
               (set rt rt1)
            ) (tail(
               (let rt2 (maybe-deref(apply-hard( sloc ft2 pt ))))
               (set rt rt2)
            )))
         )))
         ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF fpt )) frt )) )) (tail(
            (let ctx (unify( fpt pt )))
            (if (non-zero ctx) (tail(
               (let ctx-2 (normalize ctx))(set ctx ctx-2)
               (let closed-type (substitute( ctx ft )))
               (let rt1 (maybe-deref(guess-representation(substitute( ctx frt )))))
               (set rt rt1)
               (if (==( do-specialize True_u8 )) (
                  (if (head-string key) (
                     (if (is-closing ctx) (
                        (try-specialize( key ft ctx closed-type ))
                     ) ())
                  ) ())
               ) ())
            )) ())
         )))
         ( _ () )
      ))
   ) (
      (if (non-zero ft) (
         (if (non-zero pt) (tail(
            (let rt2 (TGround(
               'Cons_s
               (close(TypeSeq(
                  (close(TypeSeq(
                     (close TypeEOF)
                     ft
                  )))
                  pt
               )))
            )))
            (set rt rt2)
         )) ())
      ) ())
   ))
   (close rt)
)) Type[]);

specialize-term := λ(: tctx StringSList)(: t S). (: (tail(
   (match t (
      ()
      ( SNil (set t SNil) )
      ( (SAtom a) (
         (while (non-zero tctx) (match tctx (
            ()
            ( (SSLSeq( rst k v )) (tail(
               (if (==( a k )) (
                  (set t v)
               ) ())
               (set tctx rst)
            )))
         )))
      ))
      ( (SCons( lt rt )) (
         (set t (SCons(
            (close(specialize-term( tctx lt )))
            (close(specialize-term( tctx rt )))
         )))
      ))
   ))
   (let rt t)
   rt
)) S);

try-specialize := λ(: key String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (tail(
   (let result-type-2 (normalize result-type))(set result-type result-type-2)
   (let global-ctx global-type-context)
   (if (is-special( key result-type )) () (
      (while (non-zero global-ctx) (match global-ctx (
         ()
         ( TCtxNil (set global-ctx TCtxEOF) )
         ( (TCtxBind( rst k kt t )) (tail(
            (if (is( ft kt )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (
                     (specialize( key ft unify-ctx result-type ))
                  ))
                  ( _ () )
               ))
            ) ())
            (set global-ctx rst)
         )))
      )))
   ))
)) Nil);

is-closing := λ(: tctx TContext). (: (tail(
   (let r 0_u64)
   (while (non-zero tctx) (match tctx (
      ()
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst 'Accept_s _ _ )) (set tctx rst) )
      ( (TCtxBind( rst _ _ _ )) (tail(
         (set r 1_u64)
         (set tctx TCtxEOF)
      )))
   )))
   r
)) U64);

right-if-not-left := λ(: lt Type)(: rt Type). (: (tail(
   (match (Pair( lt rt )) (
      ()
      ( (Pair( _ (TGround( 'Arrow_s _ )) )) () )
      ( (Pair( (TGround( ltag _ )) (TGround( rtag _ )) )) (
         (if (==( ltag rtag )) (set rt TAny) ())
      ))
      ( (Pair( (TAnd( lt1 lt2 )) (TGround( rtag _ )) )) (tail(
         (let llt1 (maybe-deref(right-if-not-left( lt1 rt ))))
         (let llt2 (maybe-deref(right-if-not-left( lt2 rt ))))
         (if (non-zero llt1) () (set rt TAny))
         (if (non-zero llt2) () (set rt TAny))
      )))
      ( (Pair( _ (TAnd( rt1 rt2 )) )) (tail(
         (let rrt1 (maybe-deref(right-if-not-left( lt rt1 ))))
         (let rrt2 (maybe-deref(right-if-not-left( lt rt2 ))))
         (if (non-zero rrt1) (
            (if (non-zero rrt2) (
               (set rt (TAnd(
                  (close rrt1)
                  (close rrt2)
               )))
            ) (
               (set rt rrt1)
            ))
         ) (
            (if (non-zero rrt2) (
               (set rt rrt2)
            ) (
               (set rt TAny)
            ))
         ))
      )))
      ( _ () )
   ))
   (close rt)
)) Type[]);

tand := λ(: lt Type)(: rt Type). (: (tail(
   (if (non-zero lt) (tail(
      (let only-rt (maybe-deref(right-if-not-left( lt rt ))))
      (if (non-zero only-rt) (
         (set lt (TAnd(
            (close lt)
            (close only-rt)
         )))
      ) ())
   )) (set lt rt))
   (close lt)
)) Type[]);

infer-tctx := λ(: tctx TContext)(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst p1 )) (tail(
         (set tctx (infer-tctx( tctx rst )))
         (set tctx (infer-tctx( tctx p1 )))
      )))
   ))
   tctx
)) TContext);

infer-tctx := λ(: tctx TContext)(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (set tctx (infer-tctx( tctx lt )))
         (set tctx (infer-tctx( tctx rt )))
      )))
      ( (TVar( tv )) (
         (set tctx (TCtxBind(
            (close tctx)
            tv
            (t1 'Constant_s)
            ASTEOF
         )))
      ))
      ( (TGround( _ ts )) (
         (set tctx (infer-tctx( tctx ts )))
      ))
      ( TAny () )
   ))
   tctx
)) TContext);

infer-ctx := λ(: tctx TContext)(: lhs AST). (: (tail(
   (match lhs (
      ()
      ( (App( (Lit ':_s) (App( (Var v) (AType tt) )) )) (tail(
         (set tctx (TCtxBind(
            (close tctx)
            v
            (maybe-deref(as-local-variable tt))
            ASTEOF
         )))
         (set tctx (infer-tctx( tctx tt )))
      )))
      ( (App( ps (App( (Lit ':_s) (App( (Var v) (AType tt) )) )) )) (tail(
         (set tctx (TCtxBind(
            (close tctx)
            v
            (maybe-deref(as-local-variable tt))
            ASTEOF
         )))
         (let tctx2 (maybe-deref(infer-ctx( tctx ps ))))
         (set tctx tctx2)
         (set tctx (infer-tctx( tctx tt )))
      )))
      ( ASTNil () )
      ( _ (exit-error( 'Invalid\sLHS_s lhs )) )
   ))
   (close tctx)
)) TContext[]);

typeof-var := λ(: sloc AST)(: tctx TContext)(: vname String). (: (tail(
   (let found TAny)
   (while (non-zero tctx) (match tctx (
      ()
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k vt _ )) (
         (if (==( k vname )) (tail(
            (if (non-zero found) (
               (if (is-arrow vt) (tail(
                  (let found-2 (maybe-deref(tand(
                     found
                     vt
                  ))))
                  (set found found-2)
               )) (
                  (set found vt)
               ))
            ) (
               (set found vt)
            ))
            (if (is-arrow vt) (
               (set tctx rst)
            ) (
               (set tctx TCtxEOF)
            ))
         )) (
            (set tctx rst)
         ))
      ))
   )))
   (if (non-zero found) () (
      (exit-error( 'Unknown\sReferenced\sVariable_s sloc ))
   ))
   (close found)
)) Type[]);

