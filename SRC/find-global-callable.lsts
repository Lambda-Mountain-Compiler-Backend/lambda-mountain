
let find-global-callable(fname: CString, arg-types: Type): AST = (
   arg-types = denormalize-strong(arg-types);
   fname = find-alias(fname, arg-types);
   let match-set = mk-vector(type((Type,AST)), 16);
   for Tuple{kt=first, t=second} in global-type-context.lookup(fname, [] :: List<Tuple<Type,AST>>) {
      if non-zero(apply-plural(kt, arg-types)) {
         match-set = match-set.push( (kt, t) );
      }
   };
   let result = ASTEOF;
   for vector Tuple{kt1=first, t1=second} in match-set { if not(non-zero(result)) {
      let all-accept = true;
      for vector Tuple{kt2=first, t2=second} in match-set {
         if not(is(t1,t2) || most-special(kt1,kt2)!=kt1 ) then all-accept = false;
      };
      if all-accept { result = t1 };
   }};
   if not(non-zero(result)) && match-set.length > 0 {
      eprint("Unable to find unambiguous global callable: \{fname} \{arg-types}\n");
      for vector Tuple{kt=first, t=second} in match-set {
         eprint("\{kt}\n");
      };
   };
   if not(non-zero(result)) then fail("Unable to find appropriate global callable: \{fname} \{arg-types}\n");
   result
);
