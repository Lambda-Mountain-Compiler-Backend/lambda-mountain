
let quick-prop = {} :: HashtableEq<(String,U64),List<(Type,Type)>>;

let .ground-tag-and-arity(tt: Type): (String,U64) = (
   match tt {
      TGround { tag=tag, parameters=parameters } => (intern(tag), parameters.length);
      _ => fail("Called .ground-tag-and-arity on non-ground type: \{tt}");
   }
);

let add-quick-prop(pre: Type, post: Type): Nil = (
   print("Add QuickProp: \{pre} => \{post}\n");
   let key = pre.ground-tag-and-arity;
   let val = quick-prop.lookup(key, ([] :: List<(Type,Type)>));
   val = cons( (pre,post), val );
   quick-prop = quick-prop.bind( key, val );
);

let enrich-quick-prop(pre: Type): Type = (
   match pre {
      TGround { tag=tag, parameters=parameters } => (
         let ps = [] :: List<Type>;
         for p in parameters.reverse {
            ps = cons( enrich-quick-prop(p), ps );
         };
         pre = TGround { tag, close(ps) };
         for Tuple { lt=first, rt=second } in quick-prop.lookup( pre.ground-tag-and-arity, ([] :: List<(Type,Type)>) ) {
            if can-unify(lt, pre) then (
               let tctx = unify(lt, pre);
               let post = substitute(tctx, rt);
               pre = TAnd { close(pre), close(post) };
            )
         }
      );
      _ => ();
   }; pre
);

