
import LIB/default.lm;
import SRC/index-definitions.lm;
import SRC/t.lm;

let print(tt: Type): Nil = print(to-smart-string(tt));

let quick-prop = {} :: HashtableEq<(String,U64),List<(Type,Type)>>;

let .ground-tag-and-arity(tt: Type): (String,U64) = (
   match tt {
      TGround { tag=tag, parameters=parameters } => (intern(tag), parameters.length);
      _ => fail("Called .ground-tag-and-arity on non-ground type: \{tt}");
   }
);

let add-quick-prop(pre: Type, post: Type): Nil = (
   let key = pre.ground-tag-and-arity;
   let val = quick-prop.lookup(key, ([] :: List<(Type,Type)>));
   val = cons( (pre,post), val );
   quick-prop = quick-prop.bind( key, val );
);

let enrich-quick-prop(pre: Type): Type = (
   match pre {
      TGround { tag=tag, parameters=parameters } => (
         #for Tuple { lt, rt } in quick-prop.lookup( pre.ground-tag-and-arity, ([] :: List<(Type,Type)>) ) {
         #   print("Enrich \{pre} with \{lt} => \{rt}\n");
            # dont forget to unify and substitute tctx
         #}
         # dont forget to recurse into parameters too
      );
      _ => ();
   }; pre
);

add-quick-prop( t1(untern("A")), TAnd{ close(t1(untern("B"))), close(t1(untern("C"))) } );
add-quick-prop( t1(untern("B")), TAnd{ close(t1(untern("C"))), close(t1(untern("D"))) } );
print(enrich-quick-prop( t1(untern("A")) ));
