
# global Tag -> Class map, mutable
tag-to-class-index := (: BTreeEqEOF BTreeEq<String,Type>);

# global Class -> Yes/No map, mutable
class-to-yes-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Tag -> Fields map, mutable
tag-to-fields-index := (: BTreeEqEOF BTreeEq<String,Type>);

# global Tag -> IsFragment? map, mutable
tag-is-fragment-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Class -> Size map, mutable
class-to-size-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Tag -> Index map, mutable
tag-to-index-index := (: BTreeEqEOF BTreeEq<String,U64>);
unknown-index-of-tag := 99999_u64;

# Global Tag -> Type map, mutable
type-constructors-index := (: BTreeEqEOF BTreeEq<String,Type>);

# Global Tag -> (Type,Type) base-type to fields-type map, mutable
type-complex-fields-index := (: BTreeEqEOF BTreeEq<String,Tuple<Type,Type>>);

# has typechecking finished? boolean, mutable
types-have-changed := True_u8;

index-of-tag := λ(: tag String). (: (tail(
   (let r (.lookup( tag-to-index-index tag unknown-index-of-tag )))
   r
)) U64);

index-index-of-tag := λ(: tag String)(: index U64). (: (
   (.bind( (as (& tag-to-index-index) BTreeEq<String,U64>[]) tag index ))
) Nil);

index-size-of-class := λ(: class String)(: size U64). (: (
   (.bind( (as (& class-to-size-index) BTreeEq<String,U64>[]) class size ))
) Nil);

size-of-class := λ(: class String). (: (
   (.lookup( class-to-size-index class 0_u64 ))
) U64);

index-tag-is-fragment := λ(: tag String). (: (
   (.bind( (as (& tag-is-fragment-index) BTreeEq<String,U64>[]) tag 1_u64 ))
) Nil);

is-fragment := λ(: tag String). (: (
   (.lookup( tag-is-fragment-index tag 0_u64 ))
) U64);

is-fragment := λ(: tt Type). (: (
   (is-fragment(tag-of tt))
) U64);

tag-of := λ(: tt Type). (: (tail(
   (let tag '_s)
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let ltag (tag-of lt))
         (if (non-zero ltag) (set tag ltag) ())
         (let rtag (tag-of rt))
         (if (non-zero rtag) (set tag rtag) ())
      )))
      ( (TGround( tg _ )) (set tag tg) )
      ( _ () )
   ))
   tag
)) String);

index-class-of-tag := λ(: tag String)(: class Type). (: (tail(
   (.bind( (as (& tag-to-class-index) BTreeEq<String,Type>[]) tag class ))
   (match class (
      ()
      ( (TGround( cls _ )) (
         (.bind( (as (& class-to-yes-index) BTreeEq<String,U64>[]) cls 1_u64 ))
      ))
      ( _ (tail(
         (print 'Unexpected\sClass\sIn\sindex-class-of-tag:\s_s)(print class)(print '\n_s)
         (exit 1_u64)
      )))
   ))
)) Nil);

class-of-tag := λ(: tag String). (: (tail(
   (let r (.lookup( tag-to-class-index tag TAny )))
   r
)) Type);

is-class := λ(: tag String). (: (tail(
   (let r (.lookup( class-to-yes-index tag 0_u64 )))
   r
)) U64);

index-fields-of-tag := λ(: tag String)(: fields Type). (: (
   (.bind( (as (& tag-to-fields-index) BTreeEq<String,Type>[]) tag fields ))
) Nil);

fields-of-tag := λ(: tag String). (: (tail(
   (let r (.lookup( tag-to-fields-index tag TAny )))
   r
)) Type);

slot := λ(: tt Type)(: sl String). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TGround( bt _ )) (
         (if (==( bt sl )) (set rt tt) ())
      ))
      ( (TAnd( ltt rtt )) (tail(
         (let lt2 (slot( ltt sl )))
         (if (non-zero lt2) (
            (set rt lt2)
         ) (tail(
            (let rt2 (slot( rtt sl )))
            (set rt rt2)
         )))
      )))
      ( _ () )
   ))
   rt
)) Type);

domain := λ(: tt Type). (: (tail(
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p1) )
      ( _ () )
   ))
   r
)) Type);

range := λ(: tt Type). (: (tail(
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p2) )
      ( _ () )
   ))
   r
)) Type);

is-open := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar _) (set r 1_u64) )
      ( (TAnd( lt rt )) (tail(
         (if (is-open lt) (set r 1_u64) ())
         (if (is-open rt) (set r 1_u64) ())
      )))
      ( (TGround( _ pars )) (
         (while (non-zero pars) (match pars (
            ()
            ( (TypeSeq( rst p1 )) (tail(
               (if (is-open p1) (set r 1_u64) ())
               (set pars rst)
            )))
         )))
      ))
   ))
   r
)) U64);

is-arrow := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s _ )) (set r 1_u64) )
      ( _ () )
   ))
   r
)) U64);

t3 := λ(: tag String)(: p1 Type)(: p2 Type). (: (tail(
   (let tt (TGround(
      tag
      (close(TypeSeq( (close(TypeSeq( (close TypeEOF) p1 ))) p2 )))
   )))
   tt
)) Type);

t2 := λ(: tag String)(: p1 Type). (: (tail(
   (let tt (TGround(
      tag
      (close(TypeSeq( (close TypeEOF) p1 )))
   )))
   tt
)) Type);

t1 := λ(: tag String). (: (tail(
   (let tt (TGround(
      tag
      (close TypeEOF)
   )))
   tt
)) Type);

tsized :=  λ(: tag String). (: (tail(
   (let tt (t2( 'Sized_s (t1 tag) )))
   tt
)) Type);

substitute := λ(: tctx TContext)(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst par )) (
         (set tt (TypeSeq(
            (close(substitute( tctx rst )))
            (substitute( tctx par ))
         )))
      ))
   ))
   tt
)) TypeList);

substitute := λ(: tctx TContext)(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TVar v) (
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv _ )) (
               (if (==( tk v )) (tail(
                  (set tt tv)
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      ))
      ( (TGround( tag pars )) (
         (set tt (TGround(
            tag
            (close(substitute( tctx pars )))
         )))
      ))
      ( (TAnd( lt rt )) (
         (set tt (TAnd(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( _ () )
   ))
   tt
)) Type);

substitute-lhs := λ(: tctx TContext)(: t AST). (: (tail(
   (match t (
      ()
      ( (App( ps (App( (Lit ':_s) (App( (Var v) (AType vt) )) )) )) (
         (set t (App(
            (close(substitute-lhs( tctx ps )))
            (close(App( (close(Lit(clone-rope(SAtom ':_s)))) (close(App(
               (close(Var(clone-rope(SAtom v))))
               (close(AType( (substitute( tctx vt )) )))
            ))) )))
         )))
      ))
      ( (App( (Lit ':_s) (App( (Var v) (AType vt) )) )) (
         (set t (App( (close(Lit(clone-rope(SAtom ':_s)))) (close(App(
            (close(Var(clone-rope(SAtom v))))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
      ))
      ( (App( ps (Var v) )) (
         (set t (App(
            (close(substitute-lhs( tctx ps )))
            (close(Var(clone-rope(SAtom v))))
         )))
      ))
      ( (Var v) (set t (Var(clone-rope(SAtom v)))) )
      ( ASTNil () )
      ( _ (exit-error( 'Unexpected\sSubstitute\sLHS_s t )) )
   ))
   t
)) AST);

substitute := λ(: tctx TContext)(: t AST). (: (tail(
   (match t (
      ()
      ( ASTEOF () )
      ( ASTNil () )
      ( (App( (Lit ':_s) (App( (Lit v) (AType vt) )) )) (tail(
         (set t (App( (close(Lit(clone-rope(SAtom ':_s)))) (close(App(
            (close(Lit(clone-rope(SAtom v))))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv ta )) (
               (if (==( tk v )) (tail(
                  (set t (App( (close(Lit(clone-rope(SAtom ':_s)))) (close(App(
                     (close(substitute( tctx ta )))
                     (close(AType( (substitute( tctx vt )) )))
                  ))) )))
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      )))
      ( (App( (Lit ':_s) (App( (Var v) (AType vt) )) )) (tail(
         (set t (App( (close(Lit(clone-rope(SAtom ':_s)))) (close(App(
            (close(Var(clone-rope(SAtom v))))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv ta )) (
               (if (==( tk v )) (tail(
                  (set t (App( (close(Lit(clone-rope(SAtom ':_s)))) (close(App(
                     (close(substitute( tctx ta )))
                     (close(AType( (substitute( tctx vt )) )))
                  ))) )))
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      )))
      ( (Lit v) (set t (Lit(clone-rope(SAtom v)))) )
      ( (Var v) (set t (Var(clone-rope(SAtom v)))) )
      ( (Abs( lhs rhs tt )) (
         (set t (Abs(
            (close(substitute-lhs( tctx lhs )))
            (close(substitute( tctx rhs )))
            (substitute( tctx tt ))
         )))
      ))
      ( (AType( tt )) (
         (set t (AType( (substitute( tctx tt )) )))
      ))
      ( (App( lt rt )) (
         (set t (App(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Seq( lt rt )) (
         (set t (Seq(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Glb( k rt )) (
         (set t (Glb(
            k
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Typedef( lt rt )) (
         (set t (Typedef(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Frg( k lt tt )) (
         (set t (Frg(
            k
            (close(substitute( tctx lt )))
            (substitute( tctx tt ))
         )))
      ))
   ))
   ()
   t
)) AST);

union := λ(: lctx TContext)(: rctx TContext). (: (tail(
   (match rctx (
      ()
      ( TCtxNil (set rctx TCtxEOF) )
      ( (TCtxBind( rst k v t )) (tail(
         (set lctx (union( lctx rst )))
         (set lctx (TCtxBind( (close lctx) k v t )))
      )))
      ( _ () )
   ))
   lctx
)) TContext);

without-tag := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt1 (without-tag lt))
         (let rt1 (without-tag rt))
         (match (Pair( lt1 rt1 )) (
            ()
            ( (Pair( TAny rt2 )) (set tt rt2) )
            ( (Pair( lt2 TAny )) (set tt lt2) )
            ( (Pair( lt2 rt2 )) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ))
         ))
      )))
      ( (TGround( 'Constructor_s _ )) (set tt TAny) )
      ( (TGround( 'Tag_s _ )) (set tt TAny) )
      ( tt () )
   ))
   tt
)) Type);

without-open := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt1 (without-open lt))
         (let rt1 (without-open rt))
         (match (Pair( lt1 rt1 )) (
            ()
            ( (Pair( TAny rt2 )) (set tt rt2) )
            ( (Pair( lt2 TAny )) (set tt lt2) )
            ( (Pair( lt2 rt2 )) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ))
         ))
      )))
      ( _ (if (is-open tt) (set tt TAny) ()))
   ))
   tt
)) Type);

without-tag := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq( (close(without-tag rst)) (without-tag p1) )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

with-only-tag := λ(: tt Type). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TAnd( lt1 rt1 )) (tail(
         (let lc (with-only-tag lt1))
         (if (non-zero lc) (set rt lc) ())
         (let rc (with-only-tag rt1))
         (if (non-zero rc) (set rt rc) ())
      )))
      ( (TGround( 'Tag_s _ )) (set rt tt) )
      ( _ () )
   ))
   rt
)) Type);

with-only-class := λ(: tt Type). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TAnd( lt1 rt1 )) (tail(
         (let lc (with-only-class lt1))
         (if (non-zero lc) (set rt lc) ())
         (let rc (with-only-class rt1))
         (if (non-zero rc) (set rt rc) ())
      )))
      ( (TGround( tag _ )) (
         (if (is-class tag) (
            (if (not(is-fragment tag)) (
               (set rt tt)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   rt
)) Type);

without-representation := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-representation rst))
            (without-representation p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

without-representation := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-representation lt))
         (let rt2 (without-representation rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( 'Constant_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Literal_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'StackVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'LocalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'GlobalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg8_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg16_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg32_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg64_s TypeEOF )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-representation ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

without-size := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-size rst))
            (without-size p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

without-size := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-size lt))
         (let rt2 (without-size rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( 'Sized_s sz )) (set tt TAny) )
      ( (TGround( 'FieldsSized_s sz )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

without-size-unless-class := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-size-unless-class rst))
            (without-size-unless-class p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

without-size-unless-class := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-size-unless-class-inner lt))
         (let rt2 (without-size-unless-class-inner rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size-unless-class ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

without-size-unless-class-inner := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-size-unless-class-inner lt))
         (let rt2 (without-size-unless-class-inner rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( 'FieldsSized_s _ )) (set tt TAny) )
      ( (TGround( 'Sized_s _ )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size-unless-class ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

normalize := λ(: tt Type). (: (tail(
   (let rt tt)
   (set rt (without-representation rt))
   (set rt (without-tag rt))
   # Sized can serve as a datatype if nothing else is available
   (set rt (without-size-unless-class rt))
   rt
)) Type);

print := λ(: tt Type). (: (match tt (
   ()
   ( TAny (print '?_s) )
   ( (TVar( vn )) (print vn) )
   ( (TGround( tag TypeEOF )) (print tag) )
   ( (TAnd( lt (TGround( 'Arrow_s rs )) )) (tail(
      (print lt)
      (print '\s+\sArrow<_s)
      (print rs)
      (print '>_s)
   )))
   ( (TAnd( lt rt )) (tail(
      (print lt)
      (print '\s+\s_s)
      (print rt)
   )))
   ( (TGround( tag ps )) (tail(
      (print tag)
      (print '<_s)
      (print ps)
      (print '>_s)
   )))
)) Nil);

print := λ(: tt TypeList). (: (match tt (
   ()
   ( TypeEOF () )
   ( (TypeSeq( TypeEOF p1 )) (print p1) )
   ( (TypeSeq( rst p1 )) (tail(
      (print rst)
      (print ',_s)
      (print p1)
   )))
)) Nil);

== := λ(: lt Type)(: rt Type). (: (tail(
   (let r 0_u64)
   (match (Pair( lt rt )) (
      ()
      ( (Pair( TAny TAny )) (set r 1_u64) )
      ( (Pair( (TVar lv) (TVar rv) )) (set r (==( lv rv ))) )
      ( (Pair( (TAnd( llt rlt )) (TAnd( lrt rrt )) )) (
         (if (==( llt lrt )) (
            (if (==( rlt rrt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (Pair( (TGround( ln lps )) (TGround( rn rps )) )) (
         (if (==( ln rn )) (
            (if (==( lps rps )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

== := λ(: lt TypeList)(: rt TypeList). (: (tail(
   (let r 0_u64)
   (match (Pair( lt rt )) (
      ()
      ( (Pair( TypeEOF TypeEOF )) (set r 1_u64) )
      ( (Pair( (TypeSeq( ltr lt1 )) (TypeSeq( rtr rt1 )) )) (
         (if (==( lt1 rt1 )) (
            (if (==( ltr rtr )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

can-unify := λ(: fpt TypeList)(: pt TypeList). (: (tail(
   (let r 0_u64)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TypeEOF TypeEOF )) (set r 1_u64) )
      ( (Pair( (TypeSeq( lpr lp1 )) (TypeSeq( rpr rp1 )) )) (
         (if (can-unify( lp1 rp1 )) (
            (if (can-unify( lpr rpr )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

can-unify := λ(: fpt Type)(: pt Type). (: (tail(
   (let r 0_u64)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TAny _ )) (set r 1_u64) )
      ( (Pair( (TVar( ltv )) rt )) (set r 1_u64) )
      ( (Pair( (TAnd( lt1 lt2 )) rt )) (
         (if (can-unify( lt1 rt )) (
            (if (can-unify( lt2 rt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (Pair( lt (TAnd( rt1 rt2 )) )) (tail(
         (if (can-unify( lt rt1 )) (set r 1_u64) ())
         (if (can-unify( lt rt2 )) (set r 1_u64) ())
      )))
      ( (Pair( (TGround( 'GT_s (TypeSeq( TypeEOF (TGround( lbase TypeEOF )) )) )) (TGround( rbase TypeEOF )) )) (
         (if (>( (to-i64 rbase) (to-i64 lbase) )) (
            (set r 1_u64)
         ) ())
      ))
      ( (Pair( (TGround( ltn lps )) (TGround( rtn rps )) )) (
         (if (==( ltn rtn )) (
            (if (can-unify( lps rps )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

to-string := λ(: tt Type). (: (tail(
   (let r (to-string-impl tt))
   (clone-rope r)
)) String);

to-string := λ(: tt TypeList). (: (tail(
   (let r SNil)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( TypeEOF p1 )) (set r (to-string-impl p1)) )
      ( (TypeSeq( rst p1 )) (
         (set r (SCons(
            (close(to-string rst))
            (close(SCons(
               (close(SAtom ',_s))
               (close(to-string-impl p1))
            )))
         )))
      ))
   ))
   r
)) S);

to-string-impl := λ(: tt Type). (: (tail(
   (let r SNil)
   (match tt (
      ()
      ( TAny (set r (SAtom '?_s)) )
      ( (TVar v) (set r (SAtom v)) )
      ( (TAnd( lt rt )) (tail(
         (let ls (to-string-impl lt))
         (let rs (to-string-impl rt))
         (set r (SCons(
            (close ls)
            (close(SCons(
               (close(SAtom '+_s))
               (close rs)
            )))
         )))
      )))
      ( (TGround( tag TypeEOF )) (
        (set r (SAtom tag))
      ))
      ( (TGround( tag ps )) (tail(
        (set r (SAtom tag))
        (set r (SCons( (close r) (close(SAtom '<_s)) )))
        (set r (SCons( (close r) (close(to-string ps)) )))
        (set r (SCons( (close r) (close(SAtom '>_s)) )))
      )))
   ))
   r
)) S);

type-of-s := λ(: compound AST). (: (tail(
   (let r TAny)
   (match compound (
      ()
      ( (Lit tt) (tail(
         (let nt (parse-type tt))
         (set r nt)
      )))
      ( (Var tt) (tail(
         (let nt (parse-type tt))
         (set r nt)
      )))
      ( (App( (App( lt (Lit ',_s) )) rt )) (tail(
         (let ltt (type-of-s lt))
         (let rtt (type-of-s rt))
         (set r (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  ltt
               )))
               rtt
            )))
         )))
      )))
      ( _ (exit-error( 'Malformed\sType\sDefinition_s compound )))
   ))
   r
)) Type);

normalize := λ(: tctx TContext). (: (tail(
   (match tctx (
      ()
      ( TCtxEOF () )
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k kt t )) (tail(
         (set rst (normalize rst))
         (set tctx (TCtxBind(
            (close rst)
            k (normalize kt) t
         )))
      )))
   ))
   tctx
)) TContext);

with-only-representation := λ(: tt TypeList). (: (tail(
   (let rt tt)
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set rt (TypeSeq(
            (close(with-only-representation rst))
            (with-only-representation p1)
         )))
      ))
      ( TypeEOF () )
   ))
   rt
)) TypeList);

with-only-representation := λ(: tt Type). (: (tail(
   (let return tt)
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (with-only-representation lt))
         (let rt2 (with-only-representation rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set return (TAnd( (close lt2) (close rt2) )))
            ) (
               (set return lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set return rt2)
            ) (
               (set return TAny)
            ))
         ))
      )))
      ( (TGround( 'Constant_s TypeEOF )) () )
      ( (TGround( 'Literal_s TypeEOF )) () )
      ( (TGround( 'StackVariable_s TypeEOF )) () )
      ( (TGround( 'LocalVariable_s TypeEOF )) () )
      ( (TGround( 'GlobalVariable_s TypeEOF )) () )
      ( (TGround( 'Reg8_s TypeEOF )) () )
      ( (TGround( 'Reg16_s TypeEOF )) () )
      ( (TGround( 'Reg32_s TypeEOF )) () )
      ( (TGround( 'Reg64_s TypeEOF )) () )
      ( (TGround( tag ps )) (set return TAny) )
      ( TAny () )
      ( (TVar _) (set return TAny) )
   ))
   return
)) Type);

unify := λ(: fpt Type)(: pt Type). (: (tail(
   (let ctx TCtxEOF)
   (if (can-unify( fpt pt )) (
      (set ctx (unify-inner( fpt pt )))
   ) ())
   ctx
)) TContext);

unify-inner := λ(: fpt Type)(: pt Type). (: (tail(
   (let ctx TCtxEOF)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TAny _ )) (
         (set ctx TCtxNil)
      ))
      ( (Pair( (TVar( ltv )) (TGround( tg TypeEOF )) )) (
         (set ctx (TCtxBind(
            (close TCtxEOF)
            ltv
            pt
            (Lit tg)
         )))
      ))
      ( (Pair( (TVar( ltv )) rt )) (
         (set ctx (TCtxBind(
            (close TCtxEOF)
            ltv
            pt
            ASTEOF
         )))
      ))
      ( (Pair( (TAnd( lt1 lt2 )) rt )) (
         (match (Pair( (unify-inner( lt1 rt )) (unify-inner( lt2 rt )) )) (
            ()
            ( (Pair( TCtxEOF _ )) () )
            ( (Pair( _ TCtxEOF )) () )
            ( (Pair( lctx rctx )) (
               (set ctx (union( lctx rctx )))
            ))
         ))
      ))
      ( (Pair( lt (TAnd( rt1 rt2 )) )) (
         (match (Pair( (unify-inner( lt rt1 )) (unify-inner( lt rt2 )) )) (
            ()
            ( (Pair( TCtxEOF TCtxEOF )) () )
            ( (Pair( lctx TCtxEOF )) (set ctx lctx) )
            ( (Pair( TCtxEOF rctx )) (set ctx rctx) )
            ( (Pair( lctx rctx )) (
               (set ctx (union( lctx rctx )))
            ))
         ))
      ))
      ( (Pair( (TGround( 'GT_s (TypeSeq( TypeEOF (TGround( lbase TypeEOF )) )) )) (TGround( rbase TypeEOF )) )) (
         (if (>( (to-i64 rbase) (to-i64 lbase) )) (
            (set ctx TCtxNil)
         ) ())
      ))
      ( (Pair( (TGround( ltn lps )) (TGround( rtn rps )) )) (
         (if (==( ltn rtn )) (
            (set ctx (unify( lps rps )))
         ) ())
      ))
      ( _ () )
   ))
   ctx
)) TContext);

unify := λ(: fpt TypeList)(: pt TypeList). (: (tail(
   (let ctx TCtxEOF)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TypeEOF TypeEOF )) (set ctx TCtxNil) )
      ( (Pair( (TypeSeq( lps lp1 )) (TypeSeq( rps rp1 )) )) (tail(
         (set ctx (unify( lp1 rp1 )))
         (if (non-zero ctx) (
            (set ctx (union( ctx (unify( lps rps )) )))
         ) ())
      )))
      ( _ () )
   ))
   ctx
)) TContext);

fields-of-tag := λ(: tag Type)(: class Type). (: (tail(
   (let rhst TAny)
   (match tag (
      ()
      ( (TGround( 'Tag_s (TypeSeq( TypeEOF (TGround( ts _ )) )) )) (match (fields-of-tag ts) (
         ()
         ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF fields-lhs )) fields-rhs )) )) (
            (set rhst (substitute( (unify( fields-lhs class )) fields-rhs )))
         ))
      )))
      ( _ (tail(
         (print 'Invalid\sTag\sIn\sfields-of-tag\s_s)
         (print tag)(print '\n_s)
         (exit 1_u64)
      )))
   ))
   (set rhst (with-size rhst))
   (let rt (TGround( 'Fields_s (close(TypeSeq(
      (close TypeEOF)
      (fields-of-type( (t3( 'Cons_s rhst (TAnd( (close(t1 'U64_s)) (close(t2( 'Sized_s (t1 '8_s) ))) )) )) ))
   ))))))
   rt
)) Type);

fields-of-type := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( TAny (set tt (t1 'Nil_s)) )
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set tt (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (fields-of-type p1)
               )))
               p2
            )))
         )))
      ))
      ( _ (
         (set tt (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (t1 'Nil_s)
               )))
               tt
            )))
         )))
      ))
   ))
   tt
)) Type);

s-type-list := (: STEOF STypeList);
ascript := λ(: t S)(: tt Type). (: (
   (set s-type-list (STSeq(
      (close s-type-list)
      t tt
   )))
) Nil);

typeof := λ(: term S). (: (tail(
   (let found TAny)
   (let tctx s-type-list)
   (while (non-zero tctx) (match tctx (
      ()
      ( (STSeq( rst s tt )) (
         (if (is( s term )) (tail(
            (set found tt)
            (set tctx STEOF)
         )) (
            (set tctx rst)
         ))
      ))
   )))
   found
)) Type);

to-s := λ(: term AST). (: (tail(
   (let s SNil)
   (match term (
      ()
      ( (Var v) (
         (set s (SCons(
            (close(SAtom 'Var_s))
            (close(SAtom v))
         )))
      ))
      ( (Lit v) (
         (set s (SCons(
            (close(SAtom 'Lit_s))
            (close(SAtom v))
         )))
      ))
      ( (App( (Lit ':_s) (App( t (AType tt) )) )) (tail(
         (set s (to-s t))
         (ascript( s tt ))
      )))
      ( (App( (Var 'as_s) (App( t (AType tt) )) )) (tail(
         (set s (to-s t))
         (ascript( s tt ))
      )))
      ( (App( lt rt )) (
         (set s (SCons(
            (close(SAtom 'App_s))
            (close(SCons(
               (close(to-s lt))
               (close(to-s rt))
            )))
         )))
      ))
      ( (Abs( lt rt tlt )) (
         (set s (SCons(
            (close(SAtom 'Abs_s))
            (close(SCons(
               (close(to-s lt))
               (close(to-s rt))
            )))
         )))
      ))
      ( _ () )
   ))
   s
)) S);

ascript-normal := λ(: t AST)(: tt Type). (: (
   (if (non-zero tt) (tail(
      (let prev-tt (normalize(typeof t)))
      (if (non-zero prev-tt) (
         (if (is-arrow tt) () (tail(
            (let norm-tt (normalize tt))
            (if (==( prev-tt norm-tt )) () (tail(
               (print prev-tt)
               (print '\s!=\s_s)
               (print norm-tt)
               (print '\n_s)
               (exit-error( 'Type\sAscription\sInequality_s t ))
            )))
         )))
      ) (tail(
         (let sized-tt (with-size tt))
         (ascript( t sized-tt ))
         (set types-have-changed True_u8)
      )))
   )) ())
) Nil);

sizeof-type := λ(: tt Type). (: (tail(
   (let sz 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar _) () )
      ( (TGround( class TypeEOF )) (set sz (size-of-class class)) )
      ( (TGround( 'Sized_s (TypeSeq( TypeEOF (TGround( szp TypeEOF )) )) )) (
         (set sz (to-u64 szp))
      ))
      ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF p1 )) TAny )) )) (
         (set sz 8_u64)
      ))
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set sz (+(
            (sizeof-aligned p1)
            (sizeof-aligned p2)
         )))
      ))
      ( (TGround( 'Field_s (TypeSeq( (TypeSeq( TypeEOF p1 )) (TGround( szp TypeEOF )) )) )) (
         (set sz (*( (sizeof-type p1) (to-u64 szp) )))
      ))
      ( (TGround( tag _ )) (
         (match (.lookup( type-complex-fields-index tag (Pair( TAny TAny )) )) (
            ()
            ( (Pair( TAny TAny )) () )
            ( (Pair( bt at )) (tail(
               (let ctx (unify( bt tt )))
               (let arg-types (substitute( ctx at )))
               (set sz (+( 8_u64 (sizeof-aligned arg-types) )))
            )))
         ))
      ))
      ( (TAnd( lt rt )) (
         (if (sizeof-type lt) (
            (set sz (sizeof-type lt))
         ) (
            (set sz (sizeof-type rt))
         ))
      ))
      ( _ (tail(
         (print 'Unexpected\sType\ssizeof-type\s_s)
         (print tt)(print '\n_s)(exit 1_u64)
      )))
   ))
   sz
)) U64);

sizeof-aligned := λ(: tt Type). (: (tail(
   (let sz (sizeof-type tt))
   (if (==( sz 0_u64 )) () (set sz (max( 8_u64 sz ))))
   sz
)) U64);

set-size := λ(: base-type Type)(: args-type Type). (: (tail(
   (let tag '_s)
   (let simple False_u8)
   (match base-type (
      ()
      ( (TGround( tg TypeEOF )) (tail( (set tag tg) (set simple True_u8) )) )
      ( (TGround( tg _ )) (set tag tg) )
      ( _ (tail(
         (print 'ERROR:\stypecheck-set-size\n_s)
         (exit 1_u64)
      )))
   ))
   (if (==( simple True_u8 )) () (
      (.bind( (as (& type-complex-fields-index) BTreeEq<String,Tuple<Type,Type>>[]) tag (Pair( base-type args-type )) ))
   ))
)) Nil);

typeof-lhs := λ(: lhs AST). (: (tail(
   (let r TAny)
   (match lhs (
      ()
      ( (App( (Lit ':_s) (App( _ (AType tt) )) )) (
         (set r tt)
      ))
      ( (App( ps (App( (Lit ':_s) (App( _ (AType tt) )) )) )) (
         (set r (t3( 'Cons_s (typeof-lhs ps) tt )))
      ))
      ( ASTNil (
         (set r (t1 'Nil_s))
      ))
      ( _ (exit-error( 'Unknown\sLHS_s lhs )))
   ))
   r
)) Type);

typeof-tag := λ(: tag String). (: (tail(
   (let r (.lookup( type-constructors-index tag TAny )))
   r
)) Type);

as-local-variable := λ(: tt Type). (: (tail(
   (set tt (normalize tt))
   (if (non-zero tt) (
      (set tt (TAnd( (close tt) (close(t1 'LocalVariable_s)) )))
   ) ())
   (set tt (with-size tt))
   tt
)) Type);

as-constant := λ(: tt Type). (: (tail(
   (if (non-zero tt) (
      (set tt (TAnd( (close tt) (close(t1 'Constant_s)) )))
   ) ())
   tt
)) Type);
