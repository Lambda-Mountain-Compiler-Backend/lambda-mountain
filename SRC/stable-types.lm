
# global Tag -> Class map, mutable
tag-to-class-index := (: BTreeEqEOF BTreeEq<String,Type>);

# global Class -> Yes/No map, mutable
class-to-yes-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Tag -> Fields map, mutable
tag-to-fields-index := (: BTreeEqEOF BTreeEq<String,Type>);

# global Tag -> IsFragment? map, mutable
tag-is-fragment-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Class -> Size map, mutable
class-to-size-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Tag -> Index map, mutable
tag-to-index-index := (: BTreeEqEOF BTreeEq<String,U64>);
unknown-index-of-tag := 99999_u64;

# Global Tag -> Type map, mutable
type-constructors-index := (: BTreeEqEOF BTreeEq<String,Type>);

# Global Tag -> (Type,Type) base-type to fields-type map, mutable
type-complex-fields-index := (: BTreeEqEOF BTreeEq<String,Tuple<Type,Type>>);

# has typechecking finished? boolean, mutable
types-have-changed := True_u8;

is-special-index := (: BTreeEqEOF BTreeEq<Tuple<String,Type>,U64>);

mark-as-special := λ(: name String)(: tt Type). (: (
   (.bind( (as (& is-special-index) BTreeEq<Tuple<String,Type>,U64>[]) (Pair( name tt )) 1_u64 ))
) Nil);

is-special := λ(: name String)(: tt Type). (: (tail(
   (let r (.lookup( is-special-index (Pair( name tt )) 0_u64 )))
   r
)) U64);

index-of-tag := λ(: tag String). (: (tail(
   (let r (.lookup( tag-to-index-index tag unknown-index-of-tag )))
   r
)) U64);

index-index-of-tag := λ(: tag String)(: index U64). (: (
   (.bind( (as (& tag-to-index-index) BTreeEq<String,U64>[]) tag index ))
) Nil);

index-size-of-class := λ(: class String)(: size U64). (: (
   (.bind( (as (& class-to-size-index) BTreeEq<String,U64>[]) class size ))
) Nil);

size-of-class := λ(: class String). (: (
   (.lookup( class-to-size-index class 0_u64 ))
) U64);

index-tag-is-fragment := λ(: tag String). (: (
   (.bind( (as (& tag-is-fragment-index) BTreeEq<String,U64>[]) tag 1_u64 ))
) Nil);

is-fragment := λ(: tag String). (: (
   (.lookup( tag-is-fragment-index tag 0_u64 ))
) U64);

is-fragment := λ(: tt Type). (: (
   (is-fragment(tag-of tt))
) U64);

tag-of := λ(: tt Type). (: (tail(
   (let tag '_s)
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let ltag (tag-of lt))
         (if (non-zero ltag) (set tag ltag) ())
         (let rtag (tag-of rt))
         (if (non-zero rtag) (set tag rtag) ())
      )))
      ( (TGround( tg _ )) (set tag tg) )
      ( _ () )
   ))
   tag
)) String);

index-class-of-tag := λ(: tag String)(: class Type). (: (tail(
   (.bind( (as (& tag-to-class-index) BTreeEq<String,Type>[]) tag class ))
   (match class (
      ()
      ( (TGround( cls _ )) (
         (.bind( (as (& class-to-yes-index) BTreeEq<String,U64>[]) cls 1_u64 ))
      ))
      ( _ (tail(
         (print 'Unexpected\sClass\sIn\sindex-class-of-tag:\s_s)(print class)(print '\n_s)
         (exit 1_u64)
      )))
   ))
)) Nil);

class-of-tag := λ(: tag String). (: (tail(
   (let r (.lookup( tag-to-class-index tag TAny )))
   r
)) Type);

is-class := λ(: tag String). (: (tail(
   (let r (.lookup( class-to-yes-index tag 0_u64 )))
   r
)) U64);

index-fields-of-tag := λ(: tag String)(: fields Type). (: (
   (.bind( (as (& tag-to-fields-index) BTreeEq<String,Type>[]) tag fields ))
) Nil);

fields-of-tag := λ(: tag String). (: (tail(
   (let r (.lookup( tag-to-fields-index tag TAny )))
   r
)) Type);

slot := λ(: tt Type)(: sl String). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TGround( bt _ )) (
         (if (==( bt sl )) (set rt tt) ())
      ))
      ( (TAnd( ltt rtt )) (tail(
         (let lt2 (slot( ltt sl )))
         (if (non-zero lt2) (
            (set rt lt2)
         ) (tail(
            (let rt2 (slot( rtt sl )))
            (set rt rt2)
         )))
      )))
      ( _ () )
   ))
   rt
)) Type);

domain := λ(: tt Type). (: (tail(
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p1) )
      ( _ () )
   ))
   r
)) Type);

range := λ(: tt Type). (: (tail(
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p2) )
      ( _ () )
   ))
   r
)) Type);

is-open := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( TAny (set r 1_u64) )
      ( (TVar _) (set r 1_u64) )
      ( (TAnd( lt rt )) (tail(
         (if (is-open lt) (set r 1_u64) ())
         (if (is-open rt) (set r 1_u64) ())
      )))
      ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF _ )) _ )) )) () )
      ( (TGround( 'Field_s (TypeSeq( (TypeSeq( TypeEOF base-type )) _ )) )) (
         (set r (is-open base-type))
      ))
      ( (TGround( _ pars )) (
         (while (non-zero pars) (match pars (
            ()
            ( (TypeSeq( rst p1 )) (tail(
               (if (is-open p1) (set r 1_u64) ())
               (set pars rst)
            )))
         )))
      ))
   ))
   r
)) U64);

is-arrow := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s _ )) (set r 1_u64) )
      ( _ () )
   ))
   r
)) U64);

t3 := λ(: tag String)(: p1 Type)(: p2 Type). (: (tail(
   (let tt (TGround(
      tag
      (close(TypeSeq( (close(TypeSeq( (close TypeEOF) p1 ))) p2 )))
   )))
   tt
)) Type);

t2 := λ(: tag String)(: p1 Type). (: (tail(
   (let tt (TGround(
      tag
      (close(TypeSeq( (close TypeEOF) p1 )))
   )))
   tt
)) Type);

t1 := λ(: tag String). (: (tail(
   (let tt (TGround(
      tag
      (close TypeEOF)
   )))
   tt
)) Type);

tsized :=  λ(: tag String). (: (tail(
   (let tt (t2( 'Sized_s (t1 tag) )))
   tt
)) Type);

substitute := λ(: tctx TContext)(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst par )) (
         (set tt (TypeSeq(
            (close(substitute( tctx rst )))
            (substitute( tctx par ))
         )))
      ))
   ))
   tt
)) TypeList);

substitute := λ(: tctx TContext)(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TVar v) (
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv _ )) (
               (if (==( tk v )) (tail(
                  (set tt tv)
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      ))
      ( (TGround( tag pars )) (
         (set tt (TGround(
            tag
            (close(substitute( tctx pars )))
         )))
      ))
      ( (TAnd( lt rt )) (
         (set tt (TAnd(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( _ () )
   ))
   tt
)) Type);

substitute-lhs := λ(: tctx TContext)(: t AST). (: (tail(
   (match t (
      ()
      ( (App( ps (App( (Lit( ':_s ctk )) (App( (Var( v vtk )) (AType vt) )) )) )) (
         (set t (App(
            (close(substitute-lhs( tctx ps )))
            (close(App( (close(Lit( ':_s (unique ctk) ))) (close(App(
               (close(Var( v (unique vtk) )))
               (close(AType( (substitute( tctx vt )) )))
            ))) )))
         )))
      ))
      ( (App( (Lit( ':_s ctk )) (App( (Var( v vtk )) (AType vt) )) )) (
         (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
            (close(Var( v (unique vtk) )))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
      ))
      ( (App( ps (Var( v vtk )) )) (
         (set t (App(
            (close(substitute-lhs( tctx ps )))
            (close(Var( v (unique vtk) )))
         )))
      ))
      ( (Var( v vtk )) (set t (Var( v (unique vtk) ))) )
      ( ASTNil () )
      ( _ (exit-error( 'Unexpected\sSubstitute\sLHS_s t )) )
   ))
   t
)) AST);

substitute := λ(: tctx TContext)(: t AST). (: (tail(
   (match t (
      ()
      ( ASTEOF () )
      ( ASTNil () )
      ( (App( (Lit( ':_s ctk )) (App( (Lit( v vtk )) (AType vt) )) )) (tail(
         (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
            (close(Lit( v (unique vtk) )))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv ta )) (
               (if (==( tk v )) (tail(
                  (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
                     (close(substitute( tctx ta )))
                     (close(AType( (substitute( tctx vt )) )))
                  ))) )))
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      )))
      ( (App( (Lit( ':_s ctk )) (App( (Var( v vtk )) (AType vt) )) )) (tail(
         (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
            (close(Var( v (unique vtk) )))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv ta )) (
               (if (==( tk v )) (tail(
                  (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
                     (close(substitute( tctx ta )))
                     (close(AType( (substitute( tctx vt )) )))
                  ))) )))
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      )))
      ( (Lit( v vtk )) (set t (Lit( v (unique vtk) ))) )
      ( (Var( v vtk )) (set t (Var( v (unique vtk) ))) )
      ( (Abs( lhs rhs tt )) (
         (set t (Abs(
            (close(substitute-lhs( tctx lhs )))
            (close(substitute( tctx rhs )))
            (substitute( tctx tt ))
         )))
      ))
      ( (AType( tt )) (
         (set t (AType( (substitute( tctx tt )) )))
      ))
      ( (App( lt rt )) (
         (set t (App(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Seq( lt rt )) (
         (set t (Seq(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Glb( k rt )) (
         (set t (Glb(
            (unique k)
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Typedef( lt rt )) (
         (set t (Typedef(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Frg( k lt tt )) (
         (set t (Frg(
            (unique k)
            (close(substitute( tctx lt )))
            (substitute( tctx tt ))
         )))
      ))
      ( _ (exit-error( 'Unexpected\sSubstitution\sTerm:_s t )) )
   ))
   t
)) AST);

substitute := λ(: tctx StringSList)(: t S). (: (tail(
   (match t (
      ()
      ( SNil (set t SNil) )
      ( (SAtom a) (
         (while (non-zero tctx) (match tctx (
            ()
            ( (SSLSeq( rst k v )) (tail(
               (if (==( a k )) (
                  (set t v)
               ) ())
               (set tctx rst)
            )))
         )))
      ))
      ( (SCons( lt rt )) (
         (set t (SCons(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
   ))
   (let rt t)
   rt
)) S);

union := λ(: lctx TContext)(: rctx TContext). (: (tail(
   (match rctx (
      ()
      ( TCtxNil (set rctx TCtxEOF) )
      ( (TCtxBind( rst k v t )) (tail(
         (set lctx (union( lctx rst )))
         (set lctx (TCtxBind( (close lctx) k v t )))
      )))
      ( _ () )
   ))
   lctx
)) TContext);

without-tag := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt1 (without-tag lt))
         (let rt1 (without-tag rt))
         (match (Pair( lt1 rt1 )) (
            ()
            ( (Pair( TAny rt2 )) (set tt rt2) )
            ( (Pair( lt2 TAny )) (set tt lt2) )
            ( (Pair( lt2 rt2 )) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ))
         ))
      )))
      ( (TGround( 'Constructor_s _ )) (set tt TAny) )
      ( (TGround( 'Tag_s _ )) (set tt TAny) )
      ( tt () )
   ))
   tt
)) Type);

without-open := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt1 (without-open lt))
         (let rt1 (without-open rt))
         (match (Pair( lt1 rt1 )) (
            ()
            ( (Pair( TAny rt2 )) (set tt rt2) )
            ( (Pair( lt2 TAny )) (set tt lt2) )
            ( (Pair( lt2 rt2 )) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ))
         ))
      )))
      ( _ (if (is-open tt) (set tt TAny) ()))
   ))
   tt
)) Type);

without-tag := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq( (close(without-tag rst)) (without-tag p1) )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

with-only-tag := λ(: tt Type). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TAnd( lt1 rt1 )) (tail(
         (let lc (with-only-tag lt1))
         (if (non-zero lc) (set rt lc) ())
         (let rc (with-only-tag rt1))
         (if (non-zero rc) (set rt rc) ())
      )))
      ( (TGround( 'Tag_s _ )) (set rt tt) )
      ( _ () )
   ))
   rt
)) Type);

with-only-class := λ(: tt Type). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TAnd( lt1 rt1 )) (tail(
         (let lc (with-only-class lt1))
         (if (non-zero lc) (set rt lc) ())
         (let rc (with-only-class rt1))
         (if (non-zero rc) (set rt rc) ())
      )))
      ( (TGround( tag _ )) (
         (if (is-class tag) (
            (if (not(is-fragment tag)) (
               (set rt tt)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   rt
)) Type);

without-representation := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-representation rst))
            (without-representation p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

without-representation := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-representation lt))
         (let rt2 (without-representation rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( 'Constant_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Literal_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'StackVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'LocalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'GlobalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg8_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg16_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg32_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg64_s TypeEOF )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-representation ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

without-size := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-size rst))
            (without-size p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

without-size := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-size lt))
         (let rt2 (without-size rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( 'Sized_s sz )) (set tt TAny) )
      ( (TGround( 'FieldsSized_s sz )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

without-size-unless-class := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-size-unless-class rst))
            (without-size-unless-class p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
)) TypeList);

without-size-unless-class := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-size-unless-class-inner lt))
         (let rt2 (without-size-unless-class-inner rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size-unless-class ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

without-size-unless-class-inner := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (without-size-unless-class-inner lt))
         (let rt2 (without-size-unless-class-inner rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      )))
      ( (TGround( 'FieldsSized_s _ )) (set tt TAny) )
      ( (TGround( 'Sized_s _ )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size-unless-class ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
)) Type);

normalize := λ(: tt Type). (: (tail(
   (let rt tt)
   (set rt (without-representation rt))
   (set rt (without-tag rt))
   # Sized can serve as a datatype if nothing else is available
   (set rt (without-size-unless-class rt))
   rt
)) Type);

print := λ(: tt Type). (: (match tt (
   ()
   ( TAny (print '?_s) )
   ( (TVar( vn )) (print vn) )
   ( (TGround( tag TypeEOF )) (print tag) )
   ( (TAnd( (TGround( 'Arrow_s ls )) rt )) (tail(
      (print 'Arrow<_s)
      (print ls)
      (print '>\s+\n_s)
      (print rt)
   )))
   ( (TAnd( lt (TGround( 'Arrow_s rs )) )) (tail(
      (print lt)
      (print '\s+\sArrow<_s)
      (print rs)
      (print '>_s)
   )))
   ( (TAnd( lt rt )) (tail(
      (print lt)
      (print '\s+\s_s)
      (print rt)
   )))
   ( (TGround( tag ps )) (tail(
      (print tag)
      (print '<_s)
      (print ps)
      (print '>_s)
   )))
)) Nil);

print := λ(: tt TypeList). (: (match tt (
   ()
   ( TypeEOF () )
   ( (TypeSeq( TypeEOF p1 )) (print p1) )
   ( (TypeSeq( rst p1 )) (tail(
      (print rst)
      (print ',_s)
      (print p1)
   )))
)) Nil);

== := λ(: lt Type)(: rt Type). (: (tail(
   (let r 0_u64)
   (match (Pair( lt rt )) (
      ()
      ( (Pair( TAny TAny )) (set r 1_u64) )
      ( (Pair( (TVar lv) (TVar rv) )) (set r (==( lv rv ))) )
      ( (Pair( (TAnd( llt rlt )) (TAnd( lrt rrt )) )) (
         (if (==( llt lrt )) (
            (if (==( rlt rrt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (Pair( (TGround( ln lps )) (TGround( rn rps )) )) (
         (if (==( ln rn )) (
            (if (==( lps rps )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

== := λ(: lt TypeList)(: rt TypeList). (: (tail(
   (let r 0_u64)
   (match (Pair( lt rt )) (
      ()
      ( (Pair( TypeEOF TypeEOF )) (set r 1_u64) )
      ( (Pair( (TypeSeq( ltr lt1 )) (TypeSeq( rtr rt1 )) )) (
         (if (==( lt1 rt1 )) (
            (if (==( ltr rtr )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

can-unify := λ(: fpt TypeList)(: pt TypeList). (: (tail(
   (let r 0_u64)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TypeEOF TypeEOF )) (set r 1_u64) )
      ( (Pair( (TypeSeq( lpr lp1 )) (TypeSeq( rpr rp1 )) )) (
         (if (can-unify( lp1 rp1 )) (
            (if (can-unify( lpr rpr )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

can-unify := λ(: fpt Type)(: pt Type). (: (tail(
   (let r 0_u64)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TAny _ )) (set r 1_u64) )
      ( (Pair( (TVar( ltv )) rt )) (set r 1_u64) )
      ( (Pair( (TAnd( lt1 lt2 )) rt )) (
         (if (can-unify( lt1 rt )) (
            (if (can-unify( lt2 rt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (Pair( lt (TAnd( rt1 rt2 )) )) (tail(
         (if (can-unify( lt rt1 )) (set r 1_u64) ())
         (if (can-unify( lt rt2 )) (set r 1_u64) ())
      )))
      ( (Pair( (TGround( 'GT_s (TypeSeq( TypeEOF (TGround( lbase TypeEOF )) )) )) (TGround( rbase TypeEOF )) )) (
         (if (>( (to-i64 rbase) (to-i64 lbase) )) (
            (set r 1_u64)
         ) ())
      ))
      ( (Pair( (TGround( ltn lps )) (TGround( rtn rps )) )) (
         (if (==( ltn rtn )) (
            (if (can-unify( lps rps )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
)) U64);

to-string := λ(: tt Type). (: (tail(
   (let r (to-string-impl tt))
   (clone-rope r)
)) String);

to-string := λ(: tt TypeList). (: (tail(
   (let r SNil)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( TypeEOF p1 )) (set r (to-string-impl p1)) )
      ( (TypeSeq( rst p1 )) (
         (set r (SCons(
            (close(to-string rst))
            (close(SCons(
               (close(SAtom ',_s))
               (close(to-string-impl p1))
            )))
         )))
      ))
   ))
   r
)) S);

to-string-impl := λ(: tt Type). (: (tail(
   (let r SNil)
   (match tt (
      ()
      ( TAny (set r (SAtom '?_s)) )
      ( (TVar v) (set r (SAtom v)) )
      ( (TAnd( lt rt )) (tail(
         (let ls (to-string-impl lt))
         (let rs (to-string-impl rt))
         (set r (SCons(
            (close ls)
            (close(SCons(
               (close(SAtom '+_s))
               (close rs)
            )))
         )))
      )))
      ( (TGround( tag TypeEOF )) (
        (set r (SAtom tag))
      ))
      ( (TGround( tag ps )) (tail(
        (set r (SAtom tag))
        (set r (SCons( (close r) (close(SAtom '<_s)) )))
        (set r (SCons( (close r) (close(to-string ps)) )))
        (set r (SCons( (close r) (close(SAtom '>_s)) )))
      )))
   ))
   r
)) S);

type-of-s := λ(: compound AST). (: (tail(
   (let r TAny)
   (match compound (
      ()
      ( (Lit( tt _ )) (tail(
         (let nt (parse-type tt))
         (set r nt)
      )))
      ( (Var( tt _ )) (tail(
         (let nt (parse-type tt))
         (set r nt)
      )))
      ( (App( (App( lt (Lit( ',_s _ )) )) rt )) (tail(
         (let ltt (type-of-s lt))
         (let rtt (type-of-s rt))
         (set r (t3( 'Cons_s ltt rtt )))
      )))
      ( _ (exit-error( 'Malformed\sType\sDefinition_s compound )))
   ))
   r
)) Type);

normalize := λ(: tctx TContext). (: (tail(
   (match tctx (
      ()
      ( TCtxEOF () )
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k kt t )) (tail(
         (set rst (normalize rst))
         (set tctx (TCtxBind(
            (close rst)
            k (normalize kt) t
         )))
      )))
   ))
   tctx
)) TContext);

with-only-representation := λ(: tt TypeList). (: (tail(
   (let rt tt)
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set rt (TypeSeq(
            (close(with-only-representation rst))
            (with-only-representation p1)
         )))
      ))
      ( TypeEOF () )
   ))
   rt
)) TypeList);

with-only-representation := λ(: tt Type). (: (tail(
   (let return tt)
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let lt2 (with-only-representation lt))
         (let rt2 (with-only-representation rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set return (TAnd( (close lt2) (close rt2) )))
            ) (
               (set return lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set return rt2)
            ) (
               (set return TAny)
            ))
         ))
      )))
      ( (TGround( 'Constant_s TypeEOF )) () )
      ( (TGround( 'Literal_s TypeEOF )) () )
      ( (TGround( 'StackVariable_s TypeEOF )) () )
      ( (TGround( 'LocalVariable_s TypeEOF )) () )
      ( (TGround( 'GlobalVariable_s TypeEOF )) () )
      ( (TGround( 'Reg8_s TypeEOF )) () )
      ( (TGround( 'Reg16_s TypeEOF )) () )
      ( (TGround( 'Reg32_s TypeEOF )) () )
      ( (TGround( 'Reg64_s TypeEOF )) () )
      ( (TGround( tag ps )) (set return TAny) )
      ( TAny () )
      ( (TVar _) (set return TAny) )
   ))
   return
)) Type);

unify := λ(: fpt Type)(: pt Type). (: (tail(
   (let ctx TCtxEOF)
   (if (can-unify( fpt pt )) (
      (set ctx (unify-inner( fpt pt )))
   ) ())
   ctx
)) TContext);

unify-inner := λ(: fpt Type)(: pt Type). (: (tail(
   (let ctx TCtxEOF)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TAny _ )) (
         (set ctx TCtxNil)
      ))
      ( (Pair( (TVar( ltv )) (TGround( tg TypeEOF )) )) (
         (set ctx (TCtxBind(
            (close TCtxEOF)
            ltv
            pt
            (Lit( tg (token::new tg) ))
         )))
      ))
      ( (Pair( (TVar( ltv )) rt )) (
         (set ctx (TCtxBind(
            (close TCtxEOF)
            ltv
            pt
            ASTEOF
         )))
      ))
      ( (Pair( (TAnd( lt1 lt2 )) rt )) (
         (match (Pair( (unify-inner( lt1 rt )) (unify-inner( lt2 rt )) )) (
            ()
            ( (Pair( TCtxEOF _ )) () )
            ( (Pair( _ TCtxEOF )) () )
            ( (Pair( lctx rctx )) (
               (set ctx (union( lctx rctx )))
            ))
         ))
      ))
      ( (Pair( lt (TAnd( rt1 rt2 )) )) (
         (match (Pair( (unify-inner( lt rt1 )) (unify-inner( lt rt2 )) )) (
            ()
            ( (Pair( TCtxEOF TCtxEOF )) () )
            ( (Pair( lctx TCtxEOF )) (set ctx lctx) )
            ( (Pair( TCtxEOF rctx )) (set ctx rctx) )
            ( (Pair( lctx rctx )) (
               (set ctx (union( lctx rctx )))
            ))
         ))
      ))
      ( (Pair( (TGround( 'GT_s (TypeSeq( TypeEOF (TGround( lbase TypeEOF )) )) )) (TGround( rbase TypeEOF )) )) (
         (if (>( (to-i64 rbase) (to-i64 lbase) )) (
            (set ctx TCtxNil)
         ) ())
      ))
      ( (Pair( (TGround( ltn lps )) (TGround( rtn rps )) )) (
         (if (==( ltn rtn )) (
            (set ctx (unify( lps rps )))
         ) ())
      ))
      ( _ () )
   ))
   ctx
)) TContext);

unify := λ(: fpt TypeList)(: pt TypeList). (: (tail(
   (let ctx TCtxEOF)
   (match (Pair( fpt pt )) (
      ()
      ( (Pair( TypeEOF TypeEOF )) (set ctx TCtxNil) )
      ( (Pair( (TypeSeq( lps lp1 )) (TypeSeq( rps rp1 )) )) (tail(
         (set ctx (unify( lp1 rp1 )))
         (if (non-zero ctx) (
            (set ctx (union( ctx (unify( lps rps )) )))
         ) ())
      )))
      ( _ () )
   ))
   ctx
)) TContext);

fields-of-tag := λ(: tag Type)(: class Type). (: (tail(
   (let rhst TAny)
   (match tag (
      ()
      ( (TGround( 'Tag_s (TypeSeq( TypeEOF (TGround( ts _ )) )) )) (match (fields-of-tag ts) (
         ()
         ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF fields-lhs )) fields-rhs )) )) (
            (set rhst (substitute( (unify( fields-lhs class )) fields-rhs )))
         ))
      )))
      ( _ (tail(
         (print 'Invalid\sTag\sIn\sfields-of-tag\s_s)
         (print tag)(print '\n_s)
         (exit 1_u64)
      )))
   ))
   (set rhst (with-size rhst))
   (let rt (TGround( 'Fields_s (close(TypeSeq(
      (close TypeEOF)
      (fields-of-type( (t3( 'Cons_s rhst (TAnd( (close(t1 'U64_s)) (close(t2( 'Sized_s (t1 '8_s) ))) )) )) ))
   ))))))
   rt
)) Type);

fields-of-type := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( TAny (set tt (t1 'Nil_s)) )
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set tt (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (fields-of-type p1)
               )))
               p2
            )))
         )))
      ))
      ( _ (
         (set tt (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (t1 'Nil_s)
               )))
               tt
            )))
         )))
      ))
   ))
   tt
)) Type);

s-type-list := (: STEOF STypeList);
ascript := λ(: t S)(: tt Type). (: (
   (set s-type-list (STSeq(
      (close s-type-list)
      t tt
   )))
) Nil);

typeof := λ(: term S). (: (tail(
   (let found TAny)
   (let tctx s-type-list)
   (while (non-zero tctx) (match tctx (
      ()
      ( (STSeq( rst s tt )) (
         (if (is( s term )) (tail(
            (set found tt)
            (set tctx STEOF)
         )) (
            (set tctx rst)
         ))
      ))
   )))
   found
)) Type);

to-s := λ(: term AST). (: (tail(
   (let s SNil)
   (match term (
      ()
      ( (Var( v _ )) (
         (set s (SCons(
            (close(SAtom 'Var_s))
            (close(SAtom v))
         )))
      ))
      ( (Lit( v _ )) (
         (set s (SCons(
            (close(SAtom 'Lit_s))
            (close(SAtom v))
         )))
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (tail(
         (set s (to-s t))
         (ascript( s tt ))
      )))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (tail(
         (set s (to-s t))
         (ascript( s tt ))
      )))
      ( (App( lt rt )) (
         (set s (SCons(
            (close(SAtom 'App_s))
            (close(SCons(
               (close(to-s lt))
               (close(to-s rt))
            )))
         )))
      ))
      ( (Abs( lt rt tlt )) (
         (set s (SCons(
            (close(SAtom 'Abs_s))
            (close(SCons(
               (close(to-s lt))
               (close(to-s rt))
            )))
         )))
      ))
      ( _ () )
   ))
   s
)) S);

ascript-normal := λ(: t AST)(: tt Type). (: (
   (if (non-zero tt) (tail(
      (let prev-tt (normalize(typeof t)))
      (if (non-zero prev-tt) (
         (if (is-arrow tt) () (tail(
            (let norm-tt (normalize tt))
            (if (&&( (can-unify( prev-tt norm-tt )) (can-unify( norm-tt prev-tt )) )) () (tail(
               (print prev-tt)
               (print '\s!=\s_s)
               (print norm-tt)
               (print '\n_s)
               (exit-error( 'Type\sAscription\sInequality_s t ))
            )))
         )))
      ) (tail(
         (let sized-tt (with-size tt))
         (ascript( t sized-tt ))
         (set types-have-changed True_u8)
      )))
   )) ())
) Nil);

sizeof-type := λ(: tt Type). (: (tail(
   (let sz 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar _) () )
      ( (TGround( class TypeEOF )) (set sz (size-of-class class)) )
      ( (TGround( 'Sized_s (TypeSeq( TypeEOF (TGround( szp TypeEOF )) )) )) (
         (set sz (to-u64 szp))
      ))
      ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF p1 )) TAny )) )) (
         (set sz 8_u64)
      ))
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set sz (+(
            (sizeof-aligned p1)
            (sizeof-aligned p2)
         )))
      ))
      ( (TGround( 'Field_s (TypeSeq( (TypeSeq( TypeEOF p1 )) (TGround( szp TypeEOF )) )) )) (
         (set sz (*( (sizeof-type p1) (to-u64 szp) )))
      ))
      ( (TGround( tag _ )) (
         (match (.lookup( type-complex-fields-index tag (Pair( TAny TAny )) )) (
            ()
            ( (Pair( TAny TAny )) () )
            ( (Pair( bt at )) (tail(
               (let ctx (unify( bt tt )))
               (let arg-types (substitute( ctx at )))
               (set sz (+( 8_u64 (sizeof-aligned arg-types) )))
            )))
         ))
      ))
      ( (TAnd( lt rt )) (
         (if (sizeof-type lt) (
            (set sz (sizeof-type lt))
         ) (
            (set sz (sizeof-type rt))
         ))
      ))
      ( _ (tail(
         (print 'Unexpected\sType\ssizeof-type\s_s)
         (print tt)(print '\n_s)(exit 1_u64)
      )))
   ))
   sz
)) U64);

has-forward := λ(: tt TypeList). (: (tail(
   (let return 0_u64)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( ts t1 )) (
         (set return (max(
            (has-forward ts)
            (has-forward t1)
         )))
      ))
   ))
   return
)) U64);

has-forward := λ(: tt Type). (: (tail(
   (let return 0_u64)
   (match tt (
      ()
      ( (TGround( 'Array_s _ )) () )
      ( (TGround( 'Field_s ps )) (set return (has-forward ps)) )
      ( (TGround( 'Cons_s ps )) (set return (has-forward ps)) )
      ( (TGround( cls ps )) (
         (if (non-zero ps) (
            (set return (has-forward ps))
         ) (
            (if (not(.lookup( class-to-size-index cls 0_u64 ))) (
               (set return 1_u64)
            ) ())
         ))
      ))
      ( (TAnd( lt rt )) (
         (set return (max(
            (has-forward lt)
            (has-forward rt)
         )))
      ))
      ( _ () )
   ))
   return
)) U64);

sizeof-aligned := λ(: tt Type). (: (tail(
   (let sz (sizeof-type tt))
   (if (==( sz 0_u64 )) () (set sz (max( 8_u64 sz ))))
   sz
)) U64);

set-type-fields := λ(: base-type Type)(: args-type Type). (: (tail(
   (let tag '_s)
   (match base-type (
      ()
      ( (TGround( tg _ )) (set tag tg) )
      ( _ (tail(
         (print 'ERROR:\sset-type-fields\n_s)(print base-type)(print '\n_s)
         (exit 1_u64)
      )))
   ))
   (.bind( (as (& type-complex-fields-index) BTreeEq<String,Tuple<Type,Type>>[]) tag (Pair( base-type args-type )) ))
)) Nil);

typeof-lhs := λ(: lhs AST). (: (tail(
   (let r TAny)
   (match lhs (
      ()
      ( (App( (Lit( ':_s _ )) (App( _ (AType tt) )) )) (
         (set r tt)
      ))
      ( (App( ps (App( (Lit( ':_s _ )) (App( _ (AType tt) )) )) )) (
         (set r (t3( 'Cons_s (typeof-lhs ps) tt )))
      ))
      ( ASTNil (
         (set r (t1 'Nil_s))
      ))
      ( _ (exit-error( 'Unknown\sLHS_s lhs )))
   ))
   r
)) Type);

typeof-tag := λ(: tag String). (: (tail(
   (let r (.lookup( type-constructors-index tag TAny )))
   r
)) Type);

as-local-variable := λ(: tt Type). (: (tail(
   (set tt (normalize tt))
   (if (non-zero tt) (
      (set tt (TAnd( (close tt) (close(t1 'LocalVariable_s)) )))
   ) ())
   (set tt (with-size tt))
   tt
)) Type);

as-constant := λ(: tt Type). (: (tail(
   (if (non-zero tt) (
      (set tt (TAnd( (close tt) (close(t1 'Constant_s)) )))
   ) ())
   tt
)) Type);

with-size := λ(: tt Type). (: (tail(
   (if (not(is-sized tt)) (tail(
      (let sz (sizeof-type tt))
      (set tt (with-size-recurse tt))
      (set tt (and( tt (t2( 'Sized_s (t1(to-string sz)) )) )))
   )) ())
   (match tt (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set tt (t3( 'Cons_s (with-size p1) (with-size p2) )))
      ))
      ( _ () )
   ))
   tt
)) Type);

with-size := λ(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( ps p1 )) (
         (set tt (TypeSeq( (close(with-size ps)) (with-size p1) )))
      ))
   ))
   tt
)) TypeList);

with-size-recurse := λ(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set tt (and(
            (with-size-recurse lt)
            (with-size-recurse rt)
         )))
      ))
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(with-size ps)) )))
      ))
      ( _ () )
   ))
   tt
)) Type);

is-sized := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( TAny (set r 1_u64) )
      ( (TGround( 'Cons_s _ )) (set r 1_u64) )
      ( (TGround( 'Arrow_s _ )) (set r 1_u64) )
      ( (TGround( 'Sized_s _ )) (set r 1_u64) )
      ( (TAnd( lt rt )) (
         (set r (max(
            (is-sized lt)
            (is-sized rt)
         )))
      ))
      ( _ () )
   ))
   r
)) U64);

and := λ(: lt Type)(: rt Type). (: (tail(
   (let tt (TAnd( (close lt) (close rt) )))
   tt
)) Type);

is-parameterized := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( (TGround( _ (TypeSeq( _ _ )) )) (set r 1_u64) )
      ( (TAnd( lt rt )) (tail(
         (if (is-parameterized lt) (set r 1_u64) ())
         (if (is-parameterized rt) (set r 1_u64) ())
      )))
      ( _ () )
   ))
   r
)) U64);

deep-hash := λ(: tt Type). (: (tail(
   (let return 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar v) (set return (deep-hash v)) )
      ( (TAnd( lt rt )) (
         (set return (+(
            (deep-hash lt)
            (deep-hash rt)
         )))
      ))
      ( (TGround( tag ps )) (
         (set return (+(
            (deep-hash tag)
            (deep-hash ps)
         )))
      ))
   ))
   return
)) U64);

deep-hash := λ(: tt TypeList). (: (tail(
   (let return 0_u64)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( ts t1 )) (
         (set return (+(
            (deep-hash ts)
            (deep-hash t1)
         )))
      ))
   ))
   return
)) U64);

specialize := λ(: key String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (tail(
   (print 'Specialize\s_s)(print key)(print '\s:\s_s)(print result-type)(print '\n_s)
   (set unify-ctx (normalize unify-ctx))
   (let term ASTEOF)
   (let global-ctx global-type-context)
   (while (non-zero global-ctx) (match global-ctx (
      ()
      ( TCtxNil (set global-ctx TCtxEOF) )
      ( (TCtxBind( rst k kt t )) (tail(
         (if (==( k key )) (
            (if (==( ft kt )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (set term t) )
                  ( _ () )
               ))
            ) ())
         ) ())
         (set global-ctx rst)
      )))
   )))
   (mark-as-special( key result-type ))
   (let special-term (substitute( unify-ctx term )))
   (infer-global-context( special-term ))
   (infer-expr( global-type-context special-term Unused TAny ))
   (set ast-parsed-program (Seq(
      (close ast-parsed-program)
      (close special-term)
   )))
)) Nil);

has-representation := λ(: tt Type). (: (tail(
   (let return 0_u64)
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set return (max(
            (has-representation lt)
            (has-representation rt)
         )))
      ))
      ( (TGround( 'Constant_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg8_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg16_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg32_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg64_s _ )) (set return 1_u64) )
      ( (TGround( 'StackVariable_s _ )) (set return 1_u64) )
      ( _ () )
   ))
   return
)) U64);

guess-representation := λ(: tt Type). (: (tail(
   (if (has-representation tt) () (tail(
      (let sz (sizeof-type tt))
      (match sz (
         ()
         ( 0_u64 () )
         ( 1_u64 (set tt (and( tt (t1( 'Reg8_s )) ))) )
         ( 2_u64 (set tt (and( tt (t1( 'Reg16_s )) ))) )
         ( 4_u64 (set tt (and( tt (t1( 'Reg32_s )) ))) )
         ( 8_u64 (set tt (and( tt (t1( 'Reg64_s )) ))) )
         ( _ (set tt (and( tt (t1( 'StackVariable_s )) ))) )
      ))
   )))
   tt
)) Type);

unify-hint := λ(: hint Type)(: tt Type). (: (tail(
   (match (Pair( hint tt )) (
      ()
      ( (Pair( (TGround( hint-tag hint-args )) (TGround( tt-tag tt-args )) )) (
         (if (==( hint-tag tt-tag )) (
            (set tt hint)
         ) (
            (set tt (TGround( tt-tag (close(unify-hint( hint tt-args ))) )))
         ))
      ))
      ( (Pair( _ (TAnd( lt rt )) )) (
         (set tt (TAnd(
            (close(unify-hint( hint lt )))
            (close(unify-hint( hint rt )))
         )))
      ))
      ( _ () )
   ))
   tt
)) Type);

unify-hint := λ(: hint Type)(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(unify-hint( hint rst )))
            (unify-hint( hint p1 ))
         )))
      ))
      ( _ () )
   ))
   tt
)) TypeList);


typecheck := λ. (: (tail(
   (let p ast-parsed-program)
   (let ordered-type-exprs ASTEOF)
   (while (non-zero p) (match p (
      ()
      ( (Seq( rst r )) (tail(
         (set ordered-type-exprs (Seq( (close ordered-type-exprs) (close r) )))
         (set p rst)
      )))
   )))
   (while (non-zero ordered-type-exprs) (match ordered-type-exprs (
      ()
      ( (Seq( rst r )) (tail(
         (infer-global-context( r ))
         (set ordered-type-exprs rst)
      )))
   )))
   (infer-expr( global-type-context ast-parsed-program Unused TAny ))
   (assert-well-typed ast-parsed-program)
)) Nil);

infer-type-definition := λ(: base-type Type)(: body AST). (: (tail(
   (let r 0_u64)
   (match body (
      ()
      ( (App( (App( tds (Var( '|_s _ )) )) case )) (tail(
         (let r1 (infer-type-definition( base-type tds )))
         (let r2 (infer-type-constructor( base-type case )))
         (set r (max( r1 r2 )))
      )))
      ( case (
         (set r (infer-type-constructor( base-type case )))
      ))
   ))
   r
)) U64);

infer-type-constructor := λ(: base-type Type)(: body AST). (: (tail(
   (let r 0_u64)
   (match body (
      ()
      ( (Lit( tag _ )) (tail(
         (annotate-head-accessor( base-type ))
         (let rtype (and(
            (and(
               base-type
               (t2( 'Tag_s (t1 tag) ))
            ))
            (and(
               (t1 'Constant_s)
               (and(
                  (t2( 'Constructor_s (t1 tag) ))
                  (t2( 'FieldsSized_s (t1 '0_s) ))
               ))
            ))
         )))
         (index-class-of-tag( tag base-type ))
         (index-fields-of-tag( tag TAny ))
         (.bind( (as (& type-constructors-index) BTreeEq<String,Type>[]) tag rtype ))
         (set r 8_u64)
      )))
      ( (App( (Lit( tag _ )) args )) (tail(
         (let atype (type-of-s args))
         (if (has-forward atype) (tail(
            (print 'Size\sOf\sType\sCannot\sBe\sDetermined\sDue\sTo\sForward\sReference:\s_s)
            (print tag)(print '\n_s)
            (exit 1_u64)
         )) ())
         (let rtype (and(
            base-type
            (t2( 'Tag_s (t1 tag) ))
         )))
         (set-type-fields( base-type atype ))
         (annotate-head-accessor( base-type ))
         (annotate-accessors( base-type (t2( 'Tag_s (parse-type tag) )) atype ))
         (index-class-of-tag( tag base-type ))
         (index-fields-of-tag( tag (t3( 'Cons_s base-type atype )) ))
         (.bind( (as (& type-constructors-index) BTreeEq<String,Type>[]) tag (t3( 'Arrow_s atype rtype )) ))
         (set r (sizeof-aligned atype))
         (set r (+( r 8_u64 )))
      )))
      ( _ () )
   ))
   r
)) U64);

annotate-head-accessor := λ(: base-type Type). (: (tail(
   (let tt (and( (t1 'U64_s) (t1 'Reg64_s) )))
   (set global-type-context (TCtxBind(
      (close global-type-context)
      '.0_s
      (t3( 'Arrow_s base-type tt ))
      ASTEOF
   )))
)) Nil);

annotate-accessors := λ(: base-type Type)(: tag-type Type)(: args-type Type). (: (tail(
   (let base-type-2 (and(
      base-type
      tag-type
   )))
   (set base-type base-type-2)
   (let field-number 1_u64)
   (while (non-zero args-type) (match args-type (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF lt )) rt )) )) (tail(
         (set rt (guess-representation rt))
         (let accessor-name (clone-rope(SCons(
            (close (SAtom '._s))
            (close (SAtom (to-string field-number)))
         ))))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            accessor-name
            (t3( 'Arrow_s base-type rt ))
            ASTEOF
         )))
         (set field-number (+( field-number 1_u64 )))
         (set args-type lt)
      )))
      ( rt (tail(
         (set rt (guess-representation rt))
         (let accessor-name (clone-rope(SCons(
            (close (SAtom '._s))
            (close (SAtom (to-string field-number)))
         ))))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            accessor-name
            (t3( 'Arrow_s base-type rt ))
            ASTEOF
         )))
         (set args-type TAny)
      )))
   )))
)) Nil);

infer-global-context := λ(: td AST). (: (
   (match td (
      ()
      ( (Typedef( (Lit( base-type _ )) case-constructors )) (tail(
         (let bt (parse-type base-type))
         (let size (infer-type-definition( bt case-constructors )))
         (match bt (
            ()
            ( (TGround( class TypeEOF )) (index-size-of-class( class size )) )
            ( _ () )
         ))
      )))
      ( (Glb( k_t (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) )) (tail(
         (let lt (typeof-lhs lhs))
         (let return-type (guess-representation(without-representation rhst)))
         (let ft (t3( 'Arrow_s lt return-type )))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            td
         )))
      )))
      ( (Frg( k_t (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) atlt )) tlt )) (tail(
         (let lt (typeof-lhs lhs))
         (let ft (t3( 'Arrow_s lt rhst )))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            ASTEOF
         )))
      )))
      ( (Glb( k_t (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) )) (tail(
         (let kt (and( rhst (t1 'GlobalVariable_s) )))
         (set global-type-context (TCtxBind(
            (close global-type-context) k kt ASTEOF
         )))
         (ascript-normal( td kt ))
      )))
      ( (Frg( k_t (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) (
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            rhst ASTEOF
         )))
      ))
      ( (Glb( _ _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( (Frg( _ _ _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( _ () )
   ))
) Nil);

assert-well-typed := λ(: term AST). (: (
   (match term (
      ()
      ( ASTEOF (assert-one-typed term) )
      ( ASTNil (assert-one-typed term) )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (
            (assert-well-typed v)
         ))
      ))
      ( (Frg( _ v _ )) (
         (assert-one-typed v)
      ))
      ( (Typedef( _ _ )) () )
      ( (App( (Abs( (Var( lname _ )) ASTNil tlt )) rhs )) (tail(
         (assert-well-typed rhs)
         (assert-one-typed term)
      )))
      ( (App( (Var( 'gensym-label_s _ )) _ )) () )
      ( (App( (Var( 'label_s _ )) (Var( _ _ )) )) () )
      ( (App( (App( (Var( 'while_s _ )) cond )) body )) (tail(
         (assert-well-typed cond)
         (assert-well-typed body)
         (assert-one-typed term)
      )))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (assert-well-typed t)
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (assert-well-typed t)
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (tail(
         (assert-well-typed cond)
         (assert-well-typed t)
         (assert-well-typed f)
         (assert-one-typed term)
      )))
      ( (App( (App( (Var( 'set_s _ )) lhs )) rhs )) (tail(
         (assert-well-typed rhs)
         (assert-one-typed term)
      )))
      ( (AType _) () )
      ( (App( (Var( 'tail_s _ )) (App( lterm rterm )) )) (tail(
         (assert-well-typed lterm)
         (assert-well-typed rterm)
         (assert-one-typed term)
      )))
      ( (App( (Var( 'maybe-deref_s _ )) rterm )) (tail(
         (assert-well-typed rterm)
         (assert-one-typed term)
      )))
      ( (App( (Var( 'scope_s _ )) rterm )) (tail(
         (assert-well-typed rterm)
         (assert-one-typed term)
      )))
      ( (Lit( l _ )) (assert-one-typed term) )
      ( (Var( l _ )) (assert-one-typed term) )
      ( (Abs( lhs rhs tlt )) (tail(
         (assert-well-typed rhs)
         (assert-one-typed term)
      )))
      ( (App( l r )) (tail(
         (assert-well-typed l)
         (assert-well-typed r)
         (assert-one-typed term)
      )))
      ( (Seq( l r )) (tail(
         (assert-well-typed l)
         (assert-well-typed r)
      )))
      ( term (tail(
         (print 'Unknown\sTerm\sIn\sAssert\sWell\sTyped\s_s)(print term)(print '\n_s)
         (exit 1_u64)
      )))
   ))
) Nil);

assert-one-typed := λ(: term AST). (: (
   (if (non-zero(typeof term)) () (
      (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s term ))
   ))
) Nil);

with-fields := λ(: tt Type). (: (tail(
   (match (slot( tt 'Fields_s )) (
      ()
      ( (TGround( 'Fields_s _ )) () )
      ( _ (tail(
         (let class (with-only-class tt))
         (let tag (with-only-tag tt))
         (if (&&( (non-zero tag) (non-zero class) )) (tail(
            (let ft (fields-of-tag( tag class )))
            (set tt (and( tt ft )))
         )) ())
      )))
   ))
   tt
)) Type);

apply := λ(: function-name String)(: ft Type)(: pt Type). (: (tail(
   (let tt (apply( function-name ft pt False_u8 )))
   tt
)) Type);

apply-and-specialize := λ(: function-name String)(: ft Type)(: pt Type). (: (tail(
   (let tt (apply( function-name ft pt True_u8 )))
   tt
)) Type);

apply := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8). (: (tail(
   (let r TAny)
   (match ft (
      ()
      ( (TAnd( t1 t2 )) (tail(
         (set r (apply( function-name t1 pt do-specialize )))
         (if (non-zero r) () (
            (set r (apply( function-name t2 pt do-specialize )))
         ))
      )))
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF fpt )) frt )) )) (tail(
         (let ctx (unify( fpt pt )))
         (if (non-zero ctx) (tail(
            (set ctx (normalize ctx))
            (let closed-type (substitute( ctx ft )))
            (set r (guess-representation(substitute( ctx frt ))))
            (if (&&( (==( do-specialize True_u8 )) (is-open fpt) )) (tail(
               (print 'Apply.6\n_s)
               (if (is-open closed-type) (tail(
                  (print 'Application\sDid\sNot\sClose\sBefore\sSpecialization:\n_s)
                  (print 'Function\s_s)(print function-name)(print '\s:\s_s)(print ft)(print '\n_s)
                  (print 'Argument\s_s)(print pt)(print '\n_s)
                  (exit 1_u64)
               )) ())
               (try-specialize( function-name ft ctx closed-type ))
            )) ())
         )) ())
      )))
      ( _ () )
   ))
   r
)) Type);

apply-or-cons-and-specialize := λ(: function-name String)(: ft Type)(: pt Type). (: (tail(
   (let r TAny)
   (print 'Apply\sOr\sCons.1\n_s)
   (if (is-arrow ft) (
      (set r (apply( function-name ft pt True_u8 )))
   ) (
      (if (&&( (non-zero ft) (non-zero pt) )) (
         (set r (t3( 'Cons_s ft pt )))
      ) ())
   ))
   r
)) Type);

try-specialize := λ(: function-name String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (tail(
   (set result-type (normalize result-type))
   (let global-ctx global-type-context)
   (if (is-special( function-name result-type )) () (
      (while (non-zero global-ctx) (match global-ctx (
         ()
         ( TCtxNil (set global-ctx TCtxEOF) )
         ( (TCtxBind( rst k kt t )) (tail(
            (if (&&( (==( function-name k )) (==( ft kt )) )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (
                     (specialize( function-name ft unify-ctx result-type ))
                  ))
                  ( _ () )
               ))
            ) ())
            (set global-ctx rst)
         )))
      )))
   ))
)) Nil);

infer-tctx := λ(: tctx TContext)(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst p1 )) (tail(
         (set tctx (infer-tctx( tctx rst )))
         (set tctx (infer-tctx( tctx p1 )))
      )))
   ))
   tctx
)) TContext);

infer-tctx := λ(: tctx TContext)(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (set tctx (infer-tctx( tctx lt )))
         (set tctx (infer-tctx( tctx rt )))
      )))
      ( (TVar( tv )) (
         (set tctx (TCtxBind(
            (close tctx)
            tv
            (t1 'Constant_s)
            ASTEOF
         )))
      ))
      ( (TGround( _ ts )) (
         (set tctx (infer-tctx( tctx ts )))
      ))
      ( TAny () )
   ))
   tctx
)) TContext);

infer-ctx := λ(: tctx TContext)(: lhs AST). (: (tail(
   (match lhs (
      ()
      ( (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) (tail(
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-tctx( tctx tt )))
      )))
      ( (App( ps (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) )) (tail(
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-ctx( tctx ps )))
         (set tctx (infer-tctx( tctx tt )))
      )))
      ( ASTNil () )
      ( _ (exit-error( 'Invalid\sLHS_s lhs )) )
   ))
   tctx
)) TContext);

typeof-var := λ(: sloc AST)(: tctx TContext)(: vname String). (: (tail(
   (let found TAny)
   (while (non-zero tctx) (match tctx (
      ()
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k vt _ )) (
         (if (==( k vname )) (tail(
            (if (non-zero found) (
               (if (is-arrow vt) (
                  (set found (and( found vt )))
               ) (
                  (set found vt)
               ))
            ) (
               (set found vt)
            ))
            (if (is-arrow vt) (
               (set tctx rst)
            ) (
               (set tctx TCtxEOF)
            ))
         )) (
            (set tctx rst)
         ))
      ))
   )))
   (if (non-zero found) () (
      (exit-error( 'Unknown\sReferenced\sVariable_s sloc ))
   ))
   found
)) Type);

infer-expr := λ(: tctx TContext)(: term AST)(: used IsUsed)(: hint Type). (: (tail(
   (match term (
      ()
      ( ASTNil (ascript-normal( term (t1 'Nil_s) )) )
      ( ASTEOF (ascript-normal( term (t1 'Nil_s) )) )
      ( (Seq( l r )) (tail(
         (infer-expr( tctx l used TAny ))
         (infer-expr( tctx r used TAny ))
      )))
      ( (Typedef( _ _ )) () )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (tail(
            (print 'Infer\sGlobal\s_s)(print k)(print '\n_s)
            (infer-expr( tctx v Used TAny ))
         )))
      ))
      ( (Frg( _ v _ )) (
         (ascript-normal( v (typeof term) ))
      ))
      ( (App( (Lit( ':_s _ )) (App( (Lit( _ _ )) (AType tt) )) )) (
         (match term (
            ()
            ( (App( _ (App( t _ )) )) (tail(
               (match (slot( tt 'String_s )) (
                  ()
                  ( (TGround( 'String_s _ )) () )
                  ( _ (infer-expr( tctx t used tt )) )
               ))
               (let inner-tt (typeof t))
               (if (non-zero inner-tt) (
                  (set tt (and( tt inner-tt )))
               ) (
                  (ascript-normal( t tt ))
               ))
               (ascript-normal( term tt ))
            )))
         ))
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (tail(
         (print 'Infer\sAscript\s_s)(print term)(print '\n_s)
         (let tctx2 (maybe-deref(infer-expr( tctx t used tt ))))
         (set tctx tctx2)
         (let inner-tt (maybe-deref(typeof t)))
         (if (non-zero inner-tt) (tail(
            (let nn (with-only-representation inner-tt))
            (if (non-zero nn) (tail(
               (let tt-2 (and(
                  tt
                  nn
               )))
               (set tt tt-2)
            )) ())
            (ascript-normal( t tt ))
            (ascript-normal( term tt ))
            (match term (
               ()
               ( (App( las ras )) (tail(
                  (ascript-normal( las tt ))
                  (ascript-normal( ras tt ))
               )))
            ))
         )) ())
      )))
      ( (App( (Var( 'gensym-label_s _ )) (Var( lname _ )) )) (tail(
         (set tctx (TCtxBind(
            (close tctx) lname (t1 'Label_s) ASTEOF
         )))
         (ascript-normal( term (t1 'Nil_s) ))
      )))
      ( (App( (App( (Var( 'set_s _ )) (Var( v _ )) )) rhs )) (tail(
         (infer-expr( tctx rhs Used TAny ))
         (ascript-normal( rhs (typeof-var( term tctx v )) ))
         (ascript-normal( term (t1 'Nil_s) ))
      )))
      ( (App( (Var( 'label_s _ )) (Var( lname _ )) )) (
         (ascript-normal( term (t1 'Nil_s) ))
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (tail(
         (set tctx (infer-expr( tctx cond Used TAny )))
         (set tctx (infer-expr( tctx t Used TAny )))
         (infer-expr( tctx f Used TAny ))
         (ascript-normal( term (typeof t) ))
      )))
      ( (App( (App( (Var( 'while_s _ )) cond )) body )) (tail(
         (set tctx (infer-expr( tctx cond Used TAny )))
         (infer-expr( tctx body Used TAny ))
         (ascript-normal( term (t1 'Nil_s) ))
      )))
      ( (App( (Var( 'tail_s _ )) (App( l r )) )) (tail(
         (set tctx (infer-expr( tctx l Unused TAny )))
         (set tctx (infer-expr( tctx r used TAny )))
         (ascript-normal( term (typeof r) ))
      )))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (tail(
         (set tctx (infer-expr( tctx t used TAny )))
         (let inner-tt (typeof t))
         (if (non-zero inner-tt) (tail(
            (let nn (with-only-representation inner-tt))
            (if (non-zero nn) (
               (set tt (and( tt nn )))
            ) ())
            (let nn (with-only-class inner-tt))
            (if (non-zero nn) (
               (set tt (and( tt nn )))
            ) ())
            (set tt (with-fields( tt )))
            (ascript-normal( term tt ))
         )) ())
      )))
      ( (App( (Var( 'sizeof_s _ )) (AType _) )) (tail(
         (let tt (as-constant(parse-type 'U64_s)))
         (ascript-normal( term tt ))
         (match term (
            ()
            ( (App( s _ )) (ascript-normal( s tt )) )
         ))
      )))
      ( (App( (Var( 'scope_s _ )) r )) (tail(
         (infer-expr( tctx r used TAny ))
         (ascript-normal( term (typeof r) ))
      )))
      ( (App( (Var( 'maybe-deref_s _ )) r )) (tail(
         (set tctx (infer-expr( tctx r used TAny )))
         (let deref-type (typeof r))
         (match (slot( deref-type 'Array_s )) (
            ()
            ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF TAny )) _ )) )) () )
            ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF array-base )) TAny )) )) (
               (set deref-type (and( array-base (t1 'StackVariable_s) )))
            ))
            ( _ () )
         ))
         (ascript-normal( term deref-type ))
      )))
      ( (App( (Abs( (Var( lname _ )) ASTNil tlt )) rhs )) (tail(
         (infer-expr( tctx rhs Used TAny ))
         (let tt (typeof rhs))
         (let rt (as-local-variable tt))
         (if (non-zero tt) () (
            (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s rhs ))
         ))
         (if (non-zero rt) () (
            (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s rhs ))
         ))
         (set tctx (TCtxBind(
            (close tctx) lname rt ASTEOF
         )))
         (ascript-normal( term (maybe-deref(t1 'Nil_s)) ))
      )))
      ( (App( l r )) (tail(
         (print 'Infer\s_s)(print term)(print '\n_s)
         (set tctx (infer-expr( tctx l Used TAny )))
         (set tctx (infer-expr( tctx r Used TAny )))
         (print 'Infer.2\s_s)(print term)(print '\n_s)
         (let rt (apply-or-cons-and-specialize(
            (var-name-if-var l)
            (typeof l)
            (typeof r)
         )))
         (print 'Infer.3\s_s)(print term)(print '\n_s)
         (ascript-normal( term rt ))
         (print 'Infer.4\s_s)(print term)(print '\n_s)
      )))
      ( (Abs( lhs rhs tlt )) (tail(
         (set tctx (infer-ctx( tctx lhs )))
         (infer-expr( tctx rhs Used TAny ))
         (let lt (typeof-lhs lhs))
         (let rt (typeof rhs))
         (ascript-normal( term (t3( 'Arrow_s lt rt )) ))
      )))
      ( (Var( v _ )) (tail(
         (let vt (typeof-var( term tctx v )))
         (print 'VType\s_s)(print v)(print '\s:\s_s)(print (typeof term))(print '\n_s)
         (print 'Ascript\s_s)(print v)(print '\s:\s_s)(print vt)(print '\n_s)
         (ascript-normal( term (typeof-var( term tctx v )) ))
      )))
      ( (Lit( l _ )) (
         (if (non-zero(typeof term)) () (tail(
            (let tt (typeof-tag l))
            (if (non-zero tt) (tail(
               (if (non-zero hint) (
                  (set tt (unify-hint( hint tt )))
               ) ())
               (ascript-normal( term tt ))
            )) ())
         )))
      ))
      ( _ (tail(
         (print 'Unknown\sTerm\sIn\sType\sInference\n_s)
         (print term)
         (print '\n_s)
         (exit 1_u64)
      )))
   ))
   tctx
)) TContext);

