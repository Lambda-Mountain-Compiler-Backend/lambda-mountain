
apply := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt False_u8 blame )))
   tt
) Type);

apply-and-specialize := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt True_u8 blame )))
   tt
) Type);

apply-plural := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (let r (: LEOF List<Type>))
   (match ft (
      ()
      ( (TAnd( t1 t2 )) (
         (set r (+(
            (apply-plural( function-name t1 pt do-specialize blame ))
            (apply-plural( function-name t2 pt do-specialize blame ))
         )))
      ))
      ( (TGround( 'Arrow_s (LCons( frt (LCons( fpt LEOF )) )) )) (
         (if (can-unify( fpt pt )) (
            (set r (cons( ft r )))
         ) ())
      ))
      ( _ () )
   ))
   r
) List<Type>);

reduce-plural := λ(: pts List<Type>). (: (
   (let r (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( try tlt )) (
         (set pts tlt)
         (for-each (tst in tlt) (
            (if (non-zero try) (
               (if (can-unify( (domain try) (domain tst) )) (
                  (set try TAny)
               ) ())
            ) ())
         ))
         (if (non-zero try) (
            (set r (cons( try r )))
         ) ())
      ))
   )))
   (set pts r)
   (set r (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( try tlt )) (
         (set pts tlt)
         (for-each (tst in tlt) (
            (if (non-zero try) (
               (if (can-unify( (domain try) (domain tst) )) (
                  (set try TAny)
               ) ())
            ) ())
         ))
         (if (non-zero try) (
            (set r (cons( try r )))
         ) ())
      ))
   )))
   r
) List<Type>);

apply := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (let r TAny)
   (let rs (apply-plural( function-name ft pt do-specialize blame )))
   (let is-hook (non-zero(slot( ft 'Hook_s ))))
   (if (==( is-hook 0_u64 )) (
      (set rs (reduce-plural rs))
   ) ())
   (if (&&( (==( (.length rs) 0_u64 )) (!=( function-name 'del_s )) )) (
      (print 'Function\sApplication\sYielded\sNo\sMatches\n_s)
      (print function-name)(print '\nWith\sArgument\s:\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (print 'Options:\s_s)(print ft)(print '\n_s)
      (exit 1_u64)
   ) ())
   (if (&&( (>( (.length rs) 1_u64 )) (==( is-hook 0_u64 )) )) (
      (print 'Function\sApplication\sYielded\sAn\sIrreducible\sPlurality\sOf\sMatches\n_s)
      (print function-name)(print '\s:\s_s)(print ft)(print '\n_s)
      (print 'With\sArgument\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (let rs-copy rs)
      (while (non-zero( rs-copy )) (
         (print 'Matched\s_s)
         (match rs-copy (
            ()
            ( (LCons( hd tl )) (
               (print hd)
               (set rs-copy tl)
            ))
         ))
         (print '\n_s)
      ))
      (exit 1_u64)      
   ) ())
   (for-each (sft in rs) (
      (match sft (
         ()
         ( (TGround( 'Arrow_s (LCons( frt (LCons( fpt LEOF )) )) )) (
            (let ctx (unify( fpt pt )))
            (set ctx (normalize ctx))
            (let closed-type (substitute( ctx sft )))
            (set r (guess-representation(substitute( ctx frt ))))
            (if (&&( (==( do-specialize True_u8 )) (is-open sft) )) (
               (if (is-open closed-type) (
                  (print 'Application\sDid\sNot\sClose\sBefore\sSpecialization:\n_s)
                  (print 'Function\s_s)(print function-name)(print '\s:\s_s)(print sft)(print '\n_s)
                  (print 'Argument\s_s)(print pt)(print '\n_s)
                  (print (location-of( blame )))(print '\n_s)
                  (exit 1_u64)
               ) ())
               (try-specialize( function-name sft ctx closed-type ))
            ) ())
         ))
         ( _ (
            (print 'Function\sNot\sSimple\sArrow:\s_s)(print sft)(print '\n_s)
            (exit 1_u64)
         ))
      ))
   ))
   r
) Type);

apply-or-cons-and-specialize := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let r TAny)
   (if (is-arrow ft) (
      (set r (apply( function-name ft pt True_u8 blame )))
   ) (
      (if (&&( (non-zero ft) (non-zero pt) )) (
         (set r (t3( 'Cons_s ft pt )))
      ) ())
   ))
   r
) Type);

try-specialize := λ(: function-name String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (
   (set result-type (normalize result-type))
   (let global-ctx global-type-context)
   (if (is-special( function-name result-type )) () (
      (while (non-zero global-ctx) (match global-ctx (
         ()
         ( TCtxNil (set global-ctx TCtxEOF) )
         ( (TCtxBind( rst k kt t )) (
            (set kt (slot( kt 'Arrow_s )))
            (if (&&( (==( function-name k )) (==( ft kt )) )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (
                     (specialize( function-name ft unify-ctx result-type ))
                  ))
                  ( _ () )
               ))
            ) ())
            (set global-ctx rst)
         ))
      )))
   ))
) Nil);

infer-tctx := λ(: tctx TContext)(: tt List<Type>). (: (
   (match tt (
      ()
      ( LEOF () )
      ( (LCons( p1 rst )) (
         (set tctx (infer-tctx( tctx rst )))
         (set tctx (infer-tctx( tctx p1 )))
      ))
   ))
   tctx
) TContext);

infer-tctx := λ(: tctx TContext)(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set tctx (infer-tctx( tctx lt )))
         (set tctx (infer-tctx( tctx rt )))
      ))
      ( (TVar( tv )) (
         (set tctx (TCtxBind(
            (close tctx)
            tv
            (t1 'Constant_s)
            ASTEOF
         )))
      ))
      ( (TGround( _ ts )) (
         (set tctx (infer-tctx( tctx ts )))
      ))
      ( TAny () )
   ))
   tctx
) TContext);

infer-ctx := λ(: tctx TContext)(: lhs AST). (: (
   (match lhs (
      ()
      ( (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) (
         (set tt (denormalize tt))
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-tctx( tctx tt )))
      ))
      ( (App( ps (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) )) (
         (set tt (denormalize tt))
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-ctx( tctx ps )))
         (set tctx (infer-tctx( tctx tt )))
      ))
      ( ASTNil () )
      ( _ (exit-error( 'Invalid\sLHS_s lhs )) )
   ))
   tctx
) TContext);

implicit-tail := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TGround( 'Cons_s (LCons( tl (LCons( hd LEOF )) )) )) (
         (set tt tl)
      ))
      ( _ () )
   ))
   tt
) Type);

typeof-var := λ(: sloc AST)(: tctx TContext)(: vname String). (: (
   (let found (typeof-var-raw( sloc tctx vname )))
   (if (non-zero found) () (
      (exit-error( 'Unknown\sReferenced\sVariable_s sloc ))
   ))
   found
) Type);

typeof-var-raw := λ(: sloc AST)(: tctx TContext)(: vname String). (: (
   (let found (find-alias-type vname))
   (while (non-zero tctx) (match tctx (
      ()
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k vt _ )) (
         (if (==( k vname )) (
            (if (non-zero found) (
               (if (is-arrow vt) (
                  (set found (and( found vt )))
               ) (
                  (set found vt)
               ))
            ) (
               (set found vt)
            ))
            (if (is-arrow vt) (
               (set tctx rst)
            ) (
               (set tctx TCtxEOF)
            ))
         ) (
            (set tctx rst)
         ))
      ))
   )))
   found
) Type);

is-reg8 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'AL_s (set r 1_u64))
      ( 'BL_s (set r 1_u64))
      ( 'CL_s (set r 1_u64))
      ( 'DL_s (set r 1_u64))
      ( 'SIL_s (set r 1_u64))
      ( 'DIL_s (set r 1_u64))
      ( 'BPL_s (set r 1_u64))
      ( 'SPL_s (set r 1_u64))
      ( 'R8B_s (set r 1_u64))
      ( 'R9B_s (set r 1_u64))
      ( 'R10B_s (set r 1_u64))
      ( 'R11B_s (set r 1_u64))
      ( 'R12B_s (set r 1_u64))
      ( 'R13B_s (set r 1_u64))
      ( 'R14B_s (set r 1_u64))
      ( 'R15B_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg16 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'AX_s (set r 1_u64))
      ( 'BX_s (set r 1_u64))
      ( 'CX_s (set r 1_u64))
      ( 'DX_s (set r 1_u64))
      ( 'SI_s (set r 1_u64))
      ( 'DI_s (set r 1_u64))
      ( 'BP_s (set r 1_u64))
      ( 'SP_s (set r 1_u64))
      ( 'R8W_s (set r 1_u64))
      ( 'R9W_s (set r 1_u64))
      ( 'R10W_s (set r 1_u64))
      ( 'R11W_s (set r 1_u64))
      ( 'R12W_s (set r 1_u64))
      ( 'R13W_s (set r 1_u64))
      ( 'R14W_s (set r 1_u64))
      ( 'R15W_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg32 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'EAX_s (set r 1_u64))
      ( 'EBX_s (set r 1_u64))
      ( 'ECX_s (set r 1_u64))
      ( 'EDX_s (set r 1_u64))
      ( 'ESI_s (set r 1_u64))
      ( 'EDI_s (set r 1_u64))
      ( 'EBP_s (set r 1_u64))
      ( 'ESP_s (set r 1_u64))
      ( 'R8D_s (set r 1_u64))
      ( 'R9D_s (set r 1_u64))
      ( 'R10D_s (set r 1_u64))
      ( 'R11D_s (set r 1_u64))
      ( 'R12D_s (set r 1_u64))
      ( 'R13D_s (set r 1_u64))
      ( 'R14D_s (set r 1_u64))
      ( 'R15D_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg64 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'RAX_s (set r 1_u64))
      ( 'RBX_s (set r 1_u64))
      ( 'RCX_s (set r 1_u64))
      ( 'RDX_s (set r 1_u64))
      ( 'RSI_s (set r 1_u64))
      ( 'RDI_s (set r 1_u64))
      ( 'RBP_s (set r 1_u64))
      ( 'RSP_s (set r 1_u64))
      ( 'R8_s (set r 1_u64))
      ( 'R9_s (set r 1_u64))
      ( 'R10_s (set r 1_u64))
      ( 'R11_s (set r 1_u64))
      ( 'R12_s (set r 1_u64))
      ( 'R13_s (set r 1_u64))
      ( 'R14_s (set r 1_u64))
      ( 'R15_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);

