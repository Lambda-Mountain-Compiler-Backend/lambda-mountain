
infer-type-constructor := λ(: base-type Type)(: body AST). (: (
   (let r 0_u64)
   (match body (
      ()
      ( (Lit( tag _ )) (
         (let rtype (and(
            (and(
               base-type
               (t2( 'Tag_s (t1 tag) ))
            ))
            (and(
               (t1 'Constant_s)
               (and(
                  (t2( 'Constructor_s (t1 tag) ))
                  (t2( 'FieldsSized_s (t1 '0_s) ))
               ))
            ))
         )))
         (index-class-of-tag( tag base-type ))
         (index-fields-of-tag( tag TAny (t1 'Nil_s) ))
         (.bind( (as (& type-constructors-index) BTreeEq<String,Type>[]) tag rtype ))
         (set r 8_u64)
      ))
      ( (App( (Lit( tag _ )) args )) (
         (let atype (type-of-s-with-fields( base-type tag args 1_u64 )))
         (mark-constructor-flat-parameters( base-type atype ))
         (if (has-forward( atype )) (
            (print 'Size\sOf\sType\sCannot\sBe\sDetermined\sDue\sTo\sForward\sReference:\s_s)
            (print tag)(print '\n_s)
            (exit 1_u64)
         ) ())
         (if (has-infinite( base-type atype )) (
            (print 'Size\sOf\sType\sIs\sInfinite:\s_s)
            (print tag)(print '\n_s)
            (exit 1_u64)
         ) ())
         (let rtype (and(
            base-type
            (t2( 'Tag_s (t1 tag) ))
         )))
         (set-type-fields( base-type atype ))
         (index-class-of-tag( tag base-type ))
         (index-fields-of-tag( tag base-type atype ))
         (.bind( (as (& type-constructors-index) BTreeEq<String,Type>[]) tag (t3( 'Arrow_s atype rtype )) ))
         (set r (sizeof-aligned atype))
         (set r (+( r 8_u64 )))
      ))
      ( _ () )
   ))
   r
) U64);

infer-global-context := λ(: td AST). (: (
   (match td (
      ()
      ( (Typedef( (Lit( base-type _ )) case-constructors )) (
         (let bt (parse-type base-type))
         (let size (infer-type-definition( bt case-constructors 0_u64 )))
         (match bt (
            ()
            ( (TGround( class LEOF )) (index-size-of-class( class size )) )
            ( _ () )
         ))
      ))
      ( (Glb( k_t (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) )) (
         (let lt (typeof-lhs lhs))
         (let return-type (guess-representation(without-representation rhst)))
         (let ft (t3( 'Arrow_s lt return-type )))
         (set ft (enrich( ft tlt )))
         (if (&&( (non-zero(slot( tlt 'Hook_s ))) (not(non-zero(slot( rhst 'Nil_s )))) )) (
            (exit-error( 'Hooks\sMust\sNot\sReturn\sValues._s td ))
         ) ())
         (mark-global-as-seen( k ft tlt ))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            td
         )))
      ))
      ( (Frg( k_t (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) )) (
         (let lt (typeof-lhs lhs))
         (let ft (t3( 'Arrow_s lt rhst )))
         (if (&&( (non-zero(slot( tlt 'Hook_s ))) (not(non-zero(slot( rhst 'Nil_s )))) )) (
            (exit-error( 'Hooks\sMust\sNot\sReturn\sBalues._s td ))
         ) ())
         (set ft (enrich( ft tlt )))
         (mark-global-as-seen( k ft tlt ))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            ASTEOF
         )))
      ))
      ( (Glb( k_t (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) )) (
         (let kt (and( (without-representation rhst) (t1 'GlobalVariable_s) )))
         (set global-type-context (TCtxBind(
            (close global-type-context) k kt ASTEOF
         )))
         (mark-global-as-seen( k kt TAny ))
         (ascript-normal( td kt ))
      ))
      ( (Frg( k_t (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) )) (
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            rhst ASTEOF
         )))
         (mark-global-as-seen( k rhst TAny ))
      ))
      ( (Glb( _ _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( (Frg( _ _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( _ () )
   ))
) Nil);

assert-well-typed := λ(: term AST). (: (
   (match term (
      ()
      ( ASTEOF (assert-one-typed term) )
      ( ASTNil (assert-one-typed term) )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (
            (assert-well-typed v)
         ))
      ))
      ( (Frg( _ v )) (
         (assert-one-typed v)
      ))
      ( (Typedef( _ _ )) () )
      ( (App( (Abs( (Var( lname _ )) ASTNil tlt )) rhs )) (
         (assert-well-typed rhs)
         (assert-one-typed term)
      ))
      ( (App( (Var( 'gensym-label_s _ )) _ )) () )
      ( (App( (Var( 'label_s _ )) (Var( _ _ )) )) () )
      ( (App( (App( (Var( 'while_s _ )) cond )) body )) (
         (assert-well-typed cond)
         (assert-well-typed body)
         (assert-one-typed term)
      ))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (assert-well-typed t)
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (assert-well-typed t)
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (
         (assert-well-typed cond)
         (assert-well-typed t)
         (assert-well-typed f)
         (assert-one-typed term)
      ))
      ( (App( (App( (Var( 'set_s _ )) lhs )) rhs )) (
         (assert-well-typed rhs)
         (assert-one-typed term)
      ))
      ( (AType _) () )
      ( (App( (Var( 'open_s _ )) rterm )) (
         (assert-well-typed rterm)
         (assert-one-typed term)
      ))
      ( (App( (Var( 'scope_s _ )) rterm )) (
         (assert-well-typed rterm)
         (assert-one-typed term)
      ))
      ( (Lit( l _ )) (assert-one-typed term) )
      ( (Var( l _ )) (assert-one-typed term) )
      ( (Abs( lhs rhs tlt )) (
         (assert-well-typed rhs)
         (assert-one-typed term)
      ))
      ( (App( l r )) (
         (assert-well-typed l)
         (assert-well-typed r)
         (assert-one-typed term)
      ))
      ( (Seq( l r )) (
         (assert-well-typed l)
         (assert-well-typed r)
      ))
      ( (Meta( _ )) () )
      ( _ (
         (print 'Unknown\sTerm\sIn\sAssert\sWell\sTyped\s_s)(print term)(print '\n_s)
         (exit 1_u64)
      ))
   ))
) Nil);

assert-one-typed := λ(: term AST). (: (
   (if (non-zero(typeof term)) () (
      (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s term ))
   ))
) Nil);

with-fields := λ(: tt Type). (: (
   (match (slot( tt 'Fields_s )) (
      ()
      ( (TGround( 'Fields_s _ )) () )
      ( _ (
         (let class (with-only-class tt))
         (let tag (with-only-tag tt))
         (if (&&( (non-zero tag) (non-zero class) )) (
            (let ft (fields-of-tag( tag class )))
            (set tt (and( tt ft )))
         ) ())
      ))
   ))
   tt
) Type);

apply := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt False_u8 blame )))
   tt
) Type);

apply-and-specialize := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt True_u8 blame )))
   tt
) Type);

apply-plural := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (let r (: LEOF List<Type>))
   (match ft (
      ()
      ( (TAnd( t1 t2 )) (
         (set r (+(
            (apply-plural( function-name t1 pt do-specialize blame ))
            (apply-plural( function-name t2 pt do-specialize blame ))
         )))
      ))
      ( (TGround( 'Arrow_s (LCons( frt (LCons( fpt LEOF )) )) )) (
         (if (can-unify( fpt pt )) (
            (set r (cons( ft r )))
         ) ())
      ))
      ( _ () )
   ))
   r
) List<Type>);

reduce-plural := λ(: pts List<Type>). (: (
   (let r (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( try tlt )) (
         (set pts tlt)
         (for-each (tst in tlt) (
            (if (non-zero try) (
               (if (can-unify( (domain try) (domain tst) )) (
                  (set try TAny)
               ) ())
            ) ())
         ))
         (if (non-zero try) (
            (set r (cons( try r )))
         ) ())
      ))
   )))
   (set pts r)
   (set r (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( try tlt )) (
         (set pts tlt)
         (for-each (tst in tlt) (
            (if (non-zero try) (
               (if (can-unify( (domain try) (domain tst) )) (
                  (set try TAny)
               ) ())
            ) ())
         ))
         (if (non-zero try) (
            (set r (cons( try r )))
         ) ())
      ))
   )))
   r
) List<Type>);

apply := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (let r TAny)
   (let rs (apply-plural( function-name ft pt do-specialize blame )))
   (let is-hook (non-zero(slot( ft 'Hook_s ))))
   (if (==( is-hook 0_u64 )) (
      (set rs (reduce-plural rs))
   ) ())
   (if (&&( (==( (.length rs) 0_u64 )) (!=( function-name 'del_s )) )) (
      (print 'Function\sApplication\sYielded\sNo\sMatches\n_s)
      (print function-name)(print '\nWith\sArgument\s:\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (print 'Options:\s_s)(print ft)(print '\n_s)
      (exit 1_u64)
   ) ())
   (if (&&( (>( (.length rs) 1_u64 )) (==( is-hook 0_u64 )) )) (
      (print 'Function\sApplication\sYielded\sAn\sIrreducible\sPlurality\sOf\sMatches\n_s)
      (print function-name)(print '\s:\s_s)(print ft)(print '\n_s)
      (print 'With\sArgument\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (let rs-copy rs)
      (while (non-zero( rs-copy )) (
         (print 'Matched\s_s)
         (match rs-copy (
            ()
            ( (LCons( hd tl )) (
               (print hd)
               (set rs-copy tl)
            ))
         ))
         (print '\n_s)
      ))
      (exit 1_u64)      
   ) ())
   (for-each (sft in rs) (
      (match sft (
         ()
         ( (TGround( 'Arrow_s (LCons( frt (LCons( fpt LEOF )) )) )) (
            (let ctx (unify( fpt pt )))
            (set ctx (normalize ctx))
            (let closed-type (substitute( ctx sft )))
            (set r (guess-representation(substitute( ctx frt ))))
            (if (&&( (==( do-specialize True_u8 )) (is-open sft) )) (
               (if (is-open closed-type) (
                  (print 'Application\sDid\sNot\sClose\sBefore\sSpecialization:\n_s)
                  (print 'Function\s_s)(print function-name)(print '\s:\s_s)(print sft)(print '\n_s)
                  (print 'Argument\s_s)(print pt)(print '\n_s)
                  (print (location-of( blame )))(print '\n_s)
                  (exit 1_u64)
               ) ())
               (try-specialize( function-name sft ctx closed-type ))
            ) ())
         ))
         ( _ (
            (print 'Function\sNot\sSimple\sArrow:\s_s)(print sft)(print '\n_s)
            (exit 1_u64)
         ))
      ))
   ))
   r
) Type);

apply-or-cons-and-specialize := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let r TAny)
   (if (is-arrow ft) (
      (set r (apply( function-name ft pt True_u8 blame )))
   ) (
      (if (&&( (non-zero ft) (non-zero pt) )) (
         (set r (t3( 'Cons_s ft pt )))
      ) ())
   ))
   r
) Type);

try-specialize := λ(: function-name String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (
   (set result-type (normalize result-type))
   (let global-ctx global-type-context)
   (if (is-special( function-name result-type )) () (
      (while (non-zero global-ctx) (match global-ctx (
         ()
         ( TCtxNil (set global-ctx TCtxEOF) )
         ( (TCtxBind( rst k kt t )) (
            (set kt (slot( kt 'Arrow_s )))
            (if (&&( (==( function-name k )) (==( ft kt )) )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (
                     (specialize( function-name ft unify-ctx result-type ))
                  ))
                  ( _ () )
               ))
            ) ())
            (set global-ctx rst)
         ))
      )))
   ))
) Nil);

infer-tctx := λ(: tctx TContext)(: tt List<Type>). (: (
   (match tt (
      ()
      ( LEOF () )
      ( (LCons( p1 rst )) (
         (set tctx (infer-tctx( tctx rst )))
         (set tctx (infer-tctx( tctx p1 )))
      ))
   ))
   tctx
) TContext);

infer-tctx := λ(: tctx TContext)(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set tctx (infer-tctx( tctx lt )))
         (set tctx (infer-tctx( tctx rt )))
      ))
      ( (TVar( tv )) (
         (set tctx (TCtxBind(
            (close tctx)
            tv
            (t1 'Constant_s)
            ASTEOF
         )))
      ))
      ( (TGround( _ ts )) (
         (set tctx (infer-tctx( tctx ts )))
      ))
      ( TAny () )
   ))
   tctx
) TContext);

infer-ctx := λ(: tctx TContext)(: lhs AST). (: (
   (match lhs (
      ()
      ( (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) (
         (set tt (denormalize tt))
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-tctx( tctx tt )))
      ))
      ( (App( ps (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) )) (
         (set tt (denormalize tt))
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-ctx( tctx ps )))
         (set tctx (infer-tctx( tctx tt )))
      ))
      ( ASTNil () )
      ( _ (exit-error( 'Invalid\sLHS_s lhs )) )
   ))
   tctx
) TContext);

implicit-tail := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TGround( 'Cons_s (LCons( tl (LCons( hd LEOF )) )) )) (
         (set tt tl)
      ))
      ( _ () )
   ))
   tt
) Type);

typeof-var := λ(: sloc AST)(: tctx TContext)(: vname String). (: (
   (let found (typeof-var-raw( sloc tctx vname )))
   (if (non-zero found) () (
      (exit-error( 'Unknown\sReferenced\sVariable_s sloc ))
   ))
   found
) Type);

typeof-var-raw := λ(: sloc AST)(: tctx TContext)(: vname String). (: (
   (let found (find-alias-type vname))
   (while (non-zero tctx) (match tctx (
      ()
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k vt _ )) (
         (if (==( k vname )) (
            (if (non-zero found) (
               (if (is-arrow vt) (
                  (set found (and( found vt )))
               ) (
                  (set found vt)
               ))
            ) (
               (set found vt)
            ))
            (if (is-arrow vt) (
               (set tctx rst)
            ) (
               (set tctx TCtxEOF)
            ))
         ) (
            (set tctx rst)
         ))
      ))
   )))
   found
) Type);

is-reg8 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'AL_s (set r 1_u64))
      ( 'BL_s (set r 1_u64))
      ( 'CL_s (set r 1_u64))
      ( 'DL_s (set r 1_u64))
      ( 'SIL_s (set r 1_u64))
      ( 'DIL_s (set r 1_u64))
      ( 'BPL_s (set r 1_u64))
      ( 'SPL_s (set r 1_u64))
      ( 'R8B_s (set r 1_u64))
      ( 'R9B_s (set r 1_u64))
      ( 'R10B_s (set r 1_u64))
      ( 'R11B_s (set r 1_u64))
      ( 'R12B_s (set r 1_u64))
      ( 'R13B_s (set r 1_u64))
      ( 'R14B_s (set r 1_u64))
      ( 'R15B_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg16 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'AX_s (set r 1_u64))
      ( 'BX_s (set r 1_u64))
      ( 'CX_s (set r 1_u64))
      ( 'DX_s (set r 1_u64))
      ( 'SI_s (set r 1_u64))
      ( 'DI_s (set r 1_u64))
      ( 'BP_s (set r 1_u64))
      ( 'SP_s (set r 1_u64))
      ( 'R8W_s (set r 1_u64))
      ( 'R9W_s (set r 1_u64))
      ( 'R10W_s (set r 1_u64))
      ( 'R11W_s (set r 1_u64))
      ( 'R12W_s (set r 1_u64))
      ( 'R13W_s (set r 1_u64))
      ( 'R14W_s (set r 1_u64))
      ( 'R15W_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg32 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'EAX_s (set r 1_u64))
      ( 'EBX_s (set r 1_u64))
      ( 'ECX_s (set r 1_u64))
      ( 'EDX_s (set r 1_u64))
      ( 'ESI_s (set r 1_u64))
      ( 'EDI_s (set r 1_u64))
      ( 'EBP_s (set r 1_u64))
      ( 'ESP_s (set r 1_u64))
      ( 'R8D_s (set r 1_u64))
      ( 'R9D_s (set r 1_u64))
      ( 'R10D_s (set r 1_u64))
      ( 'R11D_s (set r 1_u64))
      ( 'R12D_s (set r 1_u64))
      ( 'R13D_s (set r 1_u64))
      ( 'R14D_s (set r 1_u64))
      ( 'R15D_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg64 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'RAX_s (set r 1_u64))
      ( 'RBX_s (set r 1_u64))
      ( 'RCX_s (set r 1_u64))
      ( 'RDX_s (set r 1_u64))
      ( 'RSI_s (set r 1_u64))
      ( 'RDI_s (set r 1_u64))
      ( 'RBP_s (set r 1_u64))
      ( 'RSP_s (set r 1_u64))
      ( 'R8_s (set r 1_u64))
      ( 'R9_s (set r 1_u64))
      ( 'R10_s (set r 1_u64))
      ( 'R11_s (set r 1_u64))
      ( 'R12_s (set r 1_u64))
      ( 'R13_s (set r 1_u64))
      ( 'R14_s (set r 1_u64))
      ( 'R15_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);

