
# global Tag -> Class map, mutable
tag-to-class-index := (: TConEOF TypeConstructorList);

# global Tag -> Fields map, mutable
tag-to-fields-index := (: TConEOF TypeConstructorList);

# global Tag -> IsFragment? map, mutable
tag-is-fragment-index := (: SLEOF StringList);

index-tag-is-fragment := λ(: tag String). (: (
   (set tag-is-fragment-index (SLSeq(
      (close tag-is-fragment-index) tag
   )))
) Nil);

is-fragment := λ(: tag String). (: (tail(
   (let index tag-is-fragment-index)
   (let rt 0_u64)
   (while (non-zero index) (match index (
      ()
      ( (SLSeq( rst itag )) (
         (if (==( tag itag )) (tail(
            (set rt 1_u64)
            (set index SLEOF)
         )) (set index rst))
      ))
   )))
   rt
)) U64);

is-fragment := λ(: tt Type). (: (tail(
   (let r (is-fragment(tag-of tt)))
   r
)) U64);

tag-of := λ(: tt Type). (: (tail(
   (let tag '_s)
   (match tt (
      ()
      ( (TAnd( lt rt )) (tail(
         (let ltag (tag-of lt))
         (if (non-zero ltag) (set tag ltag) ())
         (let rtag (tag-of rt))
         (if (non-zero rtag) (set tag rtag) ())
      )))
      ( (TGround( tg _ )) (set tag tg) )
      ( _ () )
   ))
   tag
)) String);

index-class-of-tag := λ(: tag String)(: class Type). (: (
   (set tag-to-class-index (TConSeq(
      (close tag-to-class-index) tag class
   )))
) Nil);

class-of-tag := λ(: tag String). (: (tail(
   (let index tag-to-class-index)
   (let rt TAny)
   (while (non-zero index) (match index (
      ()
      ( (TConSeq( rst itag iclass )) (
         (if (==( tag itag )) (tail(
            (set rt iclass)
            (set index TConEOF)
         )) (set index rst))
      ))
   )))
   rt
)) Type);

is-class := λ(: tag String). (: (tail(
   (let index tag-to-class-index)
   (let rt 0_u64)
   (while (non-zero index) (match index (
      ()
      ( (TConSeq( rst itag (TGround( ctag _ )) )) (
         (if (==( tag ctag )) (tail(
            (set rt 1_u64)
            (set index TConEOF)
         )) (set index rst))
      ))
   )))
   rt
)) U64);

index-fields-of-tag := λ(: tag String)(: fields Type). (: (
   (set tag-to-fields-index (TConSeq(
      (close tag-to-fields-index) tag fields
   )))
) Nil);

fields-of-tag := λ(: tag String). (: (tail(
   (let index tag-to-fields-index)
   (let rt TAny)
   (while (non-zero index) (match index (
      ()
      ( (TConSeq( rst itag ifields )) (
         (if (==( tag itag )) (tail(
            (set rt ifields)
            (set index TConEOF)
         )) (set index rst))
      ))
   )))
   rt
)) Type);

slot := λ(: tt Type)(: sl String). (: (tail(
   (let rt TAny)
   (match tt (
      ()
      ( (TGround( bt _ )) (
         (if (==( bt sl )) (set rt tt) ())
      ))
      ( (TAnd( ltt rtt )) (tail(
         (let lt2 (slot( ltt sl )))
         (if (non-zero lt2) (
            (set rt lt2)
         ) (tail(
            (let rt2 (slot( rtt sl )))
            (set rt rt2)
         )))
      )))
      ( _ () )
   ))
   rt
)) Type);

domain := λ(: tt Type). (: (tail(
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p1) )
      ( _ () )
   ))
   r
)) Type);

range := λ(: tt Type). (: (tail(
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p2) )
      ( _ () )
   ))
   r
)) Type);

is-open := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar _) (set r 1_u64) )
      ( (TAnd( lt rt )) (tail(
         (if (is-open lt) (set r 1_u64) ())
         (if (is-open rt) (set r 1_u64) ())
      )))
      ( (TGround( _ pars )) (
         (while (non-zero pars) (match pars (
            ()
            ( (TypeSeq( rst p1 )) (tail(
               (if (is-open p1) (set r 1_u64) ())
               (set pars rst)
            )))
         )))
      ))
   ))
   r
)) U64);

is-arrow := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s _ )) (set r 1_u64) )
      ( _ () )
   ))
   r
)) U64);

t3 := λ(: tag String)(: p1 Type)(: p2 Type). (: (tail(
   (let tt (TGround(
      tag
      (close(TypeSeq( (close(TypeSeq( (close TypeEOF) p1 ))) p2 )))
   )))
   tt
)) Type);

t2 := λ(: tag String)(: p1 Type). (: (tail(
   (let tt (TGround(
      tag
      (close(TypeSeq( (close TypeEOF) p1 )))
   )))
   tt
)) Type);

t1 := λ(: tag String). (: (tail(
   (let tt (TGround(
      tag
      (close TypeEOF)
   )))
   tt
)) Type);

tsized :=  λ(: tag String). (: (tail(
   (let tt (t2( 'Sized_s (t1 tag) )))
   tt
)) Type);

substitute := λ(: tctx TContext)(: tt TypeList). (: (tail(
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst par )) (
         (set tt (TypeSeq(
            (close(substitute( tctx rst )))
            (substitute( tctx par ))
         )))
      ))
   ))
   tt
)) TypeList);

substitute := λ(: tctx TContext)(: tt Type). (: (tail(
   (match tt (
      ()
      ( (TVar v) (
         (while (non-zero tctx) (match tctx (
            ()
            ( (TCtxBind( rst tk tv _ )) (
               (if (==( tk v )) (tail(
                  (set tt tv)
                  (set tctx TCtxEOF)
               )) (set tctx rst))
            ))
         )))
      ))
      ( (TGround( tag pars )) (
         (set tt (TGround(
            tag
            (close(substitute( tctx pars )))
         )))
      ))
      ( (TAnd( lt rt )) (
         (set tt (TAnd(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( _ () )
   ))
   tt
)) Type);

union := λ(: lctx TContext)(: rctx TContext). (: (tail(
   (match rctx (
      ()
      ( (TCtxBind( rst k v t )) (tail(
         (set lctx (union( lctx rst )))
         (set lctx (TCtxBind( (close lctx) k v t )))
      )))
      ( _ () )
   ))
   lctx
)) TContext);
