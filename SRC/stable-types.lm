
# global Tag -> Class map, mutable
tag-to-class-index := (: BTreeEqEOF BTreeEq<String,Type>);

# global Class -> Yes/No map, mutable
class-to-yes-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Tag -> Fields map, mutable
tag-to-fields-index := (: BTreeEqEOF BTreeEq<String,Tuple<Type,Type>>);

# global Tag -> IsFragment? map, mutable
tag-is-fragment-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Class -> Size map, mutable
class-to-size-index := (: BTreeEqEOF BTreeEq<String,U64>);

# global Class -> Tag map, mutable
class-to-only-child := (: BTreeEqEOF BTreeEq<String,String>);

# global Tag -> Index map, mutable
tag-to-index-index := (: BTreeEqEOF BTreeEq<String,U64>);
unknown-index-of-tag := 99999_u64;

lone-index := (: BTreeEqEOF BTreeEq<String,U64>);

# Global Tag -> Type map, mutable
type-constructors-index := (: BTreeEqEOF BTreeEq<String,Type>);

# Global Tag -> (Type,Type) base-type to fields-type map, mutable
type-complex-fields-index := (: BTreeEqEOF BTreeEq<String,Tuple<Type,Type>>);

# has typechecking finished? boolean, mutable
types-have-changed := True_u8;

global-symbol-registry := (: BTreeEqEOF BTreeEq<Tuple<String,Type>,U64>);

# Global (type-base-name: String, parameter: String) -> Yes/No, mutable
parameter-is-flat-index := (: BTreeEqEOF BTreeEq<Tuple<Tuple<String,U64>,U64>,U64>);

mark-parameter-flat := λ(: type-base-name String)(: type-arity U64)(: parameter U64). (: (
   (.bind( (as (& parameter-is-flat-index) BTreeEq<Tuple<Tuple<String,U64>,U64>,U64>[])
           (Tuple( (Tuple( type-base-name type-arity )) parameter )) 1_u64 ))
) Nil);

is-parameter-flat := λ(: type-base-name String)(: type-arity U64)(: parameter U64). (: (
   (let r (.lookup( parameter-is-flat-index (Tuple( (Tuple( type-base-name type-arity )) parameter )) 0_u64 )))
   r
) U64);

has-only-child := λ(: class String)(: tag String). (: (
   (.bind( (as (& class-to-only-child) BTreeEq<String,String>[]) class tag ))
) Nil);

get-only-child := λ(: class String). (: (
   (let r (.lookup( class-to-only-child class '_s )))
   r
) String);

mark-global-as-seen := λ(: name String)(: tt Type). (: (
   (if (global-is-seen( name tt )) (
      (print 'Duplicate\sGlobal\sSymbol\s_s)(print name)(print '\s:\s_s)(print tt)(print '\n_s)
      (exit 1_u64)
   ) (
      (.bind( (as (& global-symbol-registry) BTreeEq<Tuple<String,Type>,U64>[]) (Tuple( name tt )) 1_u64 ))
   ))
) Nil);

global-is-seen := λ(: name String)(: tt Type). (: (
   (let r (.lookup( global-symbol-registry (Tuple( name tt )) 0_u64 )))
   r
) U64);

is-special-index := (: BTreeEqEOF BTreeEq<Tuple<String,Type>,U64>);

mark-as-special := λ(: name String)(: tt Type). (: (
   (.bind( (as (& is-special-index) BTreeEq<Tuple<String,Type>,U64>[]) (Tuple( name tt )) 1_u64 ))
) Nil);

is-special := λ(: name String)(: tt Type). (: (
   (let r (.lookup( is-special-index (Tuple( name tt )) 0_u64 )))
   r
) U64);

index-of-tag := λ(: tag String). (: (
   (let r (.lookup( tag-to-index-index tag unknown-index-of-tag )))
   r
) U64);

index-index-of-tag := λ(: tag String)(: index U64). (: (
   (.bind( (as (& tag-to-index-index) BTreeEq<String,U64>[]) tag index ))
) Nil);

index-lone-tag := λ(: tag String). (: (
   (.bind( (as (& lone-index) BTreeEq<String,U64>[]) tag 1_u64 ))
) Nil);

is-lone-tag := λ(: tag String). (: (
   (.lookup( lone-index tag 0_u64 ))
) U64);

index-size-of-class := λ(: class String)(: size U64). (: (
   (.bind( (as (& class-to-size-index) BTreeEq<String,U64>[]) class size ))
) Nil);

size-of-class := λ(: class String). (: (
   (.lookup( class-to-size-index class 0_u64 ))
) U64);

index-tag-is-fragment := λ(: tag String). (: (
   (.bind( (as (& tag-is-fragment-index) BTreeEq<String,U64>[]) tag 1_u64 ))
) Nil);

is-fragment := λ(: tag String). (: (
   (.lookup( tag-is-fragment-index tag 0_u64 ))
) U64);

is-fragment := λ(: tt Type). (: (
   (is-fragment(tag-of tt))
) U64);

tag-of := λ(: tt Type). (: (
   (let tag '_s)
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let ltag (tag-of lt))
         (if (non-zero ltag) (set tag ltag) ())
         (let rtag (tag-of rt))
         (if (non-zero rtag) (set tag rtag) ())
      ))
      ( (TGround( tg _ )) (set tag tg) )
      ( _ () )
   ))
   tag
) String);

index-class-of-tag := λ(: tag String)(: class Type). (: (
   (.bind( (as (& tag-to-class-index) BTreeEq<String,Type>[]) tag class ))
   (match class (
      ()
      ( (TGround( cls _ )) (
         (.bind( (as (& class-to-yes-index) BTreeEq<String,U64>[]) cls 1_u64 ))
      ))
      ( _ (
         (print 'Unexpected\sClass\sIn\sindex-class-of-tag:\s_s)(print class)(print '\n_s)
         (exit 1_u64)
      ))
   ))
) Nil);

class-of-tag := λ(: tag String). (: (
   (let r (.lookup( tag-to-class-index tag TAny )))
   r
) Type);

is-class := λ(: tag String). (: (
   (let r (.lookup( class-to-yes-index tag 0_u64 )))
   r
) U64);

index-fields-of-tag := λ(: tag String)(: fields-params Type)(: fields-rhs Type). (: (
   (.bind( (as (& tag-to-fields-index) BTreeEq<String,Tuple<Type,Type>>[]) tag (Tuple( fields-params fields-rhs )) ))
) Nil);

fields-of-tag := λ(: tag String). (: (
   (let r (.lookup( tag-to-fields-index tag (Tuple( TAny TAny )) )))
   r
) Tuple<Type,Type>);

domain := λ(: tt Type). (: (
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p1) )
      ( _ () )
   ))
   r
) Type);

range := λ(: tt Type). (: (
   (let r TAny)
   (match (slot( tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (set r p2) )
      ( _ () )
   ))
   r
) Type);

is-open := λ(: tt Type). (: (
   (let r 0_u64)
   (match tt (
      ()
      ( TAny (set r 1_u64) )
      ( (TVar _) (set r 1_u64) )
      ( (TAnd( lt rt )) (
         (if (is-open lt) (set r 1_u64) ())
         (if (is-open rt) (set r 1_u64) ())
      ))
      ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF _ )) _ )) )) () )
      ( (TGround( 'Field_s (TypeSeq( (TypeSeq( TypeEOF base-type )) _ )) )) (
         (set r (is-open base-type))
      ))
      ( (TGround( _ pars )) (
         (while (non-zero pars) (match pars (
            ()
            ( (TypeSeq( rst p1 )) (
               (if (is-open p1) (set r 1_u64) ())
               (set pars rst)
            ))
         )))
      ))
   ))
   r
) U64);

tsized :=  λ(: tag String). (: (
   (let tt (t2( 'Sized_s (t1 tag) )))
   tt
) Type);

substitute := λ(: tctx TContext)(: tt TypeList). (: (
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst par )) (
         (set tt (TypeSeq(
            (close(substitute( tctx rst )))
            (substitute( tctx par ))
         )))
      ))
   ))
   tt
) TypeList);

substitute := λ(: tctx TContext)(: tt Type). (: (
   (match tt (
      ()
      ( (TVar v) (
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv _ )) (
               (if (==( tk v )) (
                  (set tt tv)
                  (set tctx TCtxEOF)
               ) (set tctx rst))
            ))
         )))
      ))
      ( (TGround( tag pars )) (
         (set tt (TGround(
            tag
            (close(substitute( tctx pars )))
         )))
      ))
      ( (TAnd( lt rt )) (
         (set tt (TAnd(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( _ () )
   ))
   tt
) Type);

substitute := λ(: tctx Context)(: tt TypeList). (: (
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst par )) (
         (set tt (TypeSeq(
            (close(substitute( tctx rst )))
            (substitute( tctx par ))
         )))
      ))
   ))
   tt
) TypeList);

substitute := λ(: tctx Context)(: tt Type). (: (
   (match tt (
      ()
      ( (TVar v) (
         (while (non-zero tctx) (match tctx (
            ()
            ( CtxNil (set tctx CtxEOF) )
            ( (CtxBind( rst tk (Lit( tv _ )) )) (
               (if (==( tk v )) (
                  (set tt (parse-type tv))
                  (set tctx CtxEOF)
               ) (set tctx rst))
            ))
            ( (CtxBind( rst tk (Var( tv _ )) )) (
               (if (==( tk v )) (
                  (set tt (parse-type tv))
                  (set tctx CtxEOF)
               ) (set tctx rst))
            ))
            ( (CtxBind( rst tk tv )) (
               (set tctx rst)
            ))
         )))
      ))
      ( (TGround( tag pars )) (
         (set tt (TGround(
            tag
            (close(substitute( tctx pars )))
         )))
      ))
      ( (TAnd( lt rt )) (
         (set tt (TAnd(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( _ () )
   ))
   tt
) Type);

substitute-lhs := λ(: tctx TContext)(: t AST). (: (
   (match t (
      ()
      ( (App( ps (App( (Lit( ':_s ctk )) (App( (Var( v vtk )) (AType vt) )) )) )) (
         (set t (App(
            (close(substitute-lhs( tctx ps )))
            (close(App( (close(Lit( ':_s (unique ctk) ))) (close(App(
               (close(Var( v (unique vtk) )))
               (close(AType( (substitute( tctx vt )) )))
            ))) )))
         )))
      ))
      ( (App( (Lit( ':_s ctk )) (App( (Var( v vtk )) (AType vt) )) )) (
         (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
            (close(Var( v (unique vtk) )))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
      ))
      ( (App( ps (Var( v vtk )) )) (
         (set t (App(
            (close(substitute-lhs( tctx ps )))
            (close(Var( v (unique vtk) )))
         )))
      ))
      ( (Var( v vtk )) (set t (Var( v (unique vtk) ))) )
      ( ASTNil () )
      ( _ (exit-error( 'Unexpected\sSubstitute\sLHS_s t )) )
   ))
   t
) AST);

substitute := λ(: tctx TContext)(: t AST). (: (
   (match t (
      ()
      ( ASTEOF () )
      ( ASTNil () )
      ( (App( (Lit( ':_s ctk )) (App( (Lit( v vtk )) (AType vt) )) )) (
         (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
            (close(Lit( v (unique vtk) )))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv ta )) (
               (if (==( tk v )) (
                  (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
                     (close(substitute( tctx ta )))
                     (close(AType( (substitute( tctx vt )) )))
                  ))) )))
                  (set tctx TCtxEOF)
               ) (set tctx rst))
            ))
         )))
      ))
      ( (App( (Lit( ':_s ctk )) (App( (Var( v vtk )) (AType vt) )) )) (
         (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
            (close(Var( v (unique vtk) )))
            (close(AType( (substitute( tctx vt )) )))
         ))) )))
         (while (non-zero tctx) (match tctx (
            ()
            ( TCtxNil (set tctx TCtxEOF) )
            ( (TCtxBind( rst tk tv ta )) (
               (if (==( tk v )) (
                  (set t (App( (close(Lit( ':_s (unique ctk) ))) (close(App(
                     (close(substitute( tctx ta )))
                     (close(AType( (substitute( tctx vt )) )))
                  ))) )))
                  (set tctx TCtxEOF)
               ) (set tctx rst))
            ))
         )))
      ))
      ( (Lit( v vtk )) (set t (Lit( v (unique vtk) ))) )
      ( (Var( v vtk )) (set t (Var( v (unique vtk) ))) )
      ( (Abs( lhs rhs tt )) (
         (set t (Abs(
            (close(substitute-lhs( tctx lhs )))
            (close(substitute( tctx rhs )))
            (substitute( tctx tt ))
         )))
      ))
      ( (AType( tt )) (
         (set t (AType( (substitute( tctx tt )) )))
      ))
      ( (App( lt rt )) (
         (set t (App(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Seq( lt rt )) (
         (set t (Seq(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Glb( k rt )) (
         (set t (Glb(
            (unique k)
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Typedef( lt rt )) (
         (set t (Typedef(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
      ( (Frg( k lt tt )) (
         (set t (Frg(
            (unique k)
            (close(substitute( tctx lt )))
            (substitute( tctx tt ))
         )))
      ))
      ( _ (exit-error( 'Unexpected\sSubstitution\sTerm:_s t )) )
   ))
   t
) AST);

substitute := λ(: tctx StringSList)(: t S). (: (
   (match t (
      ()
      ( SNil (set t SNil) )
      ( (SAtom a) (
         (while (non-zero tctx) (match tctx (
            ()
            ( (SSLSeq( rst k v )) (
               (if (==( a k )) (
                  (set t v)
               ) ())
               (set tctx rst)
            )))
         ))
      ))
      ( (SCons( lt rt )) (
         (set t (SCons(
            (close(substitute( tctx lt )))
            (close(substitute( tctx rt )))
         )))
      ))
   ))
   (let rt t)
   rt
) S);

union := λ(: lctx TContext)(: rctx TContext). (: (
   (match rctx (
      ()
      ( TCtxNil (set rctx TCtxEOF) )
      ( TCtxEOF () )
      ( (TCtxBind( rst k v t )) (
         (set lctx (union( lctx rst )))
         (set lctx (TCtxBind( (close lctx) k v t )))
      ))
   ))
   lctx
) TContext);

and := λ(: lctx TContext)(: rctx TContext). (: (
   (match (Tuple( lctx rctx )) (
      ()
      ( (Tuple( TCtxEOF _ )) (set lctx TCtxEOF) )
      ( (Tuple( _ TCtxEOF )) (set lctx TCtxEOF) )
      ( _ (
         (set lctx (union( lctx rctx )))
      ))
   ))
   lctx
) TContext);

with-tag := λ(: tt Type). (: (
   (let cls-tt (with-only-class tt))
   (if (non-zero cls-tt) (
      (match cls-tt (
         ()
         ( (TGround( cls _ )) (
            (let tag (get-only-child cls))
            (if (head-string tag) (
               (set tt (and( tt (t2( 'Tag_s (t1 tag) )) )))
            ) ())
         ))
         ( _ () )
      ))
   ) ())
   tt
) Type);

without-tag := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt1 (without-tag lt))
         (let rt1 (without-tag rt))
         (match (Tuple( lt1 rt1 )) (
            ()
            ( (Tuple( TAny rt2 )) (set tt rt2) )
            ( (Tuple( lt2 TAny )) (set tt lt2) )
            ( (Tuple( lt2 rt2 )) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ))
         ))
      ))
      ( (TGround( 'Constructor_s _ )) (set tt TAny) )
      ( (TGround( 'Tag_s _ )) (set tt TAny) )
      ( (TGround( 'Fields_s _ )) (set tt TAny) )
      ( (TGround( 'FieldsSized_s _ )) (set tt TAny) )
      ( _ () )
   ))
   tt
) Type);

without-open := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt1 (without-open lt))
         (let rt1 (without-open rt))
         (match (Tuple( lt1 rt1 )) (
            ()
            ( (Tuple( TAny rt2 )) (set tt rt2) )
            ( (Tuple( lt2 TAny )) (set tt lt2) )
            ( (Tuple( lt2 rt2 )) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ))
         ))
      ))
      ( _ (if (is-open tt) (set tt TAny) ()))
   ))
   tt
) Type);

without-tag := λ(: tt TypeList). (: (
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq( (close(without-tag rst)) (without-tag p1) )))
      ))
      ( TypeEOF () )
   ))
   tt
) TypeList);

with-only-tag := λ(: tt Type). (: (
   (let rt TAny)
   (match tt (
      ()
      ( (TAnd( lt1 rt1 )) (
         (let lc (with-only-tag lt1))
         (if (non-zero lc) (set rt lc) (
            (let rc (with-only-tag rt1))
            (if (non-zero rc) (set rt rc) ())
         ))
      ))
      ( (TGround( 'Tag_s _ )) (set rt tt) )
      ( _ () )
   ))
   rt
) Type);

with-only-class := λ(: tt Type). (: (
   (let rt TAny)
   (match tt (
      ()
      ( (TAnd( lt1 rt1 )) (
         (let lc (with-only-class lt1))
         (if (non-zero lc) (set rt lc) ())
         (let rc (with-only-class rt1))
         (if (non-zero rc) (set rt rc) ())
      ))
      ( (TGround( tag _ )) (
         (if (is-class tag) (
            (if (not(is-fragment tag)) (
               (set rt tt)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   rt
) Type);

without-representation := λ(: tt TypeList). (: (
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-representation rst))
            (without-representation p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
) TypeList);

without-representation := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt2 (without-representation lt))
         (let rt2 (without-representation rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      ))
      ( (TGround( 'Constant_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Literal_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'StackVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'LocalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'GlobalVariable_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg8_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg16_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg32_s TypeEOF )) (set tt TAny) )
      ( (TGround( 'Reg64_s TypeEOF )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-representation ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
) Type);

without-size := λ(: tt TypeList). (: (
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-size rst))
            (without-size p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
) TypeList);

without-size := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt2 (without-size lt))
         (let rt2 (without-size rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      ))
      ( (TGround( 'Sized_s sz )) (set tt TAny) )
      ( (TGround( 'FieldsSized_s sz )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
) Type);

without-size-unless-class := λ(: tt TypeList). (: (
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(without-size-unless-class rst))
            (without-size-unless-class p1)
         )))
      ))
      ( TypeEOF () )
   ))
   tt
) TypeList);

without-size-unless-class := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt2 (without-size-unless-class-inner lt))
         (let rt2 (without-size-unless-class-inner rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      ))
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size-unless-class ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
) Type);

without-size-unless-class-inner := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt2 (without-size-unless-class-inner lt))
         (let rt2 (without-size-unless-class-inner rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set tt (TAnd( (close lt2) (close rt2) )))
            ) (
               (set tt lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set tt rt2)
            ) (
               (set tt TAny)
            ))
         ))
      ))
      ( (TGround( 'FieldsSized_s _ )) (set tt TAny) )
      ( (TGround( 'Sized_s _ )) (set tt TAny) )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(without-size-unless-class ps)) )))
      ))
      ( TAny () )
      ( (TVar _) () )
   ))
   tt
) Type);

normalize := λ(: tt Type). (: (
   (let rt tt)
   (set rt (without-representation rt))
   (set rt (without-tag rt))
   # Sized can serve as a datatype if nothing else is available
   (set rt (without-size-unless-class rt))
   rt
) Type);

== := λ(: lt Type)(: rt Type). (: (
   (let r 0_u64)
   (match (Tuple( lt rt )) (
      ()
      ( (Tuple( TAny TAny )) (set r 1_u64) )
      ( (Tuple( (TVar lv) (TVar rv) )) (set r (==( lv rv ))) )
      ( (Tuple( (TAnd( llt rlt )) (TAnd( lrt rrt )) )) (
         (if (==( llt lrt )) (
            (if (==( rlt rrt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (Tuple( (TGround( ln lps )) (TGround( rn rps )) )) (
         (if (==( ln rn )) (
            (if (==( lps rps )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
) U64);

== := λ(: lt TypeList)(: rt TypeList). (: (
   (let r 0_u64)
   (match (Tuple( lt rt )) (
      ()
      ( (Tuple( TypeEOF TypeEOF )) (set r 1_u64) )
      ( (Tuple( (TypeSeq( ltr lt1 )) (TypeSeq( rtr rt1 )) )) (
         (if (==( lt1 rt1 )) (
            (if (==( ltr rtr )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
) U64);

can-unify := λ(: fpt TypeList)(: pt TypeList). (: (
   (let r 0_u64)
   (match (Tuple( fpt pt )) (
      ()
      ( (Tuple( TypeEOF TypeEOF )) (set r 1_u64) )
      ( (Tuple( (TypeSeq( lpr lp1 )) (TypeSeq( rpr rp1 )) )) (
         (if (can-unify( lp1 rp1 )) (
            (if (can-unify( lpr rpr )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
) U64);

can-unify := λ(: fpt Type)(: pt Type). (: (
   (let r 0_u64)
   (match (Tuple( fpt pt )) (
      ()
      ( (Tuple( TAny _ )) (set r 1_u64) )
      ( (Tuple( (TGround( 'Meta_s (TypeSeq( TypeEOF _ )) )) _ )) (set r 1_u64) )
      ( (Tuple( (TVar( ltv )) rt )) (set r 1_u64) )
      ( (Tuple( (TAnd( lt1 lt2 )) rt )) (
         (if (can-unify( lt1 rt )) (
            (if (can-unify( lt2 rt )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( (Tuple( lt (TAnd( rt1 rt2 )) )) (
         (if (can-unify( lt rt1 )) (set r 1_u64) ())
         (if (can-unify( lt rt2 )) (set r 1_u64) ())
      ))

      # Varargs
      ( (Tuple(
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF lpr ))
            (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         )) ))
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF rpr )) rp1 )) ))
      )) (
         (if (can-unify( lp1 rp1 )) (
            (set r (can-unify( fpt rpr )))
         ) (
            (set r (can-unify( lpr pt )))
         ))
      ))
      ( (Tuple(
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF lpr ))
            (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         )) ))
         rp1
      )) (
         (if (can-unify( lp1 rp1 )) (
            (set r (can-unify( lpr (t1 'Nil_s) )))
         ) (
            (set r (can-unify( lpr rp1 )))
         ))
      ))
      ( (Tuple(
         (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF rpr )) rp1 )) ))
      )) (
         (if (can-unify( lp1 rp1 )) (
            (set r (can-unify( fpt rpr )))
         ) ())
      ))
      ( (Tuple(
         (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         (TGround( 'Nil_s TypeEOF ))
      )) (
         (set r 1_u64)
      ))
      ( (Tuple(
         (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         rp1
      )) (
         (set r (can-unify( lp1 rp1 )))
      ))

      ( (Tuple( (TGround( 'GT_s (TypeSeq( TypeEOF (TGround( lbase TypeEOF )) )) )) (TGround( rbase TypeEOF )) )) (
         (if (>( (to-i64 rbase) (to-i64 lbase) )) (
            (set r 1_u64)
         ) ())
      ))
      ( (Tuple( (TGround( ltn lps )) (TGround( rtn rps )) )) (
         (if (==( ltn rtn )) (
            (if (can-unify( lps rps )) (
               (set r 1_u64)
            ) ())
         ) ())
      ))
      ( _ () )
   ))
   r
) U64);

to-string := λ(: tt Type). (: (
   (let r (to-string-impl tt))
   (clone-rope r)
) String);

to-string := λ(: tt TypeList). (: (
   (let r SNil)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( TypeEOF p1 )) (set r (to-string-impl p1)) )
      ( (TypeSeq( rst p1 )) (
         (set r (SCons(
            (close(to-string rst))
            (close(SCons(
               (close(SAtom ',_s))
               (close(to-string-impl p1))
            )))
         )))
      ))
   ))
   r
) S);

to-string-impl := λ(: tt Type). (: (
   (let r SNil)
   (match tt (
      ()
      ( TAny (set r (SAtom '?_s)) )
      ( (TVar v) (set r (SAtom v)) )
      ( (TAnd( lt rt )) (
         (let ls (to-string-impl lt))
         (let rs (to-string-impl rt))
         (set r (SCons(
            (close ls)
            (close(SCons(
               (close(SAtom '+_s))
               (close rs)
            )))
         )))
      ))
      ( (TGround( tag TypeEOF )) (
        (set r (SAtom tag))
      ))
      ( (TGround( '..._s (TypeSeq( TypeEOF p1 )) )) (
        (set r (SCons( (close r) (close(to-string-impl p1)) )))
        (set r (SCons( (close r) (close(SAtom '..._s)) )))
      ))
      ( (TGround( tag ps )) (
        (set r (SAtom tag))
        (set r (SCons( (close r) (close(SAtom '<_s)) )))
        (set r (SCons( (close r) (close(to-string ps)) )))
        (set r (SCons( (close r) (close(SAtom '>_s)) )))
      ))
   ))
   r
) S);

type-of-s := λ(: compound AST). (: (
   (let r TAny)
   (match compound (
      ()
      ( (Lit( tt _ )) (
         (let nt (parse-type tt))
         (set r nt)
      ))
      ( (Var( tt _ )) (
         (let nt (parse-type tt))
         (set r nt)
      ))
      ( (App( (App( lt (Lit( ',_s _ )) )) rt )) (
         (let ltt (type-of-s lt))
         (let rtt (type-of-s rt))
         (set r (t3( 'Cons_s ltt rtt )))
      ))
      ( _ (exit-error( 'Malformed\sType\sDefinition_s compound )))
   ))
   r
) Type);

normalize := λ(: tctx TContext). (: (
   (match tctx (
      ()
      ( TCtxEOF () )
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k kt t )) (
         (set rst (normalize rst))
         (set tctx (TCtxBind(
            (close rst)
            k (normalize kt) t
         )))
      ))
   ))
   tctx
) TContext);

with-only-representation := λ(: tt TypeList). (: (
   (let rt tt)
   (match tt (
      ()
      ( (TypeSeq( rst p1 )) (
         (set rt (TypeSeq(
            (close(with-only-representation rst))
            (with-only-representation p1)
         )))
      ))
      ( TypeEOF () )
   ))
   rt
) TypeList);

with-only-representation := λ(: tt Type). (: (
   (let return tt)
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (let lt2 (with-only-representation lt))
         (let rt2 (with-only-representation rt))
         (if (non-zero lt2) (
            (if (non-zero rt2) (
               (set return (TAnd( (close lt2) (close rt2) )))
            ) (
               (set return lt2)
            ))
         ) (
            (if (non-zero rt2) (
               (set return rt2)
            ) (
               (set return TAny)
            ))
         ))
      ))
      ( (TGround( 'Constant_s TypeEOF )) () )
      ( (TGround( 'Literal_s TypeEOF )) () )
      ( (TGround( 'StackVariable_s TypeEOF )) () )
      ( (TGround( 'LocalVariable_s TypeEOF )) () )
      ( (TGround( 'GlobalVariable_s TypeEOF )) () )
      ( (TGround( 'Reg8_s TypeEOF )) () )
      ( (TGround( 'Reg16_s TypeEOF )) () )
      ( (TGround( 'Reg32_s TypeEOF )) () )
      ( (TGround( 'Reg64_s TypeEOF )) () )
      ( (TGround( tag ps )) (set return TAny) )
      ( TAny () )
      ( (TVar _) (set return TAny) )
   ))
   return
) Type);

unify := λ(: fpt Type)(: pt Type). (: (
   (let ctx TCtxEOF)
   (if (can-unify( fpt pt )) (
      (set ctx (unify-inner( fpt pt )))
   ) ())
   ctx
) TContext);

unify-inner := λ(: fpt Type)(: pt Type). (: (
   (let ctx TCtxEOF)
   (match (Tuple( fpt pt )) (
      ()
      ( (Tuple( TAny _ )) (
         (set ctx TCtxNil)
      ))
      ( (Tuple( (TVar( ltv )) (TGround( tg TypeEOF )) )) (
         (set ctx (TCtxBind(
            (close TCtxEOF)
            ltv
            pt
            (Lit( tg (token::new tg) ))
         )))
      ))
      ( (Tuple( (TGround( 'Meta_s (TypeSeq( TypeEOF mt )) )) _ )) (
         (set ctx TCtxNil)
      ))
      ( (Tuple( (TVar( ltv )) rt )) (
         (set ctx (TCtxBind(
            (close TCtxEOF)
            ltv
            pt
            ASTEOF
         )))
      ))
      ( (Tuple( (TAnd( lt1 lt2 )) rt )) (
         (match (Tuple( (unify-inner( lt1 rt )) (unify-inner( lt2 rt )) )) (
            ()
            ( (Tuple( TCtxEOF _ )) () )
            ( (Tuple( _ TCtxEOF )) () )
            ( (Tuple( lctx rctx )) (
               (set ctx (union( lctx rctx )))
            ))
         ))
      ))
      ( (Tuple( lt (TAnd( rt1 rt2 )) )) (
         (match (Tuple( (unify-inner( lt rt1 )) (unify-inner( lt rt2 )) )) (
            ()
            ( (Tuple( TCtxEOF TCtxEOF )) () )
            ( (Tuple( lctx TCtxEOF )) (set ctx lctx) )
            ( (Tuple( TCtxEOF rctx )) (set ctx rctx) )
            ( (Tuple( lctx rctx )) (
               (set ctx (union( lctx rctx )))
            ))
         ))
      ))

      # Varargs
      ( (Tuple(
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF lpr ))
            (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         )) ))
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF rpr )) rp1 )) ))
      )) (
         
         (if (can-unify( lp1 rp1 )) (
            (set ctx (and(
               (unify-inner( lpr rpr ))
               (unify-inner( lp1 rp1 ))
            )))
         ) (
            (set ctx (unify-inner( lpr pt )))
         ))
      ))
      ( (Tuple(
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF lpr ))
            (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         )) ))
         rp1
      )) (
         (if (can-unify( lp1 rp1 )) (
            (set ctx (and(
               (unify-inner( lp1 rp1 ))
               (unify-inner( lpr (t1 'Nil_s) ))
            )))
         ) (
            (set ctx (unify-inner( lpr rp1 )))
         ))
      ))
      ( (Tuple(
         (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF rpr )) rp1 )) ))
      )) (
         (if (can-unify( lp1 rp1 )) (
            (set ctx (and(
               (unify-inner( fpt rpr ))
               (unify-inner( lp1 rp1 ))
            )))
         ) ())
      ))
      ( (Tuple(
         (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         (TGround( 'Nil_s TypeEOF ))
      )) ())
      ( (Tuple(
         (TGround( '..._s (TypeSeq( TypeEOF lp1 )) ))
         rp1
      )) (
         (set ctx (unify-inner( lp1 rp1 )))
      ))

      ( (Tuple( (TGround( 'GT_s (TypeSeq( TypeEOF (TGround( lbase TypeEOF )) )) )) (TGround( rbase TypeEOF )) )) (
         (if (>( (to-i64 rbase) (to-i64 lbase) )) (
            (set ctx TCtxNil)
         ) ())
      ))
      ( (Tuple( (TGround( ltn lps )) (TGround( rtn rps )) )) (
         (if (==( ltn rtn )) (
            (set ctx (unify( lps rps )))
         ) ())
      ))
      ( _ () )
   ))
   ctx
) TContext);

unify := λ(: fpt TypeList)(: pt TypeList). (: (
   (let ctx TCtxEOF)
   (match (Tuple( fpt pt )) (
      ()
      ( (Tuple( TypeEOF TypeEOF )) (set ctx TCtxNil) )
      ( (Tuple( (TypeSeq( lps lp1 )) (TypeSeq( rps rp1 )) )) (
         (set ctx (unify( lp1 rp1 )))
         (if (non-zero ctx) (
            (set ctx (union( ctx (unify( lps rps )) )))
         ) ())
      ))
      ( _ () )
   ))
   ctx
) TContext);

fields-of-tag := λ(: tag Type)(: class Type). (: (
   (let rhst TAny)
   (match tag (
      ()
      ( (TGround( 'Tag_s (TypeSeq( TypeEOF (TGround( ts _ )) )) )) (match (fields-of-tag ts) (
         ()
         ( (Tuple( TAny TAny )) () )
         ( (Tuple( fields-lhs fields-rhs )) (
            (set rhst (substitute( (unify( fields-lhs class )) fields-rhs )))
         ))
      )))
      ( _ (
         (print 'Invalid\sTag\sIn\sfields-of-tag\s_s)
         (print tag)(print '\n_s)
         (exit 1_u64)
      ))
   ))
   (set rhst (with-size rhst))
   (let rt (TGround( 'Fields_s (close(TypeSeq(
      (close TypeEOF)
      (fields-of-type( (t3( 'Cons_s rhst (TAnd( (close(t1 'U64_s)) (close(t2( 'Sized_s (t1 '8_s) ))) )) )) ))
   ))))))
   rt
) Type);

fields-of-type := λ(: tt Type). (: (
   (match tt (
      ()
      ( TAny (set tt (t1 'Nil_s)) )
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set tt (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (fields-of-type p1)
               )))
               p2
            )))
         )))
      ))
      ( _ (
         (set tt (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (t1 'Nil_s)
               )))
               tt
            )))
         )))
      ))
   ))
   tt
) Type);

s-type-list := (: STEOF STypeList);
ascript := λ(: t S)(: tt Type). (: (
   (set s-type-list (STSeq(
      (close s-type-list)
      t tt
   )))
) Nil);

typeof := λ(: term S). (: (
   (let found TAny)
   (let tctx s-type-list)
   (while (non-zero tctx) (match tctx (
      ()
      ( (STSeq( rst s tt )) (
         (if (is( s term )) (
            (set found tt)
            (set tctx STEOF)
         ) (
            (set tctx rst)
         ))
      ))
   )))
   found
) Type);

to-s := λ(: term AST). (: (
   (let s SNil)
   (match term (
      ()
      ( (Var( v _ )) (
         (set s (SCons(
            (close(SAtom 'Var_s))
            (close(SAtom v))
         )))
      ))
      ( (Lit( v _ )) (
         (set s (SCons(
            (close(SAtom 'Lit_s))
            (close(SAtom v))
         )))
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (set s (to-s t))
         (ascript( s tt ))
      ))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (set s (to-s t))
         (ascript( s tt ))
      ))
      ( (App( lt rt )) (
         (set s (SCons(
            (close(SAtom 'App_s))
            (close(SCons(
               (close(to-s lt))
               (close(to-s rt))
            )))
         )))
      ))
      ( (Abs( lt rt tlt )) (
         (set s (SCons(
            (close(SAtom 'Abs_s))
            (close(SCons(
               (close(to-s lt))
               (close(to-s rt))
            )))
         )))
      ))
      ( _ () )
   ))
   s
) S);

ascript-normal := λ(: t AST)(: tt Type). (: (
   (if (non-zero tt) (
      (let prev-tt (normalize(typeof t)))
      (if (non-zero prev-tt) (
         (if (is-arrow tt) () (
            (let norm-tt (normalize tt))
            (if (&&( (can-unify( prev-tt norm-tt )) (can-unify( norm-tt prev-tt )) )) () (
               (print prev-tt)
               (print '\s!=\s_s)
               (print norm-tt)
               (print '\n_s)
               (exit-error( 'Type\sAscription\sInequality_s t ))
            ))
         ))
      ) (
         (set tt (with-size tt))
         (set tt (with-tag tt))
         (set tt (with-fields tt))
         (ascript( t tt ))
         (set types-have-changed True_u8)
      ))
   ) ())
) Nil);

sizeof-type := λ(: tt Type). (: (
   (let sz 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar _) () )
      ( (TGround( class TypeEOF )) (set sz (size-of-class class)) )
      ( (TGround( 'Sized_s (TypeSeq( TypeEOF (TGround( szp TypeEOF )) )) )) (
         (set sz (to-u64 szp))
      ))
      ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF p1 )) TAny )) )) (
         (set sz 8_u64)
      ))
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set sz (+(
            (sizeof-aligned p1)
            (sizeof-aligned p2)
         )))
      ))
      ( (TGround( 'Field_s (TypeSeq( (TypeSeq( TypeEOF p1 )) (TGround( szp TypeEOF )) )) )) (
         (set sz (*( (sizeof-type p1) (to-u64 szp) )))
      ))
      ( (TGround( tag _ )) (
         (match (.lookup( type-complex-fields-index tag (Tuple( TAny TAny )) )) (
            ()
            ( (Tuple( TAny TAny )) () )
            ( (Tuple( bt at )) (
               (let ctx (unify( bt tt )))
               (let arg-types (substitute( ctx at )))
               (set sz (+( 8_u64 (sizeof-aligned arg-types) )))
            ))
         ))
      ))
      ( (TAnd( lt rt )) (
         (if (sizeof-type lt) (
            (set sz (sizeof-type lt))
         ) (
            (set sz (sizeof-type rt))
         ))
      ))
      ( _ (
         (print 'Unexpected\sType\ssizeof-type\s_s)
         (print tt)(print '\n_s)(exit 1_u64)
      ))
   ))
   sz
) U64);

has-forward := λ(: tt TypeList). (: (
   (let return 0_u64)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( ts t1 )) (
         (set return (max(
            (has-forward ts)
            (has-forward t1)
         )))
      ))
   ))
   return
) U64);

has-forward := λ(: tt Type). (: (
   (let return 0_u64)
   (match tt (
      ()
      ( (TGround( 'Array_s _ )) () )
      ( (TGround( 'Field_s ps )) (set return (has-forward ps)) )
      ( (TGround( 'Cons_s ps )) (set return (has-forward ps)) )
      ( (TGround( cls ps )) (
         (if (non-zero ps) (
            (set return (has-forward ps))
         ) (
            (if (not(.lookup( class-to-size-index cls 0_u64 ))) (
               (set return 1_u64)
            ) ())
         ))
      ))
      ( (TAnd( lt rt )) (
         (set return (max(
            (has-forward lt)
            (has-forward rt)
         )))
      ))
      ( _ () )
   ))
   return
) U64);

sizeof-aligned := λ(: tt Type). (: (
   (let sz (sizeof-type tt))
   (if (==( sz 0_u64 )) () (set sz (max( 8_u64 sz ))))
   sz
) U64);

set-type-fields := λ(: base-type Type)(: args-type Type). (: (
   (let tag '_s)
   (match base-type (
      ()
      ( (TGround( tg _ )) (set tag tg) )
      ( _ (
         (print 'ERROR:\sset-type-fields\n_s)(print base-type)(print '\n_s)
         (exit 1_u64)
      ))
   ))
   (.bind( (as (& type-complex-fields-index) BTreeEq<String,Tuple<Type,Type>>[]) tag (Tuple( base-type args-type )) ))
) Nil);

typeof-lhs := λ(: lhs AST). (: (
   (let r TAny)
   (match lhs (
      ()
      ( (App( (Lit( ':_s _ )) (App( _ (AType tt) )) )) (
         (set r tt)
      ))
      ( (App( ps (App( (Lit( ':_s _ )) (App( _ (AType tt) )) )) )) (
         (set r (t3( 'Cons_s (typeof-lhs ps) tt )))
      ))
      ( ASTNil (
         (set r (t1 'Nil_s))
      ))
      ( _ (exit-error( 'Unknown\sLHS_s lhs )))
   ))
   r
) Type);

typeof-tag := λ(: tag String). (: (
   (let r (.lookup( type-constructors-index tag TAny )))
   r
) Type);

as-local-variable := λ(: tt Type). (: (
   (set tt (normalize tt))
   (if (non-zero tt) (
      (set tt (TAnd( (close tt) (close(t1 'LocalVariable_s)) )))
   ) ())
   (set tt (with-size tt))
   tt
) Type);

as-constant := λ(: tt Type). (: (
   (if (non-zero tt) (
      (set tt (TAnd( (close tt) (close(t1 'Constant_s)) )))
   ) ())
   tt
) Type);

with-size := λ(: tt Type). (: (
   (if (not(is-sized tt)) (
      (let sz (sizeof-type tt))
      (set tt (with-size-recurse tt))
      (set tt (and( tt (t2( 'Sized_s (t1(to-string sz)) )) )))
   ) ())
   (match tt (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (
         (set tt (t3( 'Cons_s (with-size p1) (with-size p2) )))
      ))
      ( _ () )
   ))
   tt
) Type);

with-size := λ(: tt TypeList). (: (
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( ps p1 )) (
         (set tt (TypeSeq( (close(with-size ps)) (with-size p1) )))
      ))
   ))
   tt
) TypeList);

with-size-recurse := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set tt (and(
            (with-size-recurse lt)
            (with-size-recurse rt)
         )))
      ))
      ( (TGround( 'Tag_s _ )) () )
      ( (TGround( 'Sized_s _ )) () )
      ( (TGround( 'Fields_s _ )) () )
      ( (TGround( 'FieldsSized_s _ )) () )
      ( (TGround( tag ps )) (
         (set tt (TGround( tag (close(with-size ps)) )))
      ))
      ( _ () )
   ))
   tt
) Type);

is-sized := λ(: tt Type). (: (
   (let r 0_u64)
   (match tt (
      ()
      ( TAny (set r 1_u64) )
      ( (TGround( 'Cons_s _ )) (set r 1_u64) )
      ( (TGround( 'Arrow_s _ )) (set r 1_u64) )
      ( (TGround( 'Sized_s _ )) (set r 1_u64) )
      ( (TAnd( lt rt )) (
         (set r (max(
            (is-sized lt)
            (is-sized rt)
         )))
      ))
      ( _ () )
   ))
   r
) U64);

and := λ(: lt Type)(: rt Type). (: (
   (let tt (TAnd( (close lt) (close rt) )))
   tt
) Type);

is-parameterized := λ(: tt Type). (: (
   (let r 0_u64)
   (match tt (
      ()
      ( (TGround( _ (TypeSeq( _ _ )) )) (set r 1_u64) )
      ( (TAnd( lt rt )) (
         (if (is-parameterized lt) (set r 1_u64) ())
         (if (is-parameterized rt) (set r 1_u64) ())
      ))
      ( _ () )
   ))
   r
) U64);

cons-head := λ(: tt Type). (: (
   (let r TAny)
   (match tt (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF hd )) tl )) )) (set r hd) )
      ( _ () )
   ))
   r
) Type);

cons-tail := λ(: tt Type). (: (
   (let r TAny)
   (match tt (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF hd )) tl )) )) (set r tl) )
      ( _ () )
   ))
   r
) Type);

deep-hash := λ(: tt Type). (: (
   (let return 0_u64)
   (match tt (
      ()
      ( TAny () )
      ( (TVar v) (set return (deep-hash v)) )
      ( (TAnd( lt rt )) (
         (set return (+(
            (deep-hash lt)
            (deep-hash rt)
         )))
      ))
      ( (TGround( tag ps )) (
         (set return (+(
            (deep-hash tag)
            (deep-hash ps)
         )))
      ))
   ))
   return
) U64);

deep-hash := λ(: tt TypeList). (: (
   (let return 0_u64)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( ts t1 )) (
         (set return (+(
            (deep-hash ts)
            (deep-hash t1)
         )))
      ))
   ))
   return
) U64);

specialize := λ(: key String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (
   (set unify-ctx (normalize unify-ctx))
   (let term ASTEOF)
   (let global-ctx global-type-context)
   (while (non-zero global-ctx) (match global-ctx (
      ()
      ( TCtxNil (set global-ctx TCtxEOF) )
      ( (TCtxBind( rst k kt t )) (
         (if (==( k key )) (
            (if (==( ft kt )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (set term t) )
                  ( _ () )
               ))
            ) ())
         ) ())
         (set global-ctx rst)
      ))
   )))
   (mark-as-special( key result-type ))
   (let special-term (substitute( unify-ctx term )))
   (infer-global-context( special-term ))
   (infer-expr( global-type-context special-term Unscoped TAny Used ))
   (set ast-parsed-program (Seq(
      (close ast-parsed-program)
      (close special-term)
   )))
) Nil);

has-representation := λ(: tt Type). (: (
   (let return 0_u64)
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set return (max(
            (has-representation lt)
            (has-representation rt)
         )))
      ))
      ( (TGround( 'Constant_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg8_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg16_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg32_s _ )) (set return 1_u64) )
      ( (TGround( 'Reg64_s _ )) (set return 1_u64) )
      ( (TGround( 'StackVariable_s _ )) (set return 1_u64) )
      ( _ () )
   ))
   return
) U64);

guess-representation := λ(: tt Type). (: (
   (if (has-representation tt) () (
      (let sz (sizeof-type tt))
      (match sz (
         ()
         ( 0_u64 () )
         ( 1_u64 (set tt (and( tt (t1( 'Reg8_s )) ))) )
         ( 2_u64 (set tt (and( tt (t1( 'Reg16_s )) ))) )
         ( 4_u64 (set tt (and( tt (t1( 'Reg32_s )) ))) )
         ( 8_u64 (set tt (and( tt (t1( 'Reg64_s )) ))) )
         ( _ (set tt (and( tt (t1( 'StackVariable_s )) ))) )
      ))
   ))
   tt
) Type);

unify-hint := λ(: hint Type)(: tt Type). (: (
   (match (Tuple( hint tt )) (
      ()
      ( (Tuple( (TGround( hint-tag hint-args )) (TGround( tt-tag tt-args )) )) (
         (if (==( hint-tag tt-tag )) (
            (set tt hint)
         ) (
            (set tt (TGround( tt-tag (close(unify-hint( hint tt-args ))) )))
         ))
      ))
      ( (Tuple( _ (TAnd( lt rt )) )) (
         (set tt (TAnd(
            (close(unify-hint( hint lt )))
            (close(unify-hint( hint rt )))
         )))
      ))
      ( _ () )
   ))
   tt
) Type);

unify-hint := λ(: hint Type)(: tt TypeList). (: (
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst p1 )) (
         (set tt (TypeSeq(
            (close(unify-hint( hint rst )))
            (unify-hint( hint p1 ))
         )))
      ))
      ( _ () )
   ))
   tt
) TypeList);


typecheck := λ. (: (
   (let p ast-parsed-program)
   (let ordered-type-exprs ASTEOF)
   (while (non-zero p) (match p (
      ()
      ( (Seq( rst r )) (
         (set ordered-type-exprs (Seq( (close ordered-type-exprs) (close r) )))
         (set p rst)
      ))
   )))
   (while (non-zero ordered-type-exprs) (match ordered-type-exprs (
      ()
      ( (Seq( rst r )) (
         (infer-global-context( r ))
         (set ordered-type-exprs rst)
      ))
   )))
   (infer-expr( global-type-context ast-parsed-program Unscoped TAny Used ))
   (assert-well-typed ast-parsed-program)
) Nil);

infer-type-definition := λ(: base-type Type)(: body AST)(: case-number U64). (: (
   (let r 0_u64)
   (match body (
      ()
      ( (App( (App( tds (Var( '|_s _ )) )) case )) (
         (let r1 (infer-type-definition( base-type tds (+( case-number 1_u64 )) )))
         (let r2 (infer-type-constructor( base-type case )))
         (set r (max( r1 r2 )))
      ))
      ( case (
         (set r (infer-type-constructor( base-type case )))
         (if (==( case-number 0_u64 )) (
            (let tag '_s)
            (match case (
               ()
               ( (Lit( tg _ )) (set tag tg) )
               ( (App( (Lit( tg _ )) args )) (set tag tg) )
               ( _ () )
            ))
            (if (head-string tag) (
               (match base-type (
                  ()
                  ( (TGround( cls _ )) (
                     (has-only-child( cls tag ))
                  ))
               ))
            ) ())
         ) ())
      ))
   ))
   r
) U64);

arity := λ(: tt TypeList). (: (
   (let a 0_u64)
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst _ )) (
         (set a (+( (arity rst) 1_u64 )))
      ))
   ))
   a
) U64);

arity := λ(: tt Type). (: (
   (let a 0_u64)
   (match tt (
      ()
      ( (TGround( _ ps )) (set a (arity ps)) )
      ( _ () )
   ))
   a
) U64);

cons-arity := λ(: tt Type). (: (
   (let a 1_u64)
   (match tt (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF ltt )) rtt )) )) (
         (set a (+( (cons-arity ltt) 1_u64 )))
      ))
      ( _ () )
   ))
   a
) U64);

parameter-number := λ(: tt Type)(: parameter-name String). (: (
   (let a 0_u64)
   (match tt (
      ()
      ( (TGround( _ ps )) (
         (set a (parameter-number( ps parameter-name 1_u64 )))
      ))
      ( _ () )
   ))
   a
) U64);

parameter-number := λ(: tt TypeList)(: parameter-name String)(: pi U64). (: (
   (let a 0_u64)
   (match tt (
      ()
      ( (TypeSeq( rst (TVar v) )) (
         (if (==( v parameter-name )) (
            (set a pi)
         ) (
            (set a (parameter-number( rst parameter-name (+( pi 1_u64 )) )))
         ))
      ))
      ( _ () )
   ))
   a
) U64);

mark-constructor-flat-parameters := λ(: base-type Type)(: tag String)(: flat-type Type). (: (
   (print 'Mark\sFlat\s_s)(print base-type)(print '._s)(print tag)
   (print '\s->\s_s)(print flat-type)(print '\n_s)
) Nil);

infer-type-constructor := λ(: base-type Type)(: body AST). (: (
   (let r 0_u64)
   (match body (
      ()
      ( (Lit( tag _ )) (
         (let rtype (and(
            (and(
               base-type
               (t2( 'Tag_s (t1 tag) ))
            ))
            (and(
               (t1 'Constant_s)
               (and(
                  (t2( 'Constructor_s (t1 tag) ))
                  (t2( 'FieldsSized_s (t1 '0_s) ))
               ))
            ))
         )))
         (index-class-of-tag( tag base-type ))
         (index-fields-of-tag( tag TAny (t1 'Nil_s) ))
         (.bind( (as (& type-constructors-index) BTreeEq<String,Type>[]) tag rtype ))
         (set r 8_u64)
      ))
      ( (App( (Lit( tag _ )) args )) (
         (let atype (type-of-s args))
         (mark-constructor-flat-parameters( base-type tag atype ))
         #TODO mark-parameter-flat tag arity parameter-no 
         (if (has-forward atype) (
            (print 'Size\sOf\sType\sCannot\sBe\sDetermined\sDue\sTo\sForward\sReference:\s_s)
            (print tag)(print '\n_s)
            (exit 1_u64)
         ) ())
         (let rtype (and(
            base-type
            (t2( 'Tag_s (t1 tag) ))
         )))
         (set-type-fields( base-type atype ))
         (index-class-of-tag( tag base-type ))
         (index-fields-of-tag( tag base-type atype ))
         (.bind( (as (& type-constructors-index) BTreeEq<String,Type>[]) tag (t3( 'Arrow_s atype rtype )) ))
         (set r (sizeof-aligned atype))
         (set r (+( r 8_u64 )))
      ))
      ( _ () )
   ))
   r
) U64);

infer-global-context := λ(: td AST). (: (
   (match td (
      ()
      ( (Typedef( (Lit( base-type _ )) case-constructors )) (
         (let bt (parse-type base-type))
         (let size (infer-type-definition( bt case-constructors 0_u64 )))
         (match bt (
            ()
            ( (TGround( class TypeEOF )) (index-size-of-class( class size )) )
            ( _ () )
         ))
      ))
      ( (Glb( k_t (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) )) (
         (let lt (typeof-lhs lhs))
         (let return-type (guess-representation(without-representation rhst)))
         (let ft (t3( 'Arrow_s lt return-type )))
         (mark-global-as-seen( k ft ))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            td
         )))
      ))
      ( (Frg( k_t (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) atlt )) tlt )) (
         (let lt (typeof-lhs lhs))
         (let ft (t3( 'Arrow_s lt rhst )))
         (mark-global-as-seen( k ft ))
         (ascript-normal( td ft ))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
            ASTEOF
         )))
      ))
      ( (Glb( k_t (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) )) (
         (let kt (and( (without-representation rhst) (t1 'GlobalVariable_s) )))
         (set global-type-context (TCtxBind(
            (close global-type-context) k kt ASTEOF
         )))
         (mark-global-as-seen( k kt ))
         (ascript-normal( td kt ))
      ))
      ( (Frg( k_t (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) (
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            rhst ASTEOF
         )))
         (mark-global-as-seen( k rhst ))
      ))
      ( (Glb( _ _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( (Frg( _ _ _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( _ () )
   ))
) Nil);

assert-well-typed := λ(: term AST). (: (
   (match term (
      ()
      ( ASTEOF (assert-one-typed term) )
      ( ASTNil (assert-one-typed term) )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (
            (assert-well-typed v)
         ))
      ))
      ( (Frg( _ v _ )) (
         (assert-one-typed v)
      ))
      ( (Typedef( _ _ )) () )
      ( (App( (Abs( (Var( lname _ )) ASTNil tlt )) rhs )) (
         (assert-well-typed rhs)
         (assert-one-typed term)
      ))
      ( (App( (Var( 'gensym-label_s _ )) _ )) () )
      ( (App( (Var( 'label_s _ )) (Var( _ _ )) )) () )
      ( (App( (App( (Var( 'while_s _ )) cond )) body )) (
         (assert-well-typed cond)
         (assert-well-typed body)
         (assert-one-typed term)
      ))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (assert-well-typed t)
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (assert-well-typed t)
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (
         (assert-well-typed cond)
         (assert-well-typed t)
         (assert-well-typed f)
         (assert-one-typed term)
      ))
      ( (App( (App( (Var( 'set_s _ )) lhs )) rhs )) (
         (assert-well-typed rhs)
         (assert-one-typed term)
      ))
      ( (AType _) () )
      ( (App( (Var( 'open_s _ )) rterm )) (
         (assert-well-typed rterm)
         (assert-one-typed term)
      ))
      ( (App( (Var( 'scope_s _ )) rterm )) (
         (assert-well-typed rterm)
         (assert-one-typed term)
      ))
      ( (Lit( l _ )) (assert-one-typed term) )
      ( (Var( l _ )) (assert-one-typed term) )
      ( (Abs( lhs rhs tlt )) (
         (assert-well-typed rhs)
         (assert-one-typed term)
      ))
      ( (App( l r )) (
         (assert-well-typed l)
         (assert-well-typed r)
         (assert-one-typed term)
      ))
      ( (Seq( l r )) (
         (assert-well-typed l)
         (assert-well-typed r)
      ))
      ( (Meta( _ )) () )
      ( _ (
         (print 'Unknown\sTerm\sIn\sAssert\sWell\sTyped\s_s)(print term)(print '\n_s)
         (exit 1_u64)
      ))
   ))
) Nil);

assert-one-typed := λ(: term AST). (: (
   (if (non-zero(typeof term)) () (
      (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s term ))
   ))
) Nil);

with-fields := λ(: tt Type). (: (
   (match (slot( tt 'Fields_s )) (
      ()
      ( (TGround( 'Fields_s _ )) () )
      ( _ (
         (let class (with-only-class tt))
         (let tag (with-only-tag tt))
         (if (&&( (non-zero tag) (non-zero class) )) (
            (let ft (fields-of-tag( tag class )))
            (set tt (and( tt ft )))
         ) ())
      ))
   ))
   tt
) Type);

apply := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt False_u8 blame )))
   tt
) Type);

apply-and-specialize := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt True_u8 blame )))
   tt
) Type);

apply-plural := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (let r (: LEOF List<Type>))
   (match ft (
      ()
      ( (TAnd( t1 t2 )) (
         (set r (+(
            (apply-plural( function-name t1 pt do-specialize blame ))
            (apply-plural( function-name t2 pt do-specialize blame ))
         )))
      ))
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF fpt )) frt )) )) (
         (if (can-unify( fpt pt )) (
            (set r (cons( ft r )))
         ) ())
      ))
      ( _ () )
   ))
   r
) List<Type>);

reduce-plural := λ(: pts List<Type>). (: (
   (let r (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( try tlt )) (
         (let maybes tlt)
         (set pts tlt)
         (while (non-zero maybes) (match maybes (
            ()
            ( (LCons( tst mrst )) (
               (if (non-zero try) (
                  (if (can-unify( (domain try) (domain tst) )) (
                     (set try TAny)
                  ) ())
               ) ())
               (set maybes mrst)
            ))
         )))
         (if (non-zero try) (
            (set r (cons( try r )))
         ) ())
      ))
   )))
   (set pts r)
   (set r (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( try tlt )) (
         (let maybes tlt)
         (set pts tlt)
         (while (non-zero maybes) (match maybes (
            ()
            ( (LCons( tst mrst )) (
               (if (non-zero try) (
                  (if (can-unify( (domain try) (domain tst) )) (
                     (set try TAny)
                  ) ())
               ) ())
               (set maybes mrst)
            ))
         )))
         (if (non-zero try) (
            (set r (cons( try r )))
         ) ())
      ))
   )))
   r
) List<Type>);

apply := λ(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (let r TAny)
   (let rs (apply-plural( function-name ft pt do-specialize blame )))
   (set rs (reduce-plural rs))
   (if (==( (.length rs) 0_u64 )) (
      (print 'Function\sApplication\sYielded\sNo\sMatches\n_s)
      (print function-name)(print '\nWith\sArgument\s:\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (print 'Options:\s_s)(print ft)(print '\n_s)
      (exit 1_u64)
   ) ())
   (if (>( (.length rs) 1_u64 )) (
      (print 'Function\sApplication\sYielded\sAn\sIrreducible\sPlurality\sOf\sMatches\n_s)
      (print function-name)(print '\s:\s_s)(print ft)(print '\n_s)
      (print 'With\sArgument\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (let rs-copy rs)
      (while (non-zero( rs-copy )) (
         (print 'Matched\s_s)
         (match rs-copy (
            ()
            ( (LCons( hd tl )) (
               (print hd)
               (set rs-copy tl)
            ))
         ))
         (print '\n_s)
      ))
      (exit 1_u64)      
   ) ())
   (match rs (
      ()
      ( (LCons( sft _ )) (
         (match sft (
            ()
            ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF fpt )) frt )) )) (
               (let ctx (unify( fpt pt )))
               (set ctx (normalize ctx))
               (let closed-type (substitute( ctx sft )))
               (set r (guess-representation(substitute( ctx frt ))))
               (if (&&( (==( do-specialize True_u8 )) (is-open sft) )) (
                  (if (is-open closed-type) (
                     (print 'Application\sDid\sNot\sClose\sBefore\sSpecialization:\n_s)
                     (print 'Function\s_s)(print function-name)(print '\s:\s_s)(print sft)(print '\n_s)
                     (print 'Argument\s_s)(print pt)(print '\n_s)
                     (print (location-of( blame )))(print '\n_s)
                     (exit 1_u64)
                  ) ())
                  (try-specialize( function-name sft ctx closed-type ))
               ) ())
            ))
            ( _ (
               (print 'Function\sNot\sSimple\sArrow:\s_s)(print sft)(print '\n_s)
               (exit 1_u64)
            ))
         ))
      ))
   ))
   r
) Type);

apply-or-cons-and-specialize := λ(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let r TAny)
   (if (is-arrow ft) (
      (set r (apply( function-name ft pt True_u8 blame )))
   ) (
      (if (&&( (non-zero ft) (non-zero pt) )) (
         (set r (t3( 'Cons_s ft pt )))
      ) ())
   ))
   r
) Type);

try-specialize := λ(: function-name String)(: ft Type)(: unify-ctx TContext)(: result-type Type). (: (
   (set result-type (normalize result-type))
   (let global-ctx global-type-context)
   (if (is-special( function-name result-type )) () (
      (while (non-zero global-ctx) (match global-ctx (
         ()
         ( TCtxNil (set global-ctx TCtxEOF) )
         ( (TCtxBind( rst k kt t )) (
            (if (&&( (==( function-name k )) (==( ft kt )) )) (
               (match t (
                  ()
                  ( (Glb( _ (Abs( _ _ _ )) )) (
                     (specialize( function-name ft unify-ctx result-type ))
                  ))
                  ( _ () )
               ))
            ) ())
            (set global-ctx rst)
         ))
      )))
   ))
) Nil);

infer-tctx := λ(: tctx TContext)(: tt TypeList). (: (
   (match tt (
      ()
      ( TypeEOF () )
      ( (TypeSeq( rst p1 )) (
         (set tctx (infer-tctx( tctx rst )))
         (set tctx (infer-tctx( tctx p1 )))
      ))
   ))
   tctx
) TContext);

infer-tctx := λ(: tctx TContext)(: tt Type). (: (
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (set tctx (infer-tctx( tctx lt )))
         (set tctx (infer-tctx( tctx rt )))
      ))
      ( (TVar( tv )) (
         (set tctx (TCtxBind(
            (close tctx)
            tv
            (t1 'Constant_s)
            ASTEOF
         )))
      ))
      ( (TGround( _ ts )) (
         (set tctx (infer-tctx( tctx ts )))
      ))
      ( TAny () )
   ))
   tctx
) TContext);

infer-ctx := λ(: tctx TContext)(: lhs AST). (: (
   (match lhs (
      ()
      ( (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) (
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-tctx( tctx tt )))
      ))
      ( (App( ps (App( (Lit( ':_s _ )) (App( (Var( v vtk )) (AType tt) )) )) )) (
         (set tctx (TCtxBind(
            (close tctx) v (as-local-variable tt) (Var( v vtk ))
         )))
         (set tctx (infer-ctx( tctx ps )))
         (set tctx (infer-tctx( tctx tt )))
      ))
      ( ASTNil () )
      ( _ (exit-error( 'Invalid\sLHS_s lhs )) )
   ))
   tctx
) TContext);

implicit-tail := λ(: tt Type). (: (
   (match tt (
      ()
      ( (TGround( 'Cons_s (TypeSeq( (TypeSeq( TypeEOF hd )) tl )) )) (
         (set tt tl)
      ))
      ( _ () )
   ))
   tt
) Type);

typeof-var := λ(: sloc AST)(: tctx TContext)(: vname String). (: (
   (let found (typeof-var-raw( sloc tctx vname )))
   (if (non-zero found) () (
      (exit-error( 'Unknown\sReferenced\sVariable_s sloc ))
   ))
   found
) Type);

typeof-var-raw := λ(: sloc AST)(: tctx TContext)(: vname String). (: (
   (let found TAny)
   (while (non-zero tctx) (match tctx (
      ()
      ( TCtxNil (set tctx TCtxEOF) )
      ( (TCtxBind( rst k vt _ )) (
         (if (==( k vname )) (
            (if (non-zero found) (
               (if (is-arrow vt) (
                  (set found (and( found vt )))
               ) (
                  (set found vt)
               ))
            ) (
               (set found vt)
            ))
            (if (is-arrow vt) (
               (set tctx rst)
            ) (
               (set tctx TCtxEOF)
            ))
         ) (
            (set tctx rst)
         ))
      ))
   )))
   found
) Type);

is-reg8 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'AL_s (set r 1_u64))
      ( 'BL_s (set r 1_u64))
      ( 'CL_s (set r 1_u64))
      ( 'DL_s (set r 1_u64))
      ( 'SIL_s (set r 1_u64))
      ( 'DIL_s (set r 1_u64))
      ( 'BPL_s (set r 1_u64))
      ( 'SPL_s (set r 1_u64))
      ( 'R8B_s (set r 1_u64))
      ( 'R9B_s (set r 1_u64))
      ( 'R10B_s (set r 1_u64))
      ( 'R11B_s (set r 1_u64))
      ( 'R12B_s (set r 1_u64))
      ( 'R13B_s (set r 1_u64))
      ( 'R14B_s (set r 1_u64))
      ( 'R15B_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg16 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'AX_s (set r 1_u64))
      ( 'BX_s (set r 1_u64))
      ( 'CX_s (set r 1_u64))
      ( 'DX_s (set r 1_u64))
      ( 'SI_s (set r 1_u64))
      ( 'DI_s (set r 1_u64))
      ( 'BP_s (set r 1_u64))
      ( 'SP_s (set r 1_u64))
      ( 'R8W_s (set r 1_u64))
      ( 'R9W_s (set r 1_u64))
      ( 'R10W_s (set r 1_u64))
      ( 'R11W_s (set r 1_u64))
      ( 'R12W_s (set r 1_u64))
      ( 'R13W_s (set r 1_u64))
      ( 'R14W_s (set r 1_u64))
      ( 'R15W_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg32 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'EAX_s (set r 1_u64))
      ( 'EBX_s (set r 1_u64))
      ( 'ECX_s (set r 1_u64))
      ( 'EDX_s (set r 1_u64))
      ( 'ESI_s (set r 1_u64))
      ( 'EDI_s (set r 1_u64))
      ( 'EBP_s (set r 1_u64))
      ( 'ESP_s (set r 1_u64))
      ( 'R8D_s (set r 1_u64))
      ( 'R9D_s (set r 1_u64))
      ( 'R10D_s (set r 1_u64))
      ( 'R11D_s (set r 1_u64))
      ( 'R12D_s (set r 1_u64))
      ( 'R13D_s (set r 1_u64))
      ( 'R14D_s (set r 1_u64))
      ( 'R15D_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);
is-reg64 := λ(: s String). (: (
   (let r 0_u64)
   (match s (
      ()
      ( 'RAX_s (set r 1_u64))
      ( 'RBX_s (set r 1_u64))
      ( 'RCX_s (set r 1_u64))
      ( 'RDX_s (set r 1_u64))
      ( 'RSI_s (set r 1_u64))
      ( 'RDI_s (set r 1_u64))
      ( 'RBP_s (set r 1_u64))
      ( 'RSP_s (set r 1_u64))
      ( 'R8_s (set r 1_u64))
      ( 'R9_s (set r 1_u64))
      ( 'R10_s (set r 1_u64))
      ( 'R11_s (set r 1_u64))
      ( 'R12_s (set r 1_u64))
      ( 'R13_s (set r 1_u64))
      ( 'R14_s (set r 1_u64))
      ( 'R15_s (set r 1_u64))
      ( _ () )
   ))
   r
) U64);

infer-expr := λ(: tctx TContext)(: term AST)(: scoped IsScoped)(: hint Type)(: used IsUsed). (: (
   (match term (
      ()
      ( ASTNil (ascript-normal( term (t1 'Nil_s) )) )
      ( ASTEOF (ascript-normal( term (t1 'Nil_s) )) )
      ( (Seq( l r )) (
         (infer-expr( tctx l Unscoped TAny Used ))
         (infer-expr( tctx r Unscoped TAny Used ))
      ))
      ( (Typedef( _ _ )) () )
      ( (Glb( k v )) (
         (if (is-open(typeof term)) () (
            (infer-expr( tctx v Unscoped TAny Used ))
         ))
      ))
      ( (Frg( _ v _ )) (
         (ascript-normal( v (typeof term) ))
      ))
      ( (App( (Lit( ':_s _ )) (App( (Lit( _ _ )) (AType tt) )) )) (
         (match term (
            ()
            ( (App( _ (App( t _ )) )) (
               (match (slot( tt 'String_s )) (
                  ()
                  ( (TGround( 'String_s _ )) () )
                  ( _ (infer-expr( tctx t Unscoped tt used )) )
               ))
               (let inner-tt (typeof t))
               (if (non-zero inner-tt) (
                  (set tt (and( tt inner-tt )))
               ) (
                  (ascript-normal( t tt ))
               ))
               (ascript-normal( term tt ))
            ))
         ))
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (set tctx (infer-expr( tctx t Unscoped tt used )))
         (let inner-tt (typeof t))
         (if (non-zero inner-tt) (
            (let nn (with-only-representation inner-tt))
            (if (non-zero nn) (
               (let tt-2 (and(
                  tt
                  nn
               )))
               (set tt tt-2)
            ) ())
            (ascript-normal( t tt ))
            (ascript-normal( term tt ))
            (match term (
               ()
               ( (App( las ras )) (
                  (ascript-normal( las tt ))
                  (ascript-normal( ras tt ))
               ))
            ))
         ) ())
      ))
      ( (App( (Var( 'gensym-label_s _ )) (Var( lname _ )) )) (
         (set tctx (TCtxBind(
            (close tctx) lname (t1 'Label_s) ASTEOF
         )))
         (ascript-normal( term (t1 'Nil_s) ))
      ))
      ( (App( (App( (Var( 'set_s _ )) (Var( v _ )) )) rhs )) (
         (infer-expr( tctx rhs Unscoped TAny Tail ))
         (ascript-normal( rhs (typeof-var( term tctx v )) ))
         (ascript-normal( term (t1 'Nil_s) ))
      ))
      ( (App( (Var( 'label_s _ )) (Var( lname _ )) )) (
         (ascript-normal( term (t1 'Nil_s) ))
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (
         (if (is( scoped Scoped )) (
            (let tctx-inner (infer-expr( tctx cond Unscoped TAny Used )))
            (infer-expr( tctx-inner t Unscoped TAny Tail ))
         ) (
            (set tctx (infer-expr( tctx cond Unscoped TAny Used )))
            (set tctx (infer-expr( tctx t Unscoped TAny Tail )))
         ))
         (infer-expr( tctx f Unscoped TAny Tail ))
         (ascript-normal( term (guess-representation(without-representation(typeof t))) ))
      ))
      ( (App( (App( (Var( 'while_s _ )) cond )) body )) (
         (set tctx (infer-expr( tctx cond Unscoped TAny Used )))
         (infer-expr( tctx body Unscoped TAny Tail ))
         (ascript-normal( term (t1 'Nil_s) ))
      ))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (set tctx (infer-expr( tctx t Unscoped TAny used )))
         (let inner-tt (typeof t))
         (match t (
            ()
            ( (Lit( l _ )) (
               (if (is-reg8 l) (set inner-tt (t1 'Reg8_s)) ())
               (if (is-reg16 l) (set inner-tt (t1 'Reg16_s)) ())
               (if (is-reg32 l) (set inner-tt (t1 'Reg32_s)) ())
               (if (is-reg64 l) (set inner-tt (t1 'Reg64_s)) ())
            ))
            ( _ () )
         ))
         (if (non-zero inner-tt) (
            (let inner-repr (with-only-representation inner-tt))
            (if (non-zero inner-repr) (
               (set tt (and( tt inner-repr )))
            ) ())
            (let inner-class (with-only-class inner-tt))
            (if (non-zero inner-class) (
               (set tt (and( tt inner-class )))
            ) ())
            (set tt (with-fields( tt )))
            (ascript-normal( term tt ))
         ) ())
      ))
      ( (App( (Var( 'sizeof_s _ )) (AType _) )) (
         (let tt (as-constant(parse-type 'U64_s)))
         (ascript-normal( term tt ))
         (match term (
            ()
            ( (App( s _ )) (ascript-normal( s tt )) )
         ))
      ))
      ( (App( (Var( 'scope_s _ )) r )) (
         (infer-expr( tctx r Scoped TAny Tail ))
         (ascript-normal( term (typeof r) ))
      ))
      ( (App( (Var( 'open_s _ )) r )) (
         (set tctx (infer-expr( tctx r Unscoped TAny Used )))
         (let deref-type (typeof r))
         (match (slot( deref-type 'Array_s )) (
            ()
            ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF TAny )) _ )) )) () )
            ( (TGround( 'Array_s (TypeSeq( (TypeSeq( TypeEOF array-base )) TAny )) )) (
               (set deref-type (and( array-base (t1 'StackVariable_s) )))
            ))
            ( _ () )
         ))
         (ascript-normal( term deref-type ))
      ))
      ( (App( (Abs( (Var( lname _ )) ASTNil tlt )) rhs )) (
         (let prev-tt (typeof-var-raw( term tctx lname )))
         (if (non-zero prev-tt) (
            (if (not(is-arrow prev-tt)) (
               (exit-error( 'Variable\sName\sIs\sAlready\sBound\sIn\sOuter\sScope_s term ))
            ) ())
         ) ())
         (infer-expr( tctx rhs Unscoped TAny Tail ))
         (let tt (typeof rhs))
         (let rt (as-local-variable tt))
         (if (non-zero tt) () (
            (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s rhs ))
         ))
         (if (non-zero rt) () (
            (exit-error( 'Unable\sto\sinfer\stype\sof\sexpression_s rhs ))
         ))
         (set tctx (TCtxBind(
            (close tctx) lname rt ASTEOF
         )))
         (ascript-normal( term (t1 'Nil_s) ))
      ))
      ( (App( l r )) (
         (let l-used Unused)
         (if (is( used Call )) (set l-used Call) ())
         (let r-used Used)
         (if (is( used Unused )) (set r-used Unused) ())
         (set tctx (infer-expr( tctx l Unscoped TAny l-used )))
         (if (is-arrow(typeof l)) (set r-used Call) ())
         (set tctx (infer-expr( tctx r Unscoped TAny r-used )))
         (let rt (apply-or-cons-and-specialize(
            (var-name-if-var l)
            (typeof l)
            (typeof r)
            term
         )))
         (if (is( l-used Unused )) (
            (set rt (implicit-tail rt))
         ) ())
         (ascript-normal( term rt ))
      ))
      ( (Abs( lhs rhs tlt )) (
         (set tctx (infer-ctx( tctx lhs )))
         (infer-expr( tctx rhs Unscoped TAny Tail ))
         (let lt (typeof-lhs lhs))
         (let rt (typeof rhs))
         (ascript-normal( term (t3( 'Arrow_s lt rt )) ))
      ))
      ( (Var( v vtk )) (
         (let vt (typeof-var( term tctx v )))
         (ascript-normal( term (typeof-var( term tctx v )) ))
      ))
      ( (Lit( l _ )) (
         (if (non-zero(typeof term)) () (
            (let tt (typeof-tag l))
            (if (non-zero tt) (
               (if (non-zero hint) (
                  (set tt (unify-hint( hint tt )))
               ) ())
               (ascript-normal( term tt ))
            ) ())
         ))
      ))
      ( (Meta( _ )) (ascript-normal( term (t1 'Nil_s) )) )
      ( _ (
         (print 'Unknown\sTerm\sIn\sType\sInference\n_s)
         (print term)
         (print '\n_s)
         (exit 1_u64)
      ))
   ))
   tctx
) TContext);

