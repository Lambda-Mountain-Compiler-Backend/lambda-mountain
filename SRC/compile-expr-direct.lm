
compile-expr-direct := Î»(: ctx FContext)(: term AST)(: stack-offset I64)(: used IsUsed). (: (
   (let e (fragment::new()))
   (set e (fragment::set-context( e ctx )))
   (set e (fragment::set-offset( e stack-offset )))
   (match term (
      ()
      ( ASTNil (
         (set e (fragment::set-type( e (denormalize(t1 'Nil_s)) )))
      ))
      ( ASTEOF () )
      ( (Var( id _ )) (
         # TODO, this is being called instead of function
         (set e (fragment-context::lookup( ctx id (typeof term) term )))
         (set e (fragment::set-context( e ctx )))
         (set e (fragment::set-offset( e stack-offset )))
      ))
      ( (Lit( val _ )) (
         (let ltype (typeof term))
         (if (is-string ltype) (
            (set e (compile-declare-cstring( val )))
         ) (
            (let isa-fragment False_u8)
            (if (is-reg8 ltype) (set isa-fragment True_u8) ())
            (if (is-reg16 ltype) (set isa-fragment True_u8) ())
            (if (is-reg32 ltype) (set isa-fragment True_u8) ())
            (if (is-reg64 ltype) (set isa-fragment True_u8) ())
            (if (==( isa-fragment True_u8 )) (
               (set e (fragment::expression val))
            ) (
               (if (non-zero(class-of-tag val)) (
                  (let tag-index (index-of-tag val))
                  (set e (fragment::expression(to-string tag-index)))
                  (set e (fragment::set( e 'program_s (SCons( (close SNil) (close SNil) )) )))
               ) (
                  (match val (
                     ()
                     ( 'True_s (set e (fragment::expression '1_s)) )
                     ( 'False_s (set e (fragment::expression '0_s)) )
                     ( '\\t_s (set e (fragment::expression '9_s)) )
                     ( '\\n_s (set e (fragment::expression '10_s)) )
                     ( '\\s_s (set e (fragment::expression '32_s)) )
                     ( '\\o_s (set e (fragment::expression '35_s)) )
                     ( '\\`_s (set e (fragment::expression '39_s)) )
                     ( '\\[_s (set e (fragment::expression '40_s)) )
                     ( '\\]_s (set e (fragment::expression '41_s)) )
                     ( '\\:_s (set e (fragment::expression '59_s)) )
                     ( _ (set e (fragment::expression val)) )
                  ))
               ))
            ))
         ))
         (set e (fragment::set-context( e ctx )))
         (set e (fragment::set-type( e (denormalize ltype) )))
      ))
      ( (App( (Lit( ':_s _ )) (App( t (AType tt) )) )) (
         (set e (compile-expr( ctx t stack-offset used )))
      ))
      ( (App( (Var( 'gensym-label_s _ )) (Var( id _ )) )) (
         (set ctx (fragment-context::bind(
            ctx id (t1 'Label_s) (fragment::label( (uuid()) ))
         )))
         (set e (fragment::set-context( e ctx )))
         (set e (fragment::set-type( e (denormalize(t1 'Nil_s)) )))
      ))
      ( (App( (Var( 'label_s _ )) (Var( id _ )) )) (
         (let l (fragment-context::lookup( ctx id (t1 'Label_s) term )))
         (let prog (SCons(
            (close(fragment::get( l 'expression_s )))
            (close(SAtom ':\n_s))
         )))
         (set e (fragment::set( e 'program_s prog )))
         (set e (fragment::set-type( e (denormalize(t1 'Nil_s)) )))
      ))
      ( (App( (Var( 'scope_s _ )) t )) (
         (set e (compile-expr( ctx t stack-offset Tail )))
         (set e (fragment::set-context( e ctx )))
      ))
      ( (App( (Var( 'open_s _ )) t )) (
         (let tt (typeof t))
         (match (slot( tt 'Array_s )) (
            ()
            ( (TGround( 'Array_s (LCons( _ (LCons( TAny LEOF )) )) )) (
               (set e (compile-expr( ctx t stack-offset Used )))
            ) )
            ( (TGround( 'Array_s (LCons( TAny (LCons( inner-tt LEOF )) )) )) (
               (set e (compile-stack-calls( ctx 'push-deref_s (t1 'Nil_s) t stack-offset Used )))
               (set e (fragment::set-type( e (and( (denormalize inner-tt) (t1 'StackVariable_s) )) )))
               (let new-offset (-( stack-offset (as (sizeof-aligned inner-tt) I64) )))
               (set e (fragment::set-offset( e new-offset )))
            ))
            ( _ (
               (set e (compile-expr( ctx t stack-offset Used )))
            ))
         ))
      ))
      ( (App( (Var( 'sizeof_s _ )) (AType tt) )) (
         (let sz (sizeof-type( tt )))
         (set e (fragment::expression(to-string sz)))
         (let et (TAnd( 
            (close(t1 'Literal_s))
            (close(TAnd(
               (close(t1 'Constant_s))
               (close(TAnd(
                  (close(t1 'U64_s))
                  (close(t2( 'Sized_s (t1 '8_s) )))
               )))
            )))
         )))
         (set e (fragment::set-type( e et )))
         (set e (fragment::set-context( e ctx )))
         (set e (fragment::set-offset( e stack-offset )))
      ))
      ( (App( (Var( 'as_s _ )) (App( t (AType tt) )) )) (
         (set e (compile-expr( ctx t stack-offset used )))
         (set e (fragment::set-type( e (typeof term) )))
      ))
      ( (App( (App( (Var( 'while_s _ )) cond )) body )) (
         (let e1 (cc-blob( ctx 'into-branch-conditional_s cond stack-offset )))
         (let e2 (compile-expr( (open(.context e1)) body (.offset e1) Unused )))

         (let ectx (fragment::new()))
         (set ectx (fragment::set-type( ectx (t1( 'ImplicitContext_s )) )))

         (set e (fragment-apply( ctx stack-offset 'primitive::while_s
            (FLSeq( (close(FLSeq( (close(FLSeq( (close FLEOF) ectx ))) e1 ))) e2 )) (typeof term) term
         )))

         (set e (fragment::set-context( e ctx )))
         (set e (fragment::set-offset( e stack-offset )))
         (set e (fragment::set-type( e (typeof term) )))
      ))
      ( (App( (App( (App( (Var( 'if_s _ )) cond )) t )) f )) (
         (let rsp-offset (+( stack-offset -8_i64 )))
         (let e1 (cc-blob( ctx 'into-branch-conditional_s cond rsp-offset )))
         (let e2 (compile-expr( (open(.context e1)) t (.offset e1) Tail )))
         (let end-offset (.offset e2))
         (set e2 (compile-maybe-push-stack( (open(.context e2)) (.offset e2) e2 (typeof term) term )))
         (set e2 (fragment::set-type( e2 (typeof t) )))
         (let e3 (compile-expr( (open(.context e1)) f (.offset e1) Tail )))
         (set e3 (compile-maybe-push-stack( (open(.context e3)) (.offset e3) e3 (typeof term) term )))
         (set e3 (fragment::set-type( e3 (typeof f) )))

         (let ectx (fragment::new()))
         (set ectx (fragment::set( ectx 'rsp-offset_s (SAtom(to-string rsp-offset)) ))) 
         (set ectx (fragment::set( ectx 'end-offset_s (SAtom(to-string end-offset)) ))) 
         (set ectx (fragment::set( ectx 'return-size_s (SAtom(to-string(sizeof-type(typeof term)))) ))) 
         (set ectx (fragment::set-type( ectx (t1( 'ImplicitContext_s )) )))

         (set e (fragment-apply( ctx stack-offset 'primitive::if_s
            (FLSeq( (close(FLSeq( (close(FLSeq( (close(FLSeq( (close FLEOF) ectx ))) e1 ))) e2 ))) e3 )) (typeof term) term
         )))

         (set e (fragment::set-context( e (open(.context e2)) )))
         (set e (fragment::set-offset( e end-offset )))
         (if (>( (sizeof-type(typeof term)) 8_u64 )) (
            (set e (fragment::set-type( e (and( (typeof term) (t1 'StackVariable_s) )) )))
         ) (
            (set e (fragment::set-type( e (typeof term) )))
         ))
      ))
      ( (App( (Abs( (Var( lhs _ )) ASTNil tlt )) rhs )) (
         (let rtype (typeof rhs))
         (set rtype (without-representation rtype))
         (set rtype (and( rtype (t1 'LocalVariable_s) )))
         (set rtype (with-size( rtype )))
         (let size (sizeof-aligned rtype))
         (set e (compile-push-rvalue( ctx rhs stack-offset )))
         (let bind-offset (-( stack-offset (as size I64) )))
         (let unframe-del SNil)
         (set ctx (fragment-context::bind(
            ctx lhs rtype (fragment::local-variable( bind-offset rtype ))
         )))
         (match term (
            ()
            ( (App( (Abs( lhs-var _ _ )) _ )) (
               (let tc (fragment-context::lookup-soft( ctx 'del_s (typeof lhs-var) term )))
               (let t (.type tc))
               (if (non-zero t) (
                  (let del-call (compile-stack-calls( ctx 'del_s rtype lhs-var stack-offset used )))
                  (set unframe-del (fragment::get( del-call 'program_s )))
               ) ())
            ))
         ))
         (set e (fragment::set( e 'del_s unframe-del )))
         (set e (fragment::set( e 'unframe_s
            (SCons(
               (close(fragment::get( e 'unframe_s )))
               (close(SCons(
                  (close(SAtom '\tadd\s$_s))
                  (close(SCons(
                     (close(SAtom(to-string size)))
                     (close(SAtom ',\s%rsp\n_s))
                  )))
               )))
            ))
         )))
         (set e (fragment::set-context( e ctx )))
         (set e (fragment::set-offset( e bind-offset )))
         (set e (fragment::set-type( e (typeof term) )))
      ))
      ( (App( f a )) (
         (if (is-arrow(typeof f)) (
            (match f (
               ()
               ( (Var( fname _ )) (
                  (set e (compile-stack-calls( ctx fname (typeof term) a stack-offset used )))
               ))
               ( (App( (Lit( ':_s _ )) (App( (Var( fname _ )) (AType ft) )) )) (
                  (set e (compile-stack-calls( ctx fname (typeof term) a stack-offset used )))
               ))
               ( (Lit( fname _ )) (
                  (set e (compile-constructor( ctx fname (typeof term) (typeof a) a stack-offset )))
               ))
               ( (App( (Lit( ':_s _ )) (App( (Lit( fname _ )) (AType ft) )) )) (
                  (set e (compile-constructor( ctx fname (typeof term) (typeof a) a stack-offset )))
               ))
            ))
         ) (
            (if (is( used Unused )) (scope(
               (let e1 (compile-expr( ctx f stack-offset Unused )))
               (let e2 (compile-expr( (open(.context e1)) a (.offset e1) Unused )))
               (set e (fragment::chain( e1 e2 )))
               (set e (fragment::set-type( e (typeof term) )))
            )) (scope(
               (let e1 (compile-expr( ctx f stack-offset Unused )))
               (let e2 (compile-expr( (open(.context e1)) a (.offset e1) Used )))
               (set e (fragment::chain( e1 e2 )))
               (set e (fragment::set-type( e (typeof term) )))
            )))
         ))
      ))
   ))
   e
) Fragment);

