
typeof := λ(: args FragmentList). (: (tail(
   (let r TAny)
   (match args (
      ()
      ( (FLSeq( rst f )) (tail(
         (let rst-tt (maybe-deref(typeof rst)))
         (let f-tt (maybe-deref(fragment::get-type f)))
         (if (non-zero rst-tt) (tail(
            (let r2 (t3( 'Cons_s rst-tt f-tt )))
            (set r r2)
         )) (
            (set r f-tt)
         ))
      )))
      ( _ () )
   ))
   r
)) Type);

fragment-size-args := λ(: args FragmentList). (: (tail(
   (match args (
      ()
      ( (FLSeq( rst f )) (tail(
         (let f-tt (maybe-deref(fragment::get-type f)))
         (let f-tt-sized (maybe-deref(with-size f-tt)))
         (let f-sized (maybe-deref(fragment::set-type( f f-tt-sized ))))(set f f-sized)
         (set args (FLSeq(
            (close(fragment-size-args rst))
            f
         )))
      )))
      ( _ () )
   ))
   args
)) FragmentList);

fragment-apply := λ(: ctx FContext)(: offset I64)(: k String)(: args FragmentList)(: direct-type Type)(: sloc AST). (: (tail(
   (let args-sized (maybe-deref(fragment-size-args args)))(set args args-sized)
   (let e-proto (maybe-deref(fragment::new())))
   (let e-proto-2 (maybe-deref(fragment::set-context( e-proto ctx ))))(set e-proto e-proto-2)
   (let e-proto-3 (maybe-deref(fragment::set-offset( e-proto offset ))))(set e-proto e-proto-3)


   (let at (maybe-deref(typeof args)))
   (if (non-zero at) () (tail(
      (print 'Apply\s_s)(print k)(print args)
      (let msg (clone-rope(SCons( (close(SAtom 'Untyped\sFragment\sArguments:\s_s)) (close(SAtom k)) ))))
      (exit-error( msg sloc ))
   )))
   (let arrow (maybe-deref(fragment-context::lookup( ctx k at sloc ))))
   (let arrow-tt (maybe-deref(fragment::get-type arrow)))

   (let return-tt TAny)
   (match (slot( arrow-tt 'Arrow_s )) (
      ()
      ( (TGround( 'Arrow_s (TypeSeq( (TypeSeq( TypeEOF lt )) rt )) )) (set return-tt rt) )
      ( _ (tail(
         (print 'Apply\sDirect\sFragment\sIs\sNot\sAn\sArrow:\s_s)
         (print k)(print '\s:\s_s)
         (print arrow-tt)(print '\n_s)
      )))
   ))

   (let chain True_u8)
   (match (slot( arrow-tt 'DontChain_s )) (
      ()
      ( (TGround( 'DontChain_s _ )) (set chain False_u8) )
      ( _ () )
   ))

   (let tctx (unify( (slot( arrow-tt 'Arrow_s )) direct-type )))
   (let ctx-2 (union( ctx tctx )))(set ctx ctx-2)

   (let return (maybe-deref(apply-direct( ctx arrow args e-proto chain ))))

   (let comment (SAtom '\oCall\sFragment\s_s))
   (set comment (SCons( (close comment) (close(SAtom k)) )))
   (set comment (SCons( (close comment) (close(SAtom '\s:\s_s)) )))
   (set comment (SCons( (close comment) (close(SAtom(to-string arrow-tt))) )))
   (set comment (SCons( (close comment) (close(SAtom '\n\oArgument:\s_s)) )))
   (set comment (SCons( (close comment) (close(SAtom k)) )))
   (set comment (SCons( (close comment) (close(SAtom '\s:\s_s)) )))
   (set comment (SCons( (close comment) (close(SAtom(to-string at))) )))
   (set comment (SCons( (close comment) (close(SAtom '\n_s)) )))
   (set comment (SCons( (close comment) (close(SAtom '\oReturn:\s_s)) )))
   (set comment (SCons( (close comment) (close(SAtom k)) )))
   (set comment (SCons( (close comment) (close(SAtom '\s:\s_s)) )))
   (set comment (SCons( (close comment) (close(SAtom(to-string return-tt))) )))
   (set comment (SCons( (close comment) (close(SAtom '\n_s)) )))
   (let r2 (maybe-deref(fragment::set( return 'program_s (SCons(
      (close comment)
      (close(fragment::get( return 'program_s )))
   ))))))(set return r2)
   (let r3 (maybe-deref(fragment::set-type( return return-tt ))))(set return r3)

   return
)) Fragment);

