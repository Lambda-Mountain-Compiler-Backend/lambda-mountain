
let mk-app(f: AST, a: AST): AST = (
   App{ close(f), close(a) }
);

let mk-cons-or-app(is-cons: U64, f: AST, a: AST): AST = (
   App{ is-cons, close(f), close(a) }
);

let mk-cons(f: AST, a: AST): AST = (
   App{ true, close(f), close(a) }
);

let mk-glb(k: Token, v: AST): AST = (
   Glb{ k, close(v) }
);

let mk-seq(): AST = (
   Seq{ mk-vector(type(AST)) }
);

let mk-typedef(l: AST, r: AST): AST = (
   Typedef{ close(l), close(r) }
);

let mk-typedef2(lhs-type: Type): AST = (
   Typedef2{ lhs-type, mk-vector(type(Type)), mk-vector(type(Type)), mk-vector(type((CString,Type))), TAny }
);

let .with-implies(t: AST, implies: Vector<Type>): AST = (
   match t {
      Typedef2{ lhs-type=lhs-type, implements=implements, constraints=constraints, size=size } => Typedef2{ lhs-type, implies, implements, constraints, size };
      _ => t;
   }
);
let .with-implements(t: AST, implements: Vector<Type>): AST = (
   match t {
      Typedef2{ lhs-type=lhs-type, implies=implies, constraints=constraints, size=size } => Typedef2{ lhs-type, implies, implements, constraints, size };
      _ => t;
   }
);
let .with-constraints(t: AST, constraints: Vector<(CString,Type)>): AST = (
   match t {
      Typedef2{ lhs-type=lhs-type, implies=implies, implements=implements, size=size } => Typedef2{ lhs-type, implies, implements, constraints, size };
      _ => t;
   }
);
let .with-size(t: AST, size: Type): AST = (
   match t {
      Typedef2{ lhs-type=lhs-type, implies=implies, implements=implements, constraints=constraints } => Typedef2{ lhs-type, implies, implements, constraints, size };
      _ => t;
   }
);

let mk-abs(l: AST, r: AST, t: Type): AST = (
   Abs{ close(l), close(r), t }
);

let mk-meta(l: AST): AST = (
   Meta{ close(l) }
);

let mk-nil(): AST = ASTNil{};
let mk-eof(): AST = ASTEOF{};

let .is-lit(t: AST): U64 = match t { Lit{} => true; _ => false; };

