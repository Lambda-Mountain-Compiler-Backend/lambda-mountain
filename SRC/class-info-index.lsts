
type StructLayout = LM1Style | CStyle | FragmentStyle | UnknownStyle;

type ClassInfo = ClassInfo { layout: StructLayout, tag-structs:List<Tuple<CString,Tuple<Type,Type>>> };
let class-info-index = {} :: HashtableEq<Tuple<CString,U64>,ClassInfo>;

let class-info-default = ClassInfo{ UnknownStyle, [] :: List<Tuple<CString,Tuple<Type,Type>>> };
let .with-layout(ci: ClassInfo, layout: StructLayout): ClassInfo = (
   ClassInfo{ layout, ci.tag-structs }
);
let .with-tag-struct(ci: ClassInfo, ts: Tuple<CString,Tuple<Type,Type>>): ClassInfo = (
   ClassInfo{ ci.layout, cons(ts, ci.tag-structs) }
);

let add-class-info-layout(cls: Type, layout: StructLayout): Nil = (
   class-info-index = class-info-index.bind(
      cls.ground-tag-and-arity,
      class-info-index.lookup(cls.ground-tag-and-arity,class-info-default).with-layout(layout)
   );
);
let add-class-info-tag-struct(cls: Type, ts: Tuple<CString,Tuple<Type,Type>>): Nil = (
   class-info-index = class-info-index.bind(
      cls.ground-tag-and-arity,
      class-info-index.lookup(cls.ground-tag-and-arity,class-info-default).with-tag-struct(ts)
   );
);

let .is-class(cls: Type): U64 = class-info-index.has(cls.ground-tag-and-arity);
let .is-lm-struct(cls: Type): U64 = (
   let ta = cls.ground-tag-and-arity;
   is(class-info-index.lookup(ta, class-info-default).layout, LM1Style)
);
let .is-fragment(cls: Type): U64 = (
   let ta = cls.ground-tag-and-arity;
   is(class-info-index.lookup(ta, class-info-default).layout, FragmentStyle)
);

let index-fields-of-tag(tag: CString, base-type: Type, fields-params: Type, fields-rhs: Type): Nil = (
   add-class-info-tag-struct( base-type, Tuple{tag, Tuple{fields-params, fields-rhs}} );
   index-fields-quick-prop( t1(c"Tag::" + tag), base-type, fields-rhs, 1 );
   index-fields-quick-prop( t1(c"Tag::" + tag), t3( c"Array", base-type, TAny), fields-rhs, 1 );
);

let index-fields-quick-prop(tag-tt: Type, base-type: Type, fields-tt: Type, field-index: U64): Nil = (
   match fields-tt {
      TGround{ tag:c"Cons", parameters:[pt.. rst..] } => (
         add-quick-prop( tag-tt, base-type,
            t2( c"Field::" + to-string(field-index), pt )
         );
         if is-only-child(base-type) {
            add-quick-prop( t3( c"Array", base-type, TAny ), t3( c"Array", base-type, TAny ),
               t2( c"Field::" + to-string(field-index), pt )
            )
         };
         index-fields-quick-prop( tag-tt, base-type, rst, field-index + 1)
      );
      TGround{ tag:c"Nil" } => ();
      pt => (
         add-quick-prop( tag-tt, base-type,
            t2( c"Field::" + to-string(field-index), pt )
         );
         add-quick-prop( t3( c"Array", base-type, TAny ), t3( c"Array", base-type, TAny ),
            t2( c"Field::" + to-string(field-index), pt )
         )
      );
   }
);

let fields-of-tag(base-type: Type, tag: CString): Tuple<Type,Type> = (
   let lr = Tuple{ TAny, TAny };
   for Tuple{ stag=first, slr=second } in
      class-info-index.lookup(base-type.ground-tag-and-arity,class-info-default).tag-structs {
      if tag==stag { lr = slr; }
   };
   lr
);
