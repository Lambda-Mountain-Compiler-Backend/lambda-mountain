
let infer-global-context-terms(term: AST): AST = (
   match term {
      Seq{} => (
         let seqs = mk-vector(type(AST));
         while term.is-seq { match term {
            Seq{l=left, r=right} => (
               seqs = seqs.push(r);
               if l.is-seq
               then term = l
               else (term = ASTEOF; seqs = seqs.push(l));
            );
         }};
         let is-diff = false as U64;
         let def-i = seqs.length - 1;
         while def-i > 0 {
            let r = seqs[def-i];
            let new-r = infer-global-context-terms(r);
            if not(is(r,new-r)) then { is-diff = true; seqs[def-i] = new-r; };
            def-i = def-i - 1;
         };
         if is-diff {
            term = ASTEOF;
            let def-order-i = seqs.length - 1;
            while def-order-i > 0 {
               if non-zero(term)
               then term = mk-seq(term, seqs[def-order-i])
               else term = seqs[def-order-i];
               def-order-i = def-order-i - 1;
            };
         }
      );
      Glb{rhs:Abs{}} => ();
      Glb{k=key, rhs=val} => (
         (_, let new-rhs) = std-infer-expr((None :: TContext?), rhs, false, Used, TAny);
         let kt = normalize(typeof(rhs)) && t1(c"GlobalVariable");
         global-type-context = global-type-context.bind(k.key, kt, term);
         mark-global-as-seen(k.key, kt, TAny);
         ascript-normal(term, kt);
         maybe-apply-global-callable(c"mov", t3(c"Cons",kt,kt), term);
      );
      _ => ();
   }; term
);

infer-global-context := Î»(: td AST). (: (
   (match td (
      ()
      ( (Typedef( (Lit( base-type _ )) case-constructors )) (
         (let bt (parse-type base-type))
         (infer-type-definition( bt case-constructors 0_u64 )) ()
      ))
      ( (Typedef( (AType( bt )) case-constructors )) (
         (infer-type-definition( bt case-constructors 0_u64 )) ()
      ))
      ( (Glb( k (@( frhs (Abs( lhs (App( (Lit( ':_s _ )) (App( rhs (AType rhst) )) )) tlt )) )) )) (
         (if (.is-t( tlt 'TypedMacro_s )) (
            (bind-new-macro( (.key k) frhs ))
         ) (
            (let lt (typeof-lhs lhs))
            (let return-type rhst)
            (let ft (t3( 'Arrow_s lt return-type )))
            (set ft (&&( ft tlt )))
            (if (&&( (.is-t( tlt 'Hook_s )) (not(.is-t( rhst 'Nil_s ))) )) (
               (exit-error( 'Hooks\sMust\sNot\sReturn\sValues._s td ))
            ) ())
            (mark-global-as-seen( (.key k) ft tlt ))
            (ascript-normal( td ft ))
            (ascript-normal( frhs ft ))
            (set global-type-context (.bind( global-type-context (.key k) ft td )))
         ))
      ))
      ( _ () )
   ))
) Nil);
