
let apply-blame(function-name: CString, function-type: Type, parameters: Type, do-specialize: U64, blame: AST): ApplyResult = (
   let r = apply(function-name, function-type, parameters, do-specialize);
   if not(non-zero(r.return-type)) {
      fail("Function Application Yielded No Matches\n"
           "\{function-name}\n"
           "With Arguments \{parameters}\n"
           "At \{location-of(blame)}\n"
           "With Candidates:\n"
           "\{function-type.pretty}\n")
   };
   if r.return-type.is-t(c"Error: Did Not Close Before Specialization") {
      fail("Application\sDid\sNot\sClose\sBefore\sSpecialization:\n"
           "Function \{function-name}: \{function-type}\n"
           "Argument \{parameters}\n"
           "At \{location-of(blame)}\n");
   };
   if r.return-type.is-t(c"Error: Function Application Yielded An Irreducible Plurality Of Matches") {
      fail("Function Application Yielded An Irreducible Plurality Of Matches\n"
           "\{function-name}\n"
           "With Arguments \{parameters}\n"
           "At \{location-of(blame)}\n"
           "Matched Candidates:\n"
           "\{function-type.pretty}\n")
   };
   r
);

let apply(function-name: CString, function-type: Type, parameters: Type, do-specialize: U64): ApplyResult = (
   let r = TAny {};
   let rs = apply-plural(function-name, function-type, parameters);
   if not(function-type.is-t( c"Hook" )) {
      rs = reduce-plural(rs);
   };
   let phi-types = [] :: List<Tuple<CString,Type>>;
   if rs.length > 1 && not(function-type.is-t( c"Hook" )) {
      r = t1(c"Error: Function Application Yielded An Irreducible Plurality Of Matches");
      function-type = head(rs);
      for candidate in tail(rs) {
         function-type = TAnd { close(r), close(candidate) };
      };
   } else {
      for sft in rs { # iterate in case this is a hook
         let frt = sft.range;
         let fpt = sft.domain;
         let ctx = normalize(unify(fpt, parameters));
         let phi-ctx = ctx;
         while non-zero(phi-ctx) { match phi-ctx {
            TCtxBind { rst=ctx, key:c"Phi::Transition", typ=typ, term:Var{ pid=key } } => (
               phi-types = cons( Tuple{ pid, typ }, phi-types );
               phi-ctx = rst;
            );
            TCtxBind { rst=ctx, key=key, typ=typ } => (
               phi-ctx = rst;
            );
            _ => (phi-ctx = TCtxEOF {};);
         } };
         let closed-type = substitute( ctx, sft );
         function-type = closed-type;
         if not(r.is-t( c"Error: Did Not Close Before Specialization")) {
            r = substitute(ctx, frt);
         };
         if do-specialize && sft.is-open {
            if closed-type.is-open {
               r = t1(c"Error: Did Not Close Before Specialization");
            };
            try-specialize(function-name, sft, ctx, closed-type);
         }
      };
      if function-type.is-t(c"Prop") {
         r = and(r, cons-root(parameters));
      };
   };
   ApplyResult { function-type, r, phi-types }
);

