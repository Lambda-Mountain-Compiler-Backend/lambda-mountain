
let std-infer-expr(tctx: Maybe<TContext>, term: AST, is-scoped: Bool, used: IsUsed, hint: Type): (TContext?, AST) = (
   match term {
      App{left:Lit{key:c":"}, right:App{t=left:Lit{},right:AType{tt=tt}}} => (
         tt = tt.rewrite-type-alias;
         add-concrete-type-instance(tt);
         if tt.is-t(c"String") then infer-expr(tctx, t, Unscoped, tt, used);
         let inner-tt = typeof(t);
         if non-zero(inner-tt) {
            if can-unify(tt, inner-tt)
            then tt = inner-tt
            else tt = inner-tt && tt;
         } else {
            ascript-normal(t, tt);
         };
         ascript-normal(term, tt);
      );
      App{left:Lit{key:c":"}, right:App{t=left,right:AType{tt=tt}}} => (
         tt = tt.rewrite-type-alias;
         if var-name-if-var(t)==c"__uninitialized" {
            ascript-normal(t, tt);
         } else {
            tctx = infer-expr(tctx, t, Unscoped, tt, Tail);
         };
         let inner-tt = typeof(t);
         if non-zero(inner-tt) {
            ascript-normal(term, tt);
         };
         if tt.is-t(c"SmartString") then maybe-apply-global-callable(c"intern", tt, term);
         if var-name-if-var(t)!=c"__uninitialized" && not(is(used, C)) {
            ascript-normal(t, tt);
         }
      );
      ASTEOF{} => ascript-normal(term, t1(c"Nil"));
      ASTNil{} => ascript-normal(term, t1(c"Nil"));
      Meta{} => ascript-normal(term, t1(c"Nil"));
      Typedef{} => ();
      AType{tt=tt} => ascript-normal(term, tt);
      Seq{left=left, right=right} => (
         (tctx, let new-left) = std-infer-expr(tctx, left, false, Used, TAny);
         (tctx, let new-right) = std-infer-expr(tctx, right, false, Used, TAny);
         if not(is(left,new-left)) || not(is(right,new-right))
         then term = mk-seq(new-left, new-right);
      );
      Glb{key=key, val=val} => (
         # TODO: remove after infer-expr.lm is ported
         #(tctx, let new-val) = std-infer-expr(tctx, val, false, Used);
         #if not(is(val,new-val)) then term = mk-glb(key, val);
         let rough-tt = typeof(term);
         if rough-tt.is-arrow && not(rough-tt.is-open) {
            infer-expr(tctx, val, if is-scoped then Scoped else Unscoped, TAny, used);
         };
      );
      Var{key=key, token=token} => (
         let vt = denormalize(typeof-var(term, tctx, key));
         ascript-normal(term, vt);
         mark-var-to-def-todo(tctx, key, TAny, term);
      );
      Lit{key=key, token=token} => (
         if not(non-zero(typeof(term))) {
            let tt = typeof-tag(key);
            if non-zero(tt) {
               if non-zero(hint) then tt = hint;
               ascript-normal(term,tt);
            }
         }
      );
      App{ is-cons=is-cons, l=left, r=right } => (
         if is-cons {
            tctx = infer-expr(tctx, l, Unscoped, TAny, Used);
            tctx = infer-expr(tctx, r, Unscoped, TAny, Used);
            ascript-normal(term, if is(used, Tail) then typeof(r) else t3(c"Cons", typeof(l), typeof(r)));
         } else {
            let rt = TAny;
            if var-name-if-var(l)==c"list::cons" { match r {
               App{k=left, m=right} => (
                  infer-expr(tctx, k, Unscoped, TAny, Call);
                  infer-expr(tctx, m, Unscoped, t2(c"List",normalize(typeof(k))), Used);
               );
               _ => ();
            }};
            if var-name-if-var(l)==c"map::cons" { match r {
               App{kv=left, m=right} => (
                  infer-expr(tctx, kv, Unscoped, TAny, Call);
                  infer-expr(tctx, m, Unscoped, t3(c"HashtableEq",normalize(typeof(kv)).r2,normalize(typeof(kv)).r1), Used);
               );
               _ => ();
            }};

            if index-macro-table.has(var-name-if-var(l)) {
               (tctx, term) = std-apply-macro(tctx, term);
            } else {
               tctx = infer-expr(tctx, l, Unscoped, TAny, used);
               if typeof(l).is-arrow {
                  tctx = infer-expr(tctx, r, Unscoped, TAny, Call);            
               } else {
                  tctx = infer-expr(tctx, r, Unscoped, TAny, Used);
               };
               rt = if typeof(l).is-arrow && non-zero(var-name-if-var(l)) {
                  apply-global-callable(var-name-if-var(l), typeof(r), term);
               } else {
                  t3(c"Cons", typeof(l), typeof(r))
               };
               if not(is(used,Call)) { rt = cons-tail-or-self(rt); };
               ascript-normal(term, rt);
            };
         };

         if not(index-macro-table.has(var-name-if-var(l))) && not(is-cons) && non-zero(var-name-if-var(l)) && typeof(l).is-arrow {
            mark-var-to-def-todo(tctx, var-name-if-var(l), typeof(r), l);
         };
      );
      _ => (
         # TODO: remove after infer-expr.lm is ported
         infer-expr(tctx, term, if is-scoped then Scoped else Unscoped, TAny, used);
      );
   };
   (tctx, term);
);

