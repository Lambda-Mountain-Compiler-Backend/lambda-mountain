
let std-infer-expr(tctx: Maybe<TContext>, term: AST, is-scoped: Bool, used: IsUsed): Maybe<TContext> = (
   match term {
      App{ is-cons=is-cons, l=left, r=right } => (
         if is-cons {
            tctx = infer-expr(tctx, l, Unscoped, TAny, Used);
            tctx = infer-expr(tctx, r, Unscoped, TAny, Used);
            ascript-normal(term, if is(used, Tail) then typeof(r) else t3(c"Cons", typeof(l), typeof(r)));
         } else {
            let rt = TAny;
            if var-name-if-var(l)==c"list::cons" { match r {
               App{k=left, m=right} => (
                  infer-expr(tctx, k, Unscoped, TAny, Call);
                  infer-expr(tctx, m, Unscoped, t2(c"List",normalize(typeof(k))), Used);
               );
               _ => ();
            }};
            if var-name-if-var(l)==c"map::cons" { match r {
               App{kv=left, m=right} => (
                  infer-expr(tctx, kv, Unscoped, TAny, Call);
                  infer-expr(tctx, m, Unscoped, t3(c"HashtableEq",normalize(typeof(kv)).r2,normalize(typeof(kv)).r1), Used);
               );
               _ => ();
            }};
            # demarcation line
            # stuff above the line has been reviewd
            # stuff below the line has not been reviewed

            tctx = infer-expr(tctx, l, Unscoped, TAny, used);
            if typeof(l).is-arrow {
               tctx = infer-expr(tctx, r, Unscoped, TAny, Call);            
            } else {
               tctx = infer-expr(tctx, r, Unscoped, TAny, Used);
            };

            rt = if non-zero(var-name-if-var(l)) {
               let fname = find-alias(var-name-if-var(l), typeof(r));
               apply-or-cons-and-specialize(
                  fname,
                  typeof-var-raw(term, tctx, fname),
                  typeof(r),
                  term
               ).return-type
            } else {
               t3(c"Cons", typeof(l), typeof(r))
            };
            
            #match l {
            #   Var{l-fname=key} => (
            #      if is(used, Unused) { r-used = Unused };
            #      tctx = infer-expr(tctx, l, Unscoped, TAny, l-used);
            #      if typeof(l).is-arrow { r-used = Call };
            #      let r-hint = TAny;
            #      tctx = infer-expr(tctx, r, Unscoped, TAny, r-used);
            #      let lt-fname = find-alias(l-fname, typeof(r));
            #      let apply-result = apply-or-cons-and-specialize(
            #         lt-fname,
            #         typeof-var-raw(term, tctx, lt-fname),
            #         typeof(r),
            #         term
            #      );
            #      ascript-normal(l, apply-result.function-type);
            #      rt = apply-result.return-type;
            #   );
            #   _ => (
            #      if is(used, Unused) { r-used = Unused };
            #      tctx = infer-expr(tctx, l, Unscoped, TAny, l-used);
            #
            #      if typeof(l).is-arrow { r-used = Call };
            #      tctx = infer-expr(tctx, r, Unscoped, TAny, r-used);
            #      let apply-result = apply-cons(
            #         var-name-if-var(l), typeof(l), typeof(r), term
            #      );
            #      if head-string(var-name-if-var(l)) {
            #         apply-result = apply-or-cons-and-specialize(
            #            var-name-if-var(l), typeof(l), typeof(r), term
            #         );
            #      };
            #      rt = apply-result.return-type;
            #   );
            #};

            if not(is(used,Call)) { rt = cons-tail-or-self(rt); };
            ascript-normal(term, rt);

            let lt = typeof(l);
            if lt.is-arrow {
               match l {
                  Lit{l-name=key} => (
                     let ct = t2(c"Constructor", t1(var-name-if-var(l)));
                     ct = ct && t2(c"CaseNumber", t1(to-string(index-of-tag(l-name))));
                  );
                  _ => ();
               }
            };
         };

         let arg-type = typeof(r);
         if not(is-cons) && non-zero(var-name-if-var(l)) && typeof(l).is-arrow {
            let def = defof-var(term, tctx, var-name-if-var(l), arg-type);
            var-to-def-index = var-to-def-index.bind(l,def);
         };
      );
   };
   tctx;
);

