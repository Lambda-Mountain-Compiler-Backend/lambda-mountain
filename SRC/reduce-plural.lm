
reduce-plural := Î»(: dpts List<Type>). (: (
   (let pts (: LEOF List<Tuple<Type,Type>>))
   (for-each (pt in dpts) (
      (set pts (cons( (Tuple( (denormalize-arrow pt) pt )) pts )))
   ))
   (set pts (.reverse pts))
   (let r (: LEOF List<Tuple<Type,Type>>))
   (let maybe-constructor pts)
   (while (non-zero maybe-constructor) (match maybe-constructor (
      ()
      ( (LCons( (Tuple( try-denormal try )) tlt )) (
         (if (is-constructor try) (
            (set r (cons( (Tuple( try-denormal try )) r )))
         ) ())
         (set maybe-constructor tlt)
      ))
   )))
   (if (non-zero r) (set pts (: LEOF List<Tuple<Type,Type>>)) ())
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( (Tuple( try-denormal try )) tlt )) (
         (set pts tlt)
         (for-each ((Tuple( tst-denormal tst )) in tlt) (
            (if (non-zero try) (
               (if (can-unify( (.domain try-denormal) (.domain tst-denormal) )) (
                  (set try TAny)
               ) ())
            ) ())
         ))
         (if (non-zero try) (
            (set r (cons( (Tuple( try-denormal try )) r )))
         ) ())
      ))
   )))
   (set pts r)
   (let return (: LEOF List<Type>))
   (while (non-zero pts) (match pts (
      ()
      ( (LCons( (Tuple( try-denormal try )) tlt )) (
         (set pts tlt)
         (for-each ((Tuple( tst-denormal tst )) in tlt) (
            (if (non-zero try) (
               (if (can-unify( (.domain try-denormal) (.domain tst-denormal) )) (
                  (set try TAny)
               ) ())
            ) ())
         ))
         (if (non-zero try) (
            (set return (cons( try return )))
         ) ())
      ))
   )))
   return
) List<Type>);
