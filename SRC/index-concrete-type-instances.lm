
concrete-type-instances-index := (: (HashtableEq( 0_u64 0_u64 (as 0_u64 Tuple<Tuple<String,U64>,List<Type>>[]) )) HashtableEq<Tuple<String,U64>,List<Type>>);

add-concrete-type-instance := λ(: tt Type). (: (
   (match (fields-of-tag(tag-of tt)) (
      ()
      ( (Tuple( lhst rhst )) (if (non-zero lhst) (
         (let tctx (unify( lhst tt )))
         (set rhst (substitute( tctx rhst )))
         (add-concrete-type-instance rhst)
      ) ()))
   ))
   (set tt (normalize tt))
   (let lt (with-only-array tt))
   (if (non-zero lt) (set tt lt) (set tt (with-only-class tt)))
   (if (non-zero tt) (match tt (
      ()
      ( (TGround( tag LEOF )) () )
      ( (TGround( tag ts )) (
         (if (does-concrete-type-instance-exist tt) () (
            (let k (Tuple( tag (.length ts) )))
            (set concrete-type-instances-index (.bind(
               concrete-type-instances-index k
               (cons( tt (.lookup( concrete-type-instances-index k (: LEOF List<Type>) )) ))
            )))
         ))
         (for-each (ct in ts) (add-concrete-type-instance ct))
      ))
   )) ())
) Nil);

does-concrete-type-instance-exist := λ(: tt Type). (: (
   (let r 0_u64)
   (match tt (
      ()
      ( (TGround( tag LEOF )) () )
      ( (TGround( tag ts )) (
         (let k (Tuple( tag (.length ts) )))
         (for-each (vt in (.lookup( concrete-type-instances-index k (: LEOF List<Type>) ))) (
            (if (==( vt tt )) (set r 1_u64) ())
         ))
      ))
   ))
   r
) U64);

