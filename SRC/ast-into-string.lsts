
type AST implements DefaultFormattable;

let .into(t: AST, tgt: Type<String>): String = (
   match t {
      ASTEOF{} => "[EOF]";
      ASTNil{} => "()";
      App{left:Lit{key:c":"},right:App{inner=left, right:AType{tt=tt}}} => (
         inner.into(type(String)) + " :: " + tt.into(type(String));
      );
      App{is-cons:1_u8, left=left,right=right} => (
         "(" + left.into(type(String)) + "," + right.into(type(String)) + ")";
      );
      App{left=left,right=right} => (
         left.into(type(String)) + "(" + right.into(type(String)) + ")";
      );
      Var{key=key} => key.into(type(String));
      Lit{key=key} => "'" + key.into(type(String));
      Abs{lhs=lhs,rhs=rhs} => (
         "(fn (" + lhs.ast-params-into(type(String)) + ") = " + rhs.into(type(String)) + ")";
      );
      Glb{key=key,val=val} => (
         "let \{key.key} = " + val.into(type(String)) + ";";
      );
      AType{tt=tt} => tt.into(type(String));
      Seq{left=left,right=right} => left.into(type(String)) + "\n" + right.into(type(String));
      Typedef{lhs=lhs,rhs=rhs} => "type \{lhs} = \{rhs};";
      Meta{val=val} => "meta \{val}\n";
   };
);

let .ast-params-into(t: AST, tgt: Type<String>): String = (
   match t {
      App{left:Lit{key:c":"},right:App{left:Var{key=key}, right:AType{tt=tt}}} => (
         "\{key}: \{tt}"
      );
      App{left=left, right:App{left:Lit{key:c":"},right:App{left:Var{key=key}, right:AType{tt=tt}}}} => (
         "\{left.ast-params-into(type(String))}, \{key}: \{tt}"
      );
      _ => "";
   }
);
