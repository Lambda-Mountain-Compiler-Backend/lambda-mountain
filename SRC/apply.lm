apply := 位(: function-name String)(: ft Type)(: pt Type)(: blame AST). (: (
   (let tt (apply( function-name ft pt False_u8 blame )))
   tt
) Type);

apply := 位(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST). (: (
   (apply( function-name ft pt do-specialize blame True_u8 ))
) Type);

apply := 位(: function-name String)(: ft Type)(: pt Type)(: do-specialize U8)(: blame AST)(: hard U8). (: (
   (let r TAny)
   (let rs (apply-plural( function-name ft pt do-specialize blame )))
   (if (==( (is-hook ft) 0_u64 )) (
      (set rs (reduce-plural rs))
   ) ())
   (if (&&( (==( (.length rs) 0_u64 )) (==( hard True_u8 )) )) (
      (print 'Function\sApplication\sYielded\sNo\sMatches\n_s)
      (print function-name)(print '\nWith\sArgument\s:\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (print 'Options:\s_s)(print ft)(print '\n_s)
      (exit 1_u64)
   ) ())
   (if (&&( (>( (.length rs) 1_u64 )) (==( (is-hook ft) 0_u64 )) )) (
      (print 'Function\sApplication\sYielded\sAn\sIrreducible\sPlurality\sOf\sMatches\n_s)
      (print function-name)(print '\s:\s_s)(print ft)(print '\n_s)
      (print 'With\sArgument\s_s)(print pt)(print '\n_s)
      (print (location-of( blame )))(print '\n_s)
      (let rs-copy rs)
      (while (non-zero( rs-copy )) (
         (print 'Matched\s_s)
         (match rs-copy (
            ()
            ( (LCons( hd tl )) (
               (print hd)
               (set rs-copy tl)
            ))
         ))
         (print '\n_s)
      ))
      (exit 1_u64)      
   ) ())
   (for-each (sft in rs) (
      (match sft (
         ()
         ( (TGround( 'Arrow_s (LCons( frt (LCons( fpt LEOF )) )) )) (
            (let ctx (unify( fpt pt )))
            (set ctx (normalize ctx))
            (let closed-type (substitute( ctx sft )))
            (set r (guess-representation(substitute( ctx frt ))))
            (if (&&( (==( do-specialize True_u8 )) (is-open sft) )) (
               (if (is-open closed-type) (
                  (print 'Application\sDid\sNot\sClose\sBefore\sSpecialization:\n_s)
                  (print 'Function\s_s)(print function-name)(print '\s:\s_s)(print sft)(print '\n_s)
                  (print 'Argument\s_s)(print pt)(print '\n_s)
                  (print (location-of( blame )))(print '\n_s)
                  (exit 1_u64)
               ) ())
               (try-specialize( function-name sft ctx closed-type ))
            ) ())
         ))
         ( _ (
            (print 'Function\sNot\sSimple\sArrow:\s_s)(print sft)(print '\n_s)
            (exit 1_u64)
         ))
      ))
   ))
   r
) Type);

apply := 位(: ctx Context)(: term AST). (: (
   (let return term)
   (match term (
      ()
      ( ASTEOF () )
      ( ASTNil () )
      ( (Lit( _ _ )) () )
      ( (AType tt) (
         (set return (AType( (substitute( ctx tt )) )))
      ))
      ( (Var( n _ )) (
         (while (non-zero ctx) (match ctx (
            ()
            ( (CtxBind( rst k v )) (
               (if (==( k n )) (
                  (set return v)
                  (set ctx CtxEOF)
               ) (
                  (set ctx rst)
               ))
            ))
            ( _ (set ctx CtxEOF))
         )))
      ))
      ( (App( vl vr )) (
         (set return (App(
            (close(apply( ctx vl )))
            (close(apply( ctx vr )))
         )))
      ))
      ( (Abs( vl vr tlt )) (
         (set return (Abs(
            (close(apply( ctx vl )))
            (close(apply( ctx vr )))
            tlt
         )))
      ))
      ( (Seq( vl vr )) (
         (set return (Seq(
            (close(apply( ctx vl )))
            (close(apply( ctx vr )))
         )))
      ))
      ( (Typedef( vl vr )) (
         (set return (Typedef(
            (close(apply( ctx vl )))
            (close(apply( ctx vr )))
         )))
      ))
      ( (Glb( k vr )) (
         (set return (Glb(
            (substitute( ctx k ))
            (close(apply( ctx vr )))
         )))
      ))
   ))
   return
) AST);

