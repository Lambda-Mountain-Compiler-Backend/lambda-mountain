
# internal _strlen (%rax: *char) -> %rbx
# not a call-convention function
_strlen:
	xor %rbx, %rbx
_strlen_loop:
	cmpb $0, 0(%rax)
	jz _strlen_exit
	inc %rax
	inc %rbx
	jmp _strlen_loop
_strlen_exit:
	ret
# result is stored in %rcx

print_s:
	mov $0, %r9
	jmp __print_this

__print_this: 
	cmp $0, %r9

# if .atom != NULL
__print_this_atom:
	cmp $0, %r12
	je __print_this_cons
	mov %r12, %rax
	call _strlen              # %rbx is length of string
	mov %r12, %rsi            # address of string to output
	mov %rbx, %rdx            # length is %rcx
	mov $1, %rax              # system call 1 is write
	mov $1, %rdi              # file handle 1 is stdout
	syscall                   # invoke operating system to do the write
	ret

# if .head != NULL && .tail != NULL
__print_this_cons:
	cmp $0, %r13
	je __print_this_nil
	cmp $0, %r14
	je __print_this_nil
	push %r14
	push %r13
        #show lparen
	mov $1, %rax
	mov $1, %rdi
	mov $__lparen, %rsi
	mov $1, %rdx
	syscall
        #show head
	pop %r8
	mov 0(%r8), %r12
	mov 8(%r8), %r13
	mov 16(%r8), %r14
	mov 24(%r8), %r15
	call print_s
        #show space
	mov $1, %rax
	mov $1, %rdi
	mov $__space, %rsi
	mov $1, %rdx
	syscall
        #show tail
	pop %r8
	mov 0(%r8), %r12
	mov 8(%r8), %r13
	mov 16(%r8), %r14
	mov 24(%r8), %r15
	call print_s
        #show rparen
	mov $1, %rax
	mov $1, %rdi
	mov $__lparen, %rsi
	mov $1, %rdx
	syscall
	mov $0, %r12
	mov $0, %r13
	mov $0, %r14
	mov $0, %r15
	ret

__print_this_nil:
	mov $1, %rax              # system call 1 is write
	mov $1, %rdi              # file handle 1 is stdout
	mov $__nil_literal, %rsi  # address of string to output
	mov $2, %rdx              # nil is 2 bytes
	syscall                   # invoke operating system to do the write
	ret


