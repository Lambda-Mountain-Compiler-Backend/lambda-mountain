
main := (
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (local config)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config (config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Compile (
         (foreach-atom inputs (
            (set arg $_)
            (if arg (
               (assemble (config (parse-program (tokenize (load-file arg)))))
            ) ())
         ))
      ))
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
);

$uuid := ();
uuid := λ. (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

tokenize-file := λpath. (
   tokenize (load-file path)
);

parse-lambda := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (match er (
      ()
      (((Literal .) r) (() (parse-many-expressions r)))
      ((e r) (tail(
         (local lr)
         (set lr (parse-lambda r))
         (if (head lr)
             ( (e (head lr)) (tail lr) )
             ( e (tail lr) )
         )
      )))
   ))
));

parse-one-expression := λtoks. (tail(
   (local remainder)
   (local is_lambda)
   (local expr)
   (local is_literal)
   (local is_grouped)
   (local grouped_tokens)
   (foreach-atom toks (
      (local c)
      (set c $_)
      (if expr (set remainder (remainder c)) (
      (if is_grouped (
         #grouped
         (match c (
            ()
            (() ())
            ( \[ (
               (set grouped_tokens (grouped_tokens \[))
               (set is_grouped (\[ is_grouped))
            ))
            ( \] (
               (set is_grouped (tail is_grouped))
               (if is_grouped (
                  (set grouped_tokens (grouped_tokens \]))
               ) (
                  (set expr (parse-many-expressions grouped_tokens))
                  (set grouped_tokens ())
               ))
            ))
            ( a (
               (set grouped_tokens (grouped_tokens a))
            ))
         ))
      ) (
         #not grouped
         (match c (
            ()
            (() ())
            ( \l ((set is_lambda True) (set expr INVALID)))
            ( \' (set is_literal True))
            ( \[ (
               (set is_grouped (\[ is_grouped))
            ))
            ( \] (
               (print-s DANGLING_PARENTHESES)
            ))
            ( a (
               (if is_literal (
                  (set expr (Literal a))
                  (set is_literal ())
               ) (
                  (if (is_variable a)
                     (set expr (Variable a))
                     (set expr (Literal a))
                  )
              ))
            ))
         ))
      ))
      ))
   ))
   (if expr () (set expr Nil))
   (if is_lambda
      ((Lambda (parse-lambda remainder)) ())
      (expr remainder)
   )
));

parse-many-expressions := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (local return)
   (set return (head er))
   (local remainder)
   (set remainder (tail er))
   (while remainder (
      (set er (parse-one-expression remainder))
      (set return (App (return (head er))))
      (set remainder (tail er))
   ) (head er))
   return
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local key)
   (local rhs)
   (foreach-atom toks (
      (local a)
      (set a $_)
      (if (eq(a \:)) (
         (if key (
            (set program (program (Global (key (parse-many-expressions rhs)))))
            (set key ())
         ) ())
         (set rhs ())
      ) (
         (if a (set rhs (rhs a)) ())
         (match rhs (
            ()
            ( (((() k) ':) =) (
               (set key k)
               (set rhs ())
            ))
            ( _ () )
         ))
      ))
   ))
   (if key (
     (set program (program (Global (key (parse-many-expressions rhs)))))
   ) ())
   program
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program '))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (': (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program ':))
      )))
      (= (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program =))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   program
));

is_variable := λv. (tail(
   (local is_variable)
   (local passed_char)
   (foreach-char v (
      (local c)
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_variable True) (set passed_char True) ))
         ('_ ( (set is_variable True) (set passed_char True) ))
         ('a ( (set is_variable True) (set passed_char True) ))
         ('b ( (set is_variable True) (set passed_char True) ))
         ('c ( (set is_variable True) (set passed_char True) ))
         ('d ( (set is_variable True) (set passed_char True) ))
         ('e ( (set is_variable True) (set passed_char True) ))
         ('f ( (set is_variable True) (set passed_char True) ))
         ('g ( (set is_variable True) (set passed_char True) ))
         ('h ( (set is_variable True) (set passed_char True) ))
         ('i ( (set is_variable True) (set passed_char True) ))
         ('j ( (set is_variable True) (set passed_char True) ))
         ('k ( (set is_variable True) (set passed_char True) ))
         ('l ( (set is_variable True) (set passed_char True) ))
         ('m ( (set is_variable True) (set passed_char True) ))
         ('n ( (set is_variable True) (set passed_char True) ))
         ('o ( (set is_variable True) (set passed_char True) ))
         ('p ( (set is_variable True) (set passed_char True) ))
         ('q ( (set is_variable True) (set passed_char True) ))
         ('r ( (set is_variable True) (set passed_char True) ))
         ('s ( (set is_variable True) (set passed_char True) ))
         ('t ( (set is_variable True) (set passed_char True) ))
         ('u ( (set is_variable True) (set passed_char True) ))
         ('v ( (set is_variable True) (set passed_char True) ))
         ('w ( (set is_variable True) (set passed_char True) ))
         ('x ( (set is_variable True) (set passed_char True) ))
         ('y ( (set is_variable True) (set passed_char True) ))
         ('z ( (set is_variable True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_variable
));

label-case := λk. (tail(
   (local nk)
   (foreach-char k (match $_ (
      ()
      (- (set nk (nk '_)))
      (c (set nk (nk (clone-rope c))))
   )))
   nk
));

assemble := λconfig program. (
   (local target)
   (set target 'tmp.s)
   (while config (
      (match (tail config) (
         ()
         ((Target t) (set target t))
      ))
      (set config (head config))
   ))
   (local output_p)
   (local output_d)
   (local has_main)
   (set output_p (_program-header()))
   (set output_d (_data-header()))
   (local main_ctx)
   (set main_ctx program)
   (local e)

   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set program pc)
         (set output_p (output_p ('main: \n)))
         (set output_p (output_p (_before-main())))
         (set output_p (output_p (_enter-function())))
         (set e (compile-expr(main_ctx body 0)))
         (set output_p (output_p (get-frame e)))
         (set output_p (output_p (get-prog e)))
         (set output_p (output_p (get-unframe e)))
         (set output_p (output_p (get-text e)))
         (set output_p (output_p (_exit-cleanup())))
         (set output_d (output_d (get-data e)))
         (set has_main True)
      ))
      ( (pc (Global (fname body))) (
         (set program pc)
         (set fname (label-case fname))
         (print-s (F fname body))
         (set output_p (output_p (fname ': \n)))
         (set output_p (output_p (_enter-function())))
         (set e (compile-expr(main_ctx body 0)))
         #TODO unpack expression $body
      ))
   )))

   (if has_main () (
      (set output_p (output_p ('main: \n)))
      (set output_p (output_p (_exit-cleanup())))
   ))

   (write-file (target (clone-rope (output_p output_d))))
);

is-builtin := λf. (match f (
   ()
   ('eq True)
   ('not True)
   ('head True)
   ('tail True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

get-frame := λe. (match e (
   ()
   ((f p u t d pc off) f)
));
get-prog := λe. (match e (
   ()
   ((f p u t d pc off) p)
));
get-unframe := λe. (match e (
   ()
   ((f p u t d pc off) u)
));
get-text := λe. (match e (
   ()
   ((f p u t d pc off) t)
));
get-data := λe. (match e (
   ()
   ((f p u t d pc off) d)
));
get-pc := λe. (match e (
   ()
   ((f p u t d pc off) pc)
));
get-offset := λe. (match e (
   ()
   ((f p u t d pc off) off)
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
yield-atom := λctx a offset. (tail(
   (local id)
   (set id (uuid()))
   (
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
       \t 'mov \s '$0, \s '%r14    \n # $_.$3 = 0, .tail
       \t 'mov \s '$0, \s '%r15    \n # $_.$4 = 0, .flags
      )
      ()
      ()
      (id ': \n \t '.ascii \s " a " \n \t .zero \s 1 \n)
      ctx
      offset
   )
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
compile-expr := λctx e offset. (tail(
   (local x)
   (local prog)
   (match e (
      ()
      ( (App ((Variable fname) arg)) (tail(
         if (is-builtin fname) (
            (set x (compile-expr(ctx arg offset)))
            (set prog (get-prog x))
            (set prog (prog (\t 'call \s (label-case fname) \n)))
            ( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) )
         ) (
            print-s((TODOAPP e))
         )
      )))
      ( (Literal l) (
         (yield-atom (ctx l offset))
      ))
      ( (Variable 'argv) (
         (set prog (prog ( \t 'mov \s '$__argv, \s '%rax \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%rax \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%rax \] , '%r13 \n )))
         (set prog (prog ( \t 'mov \s '16 \[ '%rax \] , '%r14 \n )))
         (set prog (prog ( \t 'mov \s '24 \[ '%rax \] , '%r15 \n )))
         ( () prog () () () ctx offset )
      ))
      (x (print-s (TODO x)) )
   ))
));

_data-header := λ.(
   .data                               \n
  'load_file_bsz:                      \n
  \t .quad \s '1024                    \n
  'load_file_buf:                      \n
  \t .zero \s '1024                    \n
  '__nil:                              \n
  \t .zero \s '32                      \n
  '__argv:                             \n
  \t .zero \s '32                      \n
  '__s_counter:                        \n
  \t .zero \s '8                       \n
  '__s_section:                        \n
  \t .zero \s '268435456               \n
  '__a_counter:                        \n
  \t .zero \s '8                       \n
  '__a_section:                        \n
  \t .zero \s '268435456               \n
  '__nil_literal:                      \n
  \t .ascii \s " \[ \] "               \n
  \t .zero \s 1                        \n
  '__hex_buffer:                       \n
  \t .ascii \s "0123456789abcdef"      \n
  '__put64_buffer:                     \n
  \t .ascii \s "0x"                    \n
  '__put64_write_buffer:               \n
  \t .ascii \s "0000000000000000 \s "  \n
  \t .zero \s '1                       \n
  '__newline:                          \n
  \t .ascii \s " \\ 'n "               \n
  '__lparen:                           \n
  \t .ascii \s " \[ "                  \n
  '__rparen:                           \n
  \t .ascii \s " \] "                  \n
  '__space:                            \n
  \t .ascii \s " \s "                  \n
  '__true:                             \n
  \t .ascii \s "True"                  \n
  \t .zero \s '1                       \n
  '__err_fopen:                        \n
  \t .ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t .zero \s '1                       \n
);

_exit-cleanup := λ.(
   \t 'mov \s '$60, \s '%eax   \n # _exit system call
   \t 'mov \s '$0, \s '%edi    \n # error code 0
   \t 'syscall                 \n
);

_before-main := λ.(
   # let argv = close ()
   # let t = argv
   # for a in argv:
   #    t.tail = (a ())
   #    t = t.tail
   \t 'pop \s %rax                        \n #argc
   \t 'mov \s '$__argv, \s '%rbx          \n
   \t 'movq \s '$0, \s '0 \[ '%rbx \]     \n
   \t 'movq \s '$0, \s '8 \[ '%rbx \]     \n
   \t 'movq \s '$0, \s '16 \[ '%rbx \]    \n
   \t 'movq \s '$0, \s '24 \[ '%rbx \]    \n

   '__before_main_argv:                   \n
   \t 'cmp \s '$0, \s '%rax              \n
   \t 'je \s '__before_main_end         \n
   \t 'pop \s '%r12                     \n #argv[i]
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n

   #close this (move S onto the heap)
   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0\[ '%r8 \] , \s '%r10         \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ '%r8 \]         \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ '%rsi \]        \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ '%rsi \]        \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ '%rsi \]       \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ '%rsi \]       \n # set top.flags
   \t 'mov \s '%rsi, \s '%rdi            \n

   #rdi is a
   \t 'mov \s '$0, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n

   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0\[ '%r8 \] , \s '%r10         \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ '%r8 \]         \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ '%rsi \]        \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ '%rsi \]        \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ '%rsi \]       \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ '%rsi \]       \n # set top.flags
   \t 'mov \s '%rsi, \s '%rdi            \n

   #rsi is clean closed ()
   \t 'mov \s '%rdi, \s '8 \[ '%rbx \]    \n
   \t 'mov \s '%rsi, \s '16 \[ '%rbx \]   \n
   \t 'mov \s '%rsi, \s '%rbx            \n
   #rbx is tail of argv
   \t 'dec \s '%rax                     \n
   \t 'jmp \s '__before_main_argv       \n
   '__before_main_end:                 \n
);

_enter-function := λ.(
   \t 'push \s '%rbp                        \n
   \t 'mov \s '%rsp, \s '%rbp                \n
);
_leave-function := λ.(
   \t 'mov \s '%rbp, \s '%rsp                \n
   \t 'pop \s '%rbp                         \n
   \t 'ret                                 \n
);

_program-header := λ.(
   '.global \s '_start                 \n
   '.text                              \n
   '_start:                            \n
   \t 'jmp \s 'main                    \n

   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   '_strlen:                           \n
   \t 'xor \s '%rbx, \s '%rbx          \n
   \t '_strlen_loop:                   \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]  \n
   \t 'jz \s '_strlen_exit             \n
   \t 'inc \s '%rax                    \n
   \t 'inc \s '%rbx                    \n
   \t 'jmp \s '_strlen_loop            \n
   '_strlen_exit:                      \n
   \t 'ret                             \n
   # result is stored in %rcx

   'print_s:                           \n

   # if .atom != NULL 
   '__print_this_atom:                 \n
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s '__print_this_cons        \n
   \t 'mov \s '%r12, \s '%rax          \n
   \t 'call \s '_strlen                \n # %rbx is length of string
   \t 'mov \s '%r12, \s '%rsi          \n # address of string to output
   \t 'mov \s '%rbx, \s '%rdx          \n # length is %rcx
   \t 'mov \s '$1, \s '%rax            \n # system call 1 is write
   \t 'mov \s '$1, \s '%rdi            \n # file handle 1 is stdout
   \t 'syscall                         \n # invoke operating system to do the write
   \t 'ret                             \n

   # if .head != NULL && .tail != NULL
   '__print_this_cons:                 \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__print_this_nil         \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'je \s '__print_this_nil         \n
   \t 'push \s '%r14                   \n
   \t 'push \s '%r13                   \n
   #show lparen
   \t 'mov \s '$1, \s '%rax            \n
   \t 'mov \s '$1, \s '%rdi            \n
   \t 'mov \s '$__lparen, \s '%rsi     \n
   \t 'mov \s '$1, \s '%rdx            \n
   \t 'syscall                         \n
   #show head
   \t 'pop \s '%r8                     \n
   \t 'mov \s '0 \[ '%r8 \] , '%r12    \n
   \t 'mov \s '8 \[ '%r8 \] , '%r13    \n
   \t 'mov \s '16 \[ '%r8 \] , '%r14   \n
   \t 'mov \s '24 \[ '%r8 \] , '%r15   \n
   \t 'call \s 'print_s                \n
   #show space
   \t 'mov \s '$1, \s '%rax            \n
   \t 'mov \s '$1, \s '%rdi            \n
   \t 'mov \s '$__space, \s '%rsi      \n
   \t 'mov \s '$1, \s '%rdx            \n
   \t 'syscall                         \n
   #show tail
   \t 'pop \s '%r8                     \n
   \t 'mov \s '0 \[ '%r8 \] , '%r12    \n
   \t 'mov \s '8 \[ '%r8 \] , '%r13    \n
   \t 'mov \s '16 \[ '%r8 \] , '%r14   \n
   \t 'mov \s '24 \[ '%r8 \] , '%r15   \n
   \t 'call \s 'print_s                \n
   #show rparen
   \t 'mov \s '$1, \s '%rax            \n
   \t 'mov \s '$1, \s '%rdi            \n
   \t 'mov \s '$__rparen, \s '%rsi     \n
   \t 'mov \s '$1, \s '%rdx            \n
   \t 'syscall                         \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n

   '__print_this_nil:                  \n
   \t 'mov \s '$1, \s '%rax            \n # system call 1 is write
   \t 'mov \s '$1, \s '%rdi            \n # file handle 1 is stdout
   \t 'mov \s '$__nil_literal, \s '%rsi \n # address of string to output
   \t 'mov \s '$2, \s '%rdx            \n # nil is 2 bytes
   \t 'syscall                         \n # invoke operating system to do the write
   \t 'ret                             \n


   'head:                              \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__head_is_nil            \n
   \t 'mov \s '0 \[ '%r13 \] ', '%r12  \n
   \t 'mov \s '16 \[ '%r13 \] ', '%r14 \n
   \t 'mov \s '24 \[ '%r13 \] ', '%r15 \n
   \t 'mov \s '8 \[ '%r13 \] ', '%r13  \n
   \t 'ret                             \n
   '__head_is_nil:                     \n
   \t 'mov \s '$0, \s %r12             \n
   \t 'mov \s '$0, \s %r13             \n
   \t 'mov \s '$0, \s %r14             \n
   \t 'mov \s '$0, \s %r15             \n
   \t 'ret                             \n

   'tail:                              \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__tail_is_nil            \n
   \t 'mov \s '0 \[ '%r14 \] ', '%r12  \n
   \t 'mov \s '8 \[ '%r14 \] ', '%r13  \n
   \t 'mov \s '24 \[ '%r14 \] ', '%r15 \n
   \t 'mov \s '16 \[ '%r14 \] ', '%r14 \n
   \t 'ret                             \n
   '__tail_is_nil:                     \n
   \t 'mov \s '$0, \s %r12             \n
   \t 'mov \s '$0, \s %r13             \n
   \t 'mov \s '$0, \s %r14             \n
   \t 'mov \s '$0, \s %r15             \n
   \t 'ret                             \n

);
