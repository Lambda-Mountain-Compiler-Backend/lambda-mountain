
$stat := ();

main := (
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (local config)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config (config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--compile (set mode Compile))
         (--parse (set mode Parse))
         (--stat (set $stat True))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Compile (
         (foreach-atom inputs (
            (set arg $_)
            (if arg (
               (assemble (config (parse-program (tokenize (load-file arg)))))
            ) ())
         ))
      ))
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
   (if $stat (
      (print-stat MAIN)
   ) ())
);

print-stat := λloc.(
   (print-s \n )
   (print-s loc )
   (print-s \n )
   (print-s 'A_COUNTER:)
   (print-s \s)
   (print-s (i2s A_COUNTER) )
   (print-s \n )
   (print-s 'S_COUNTER:)
   (print-s \s)
   (print-s (i2s S_COUNTER) )
   (print-s \n )
);

$uuid := ();
uuid := λ. (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

i2s := λi. (tail(
   (local ten)
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (local sign)
   (local s)
   (local r)
   (if (is-neg i) (
      (set sign '-)
      (set i (inv i))
   ) ())
   (while i (
      (set r (mod(i ten)))
      (set s ((clone-rope(digit r) s)))
      (set i (div(i ten)))
   ))
   (if s () (set s 0))
   (clone-rope (sign s))
));

tokenize-file := λpath. (
   tokenize (load-file path)
);

#returns (lhs rhs)
parse-lambda := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (local lmb)
   (set lmb (head er))
   (set toks (tail er))
   (match lmb (
      ()
      ((Literal \,) (
         (set lmb (Nil (parse-many-expressions toks)))
         (set toks ())
      ))
   ))
   (while toks (
      (set er (parse-one-expression toks))
      (match er (
         ()
         (((Literal \,) r) (
            (set lmb (lmb (parse-many-expressions r)))
            (set toks ())
         ))
         ((e ()) (
            (set lmb (lmb e))
            (print-s (ExpectedLambdaRhs lmb))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))
   lmb
));

parse-one-expression := λtoks. (tail(
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set expr (Lambda (parse-lambda r)))
         (set remainder ())
      ))
      ( ( \] r ) (
         (print-s (DANGLING_PARENTHESES toks))
         (set remainder ())
      ))
      ( ( \[ r ) (
         (local depth)
         (set depth 1)
         (local nested)
         (while depth (
            (if r (
               (local next)
               (set next (head r))
               (set r (tail r))
               (match next (
                  ()
                  ( \[ (
                     (set nested (nested next))
                     (set depth (1 depth))
                  ))
                  ( \] (
                     (set depth (tail depth))
                     (if depth (
                        (set nested (nested next))
                     ) ())
                  ))
                  ( _ (
                     (set nested (nested next))
                  ))
               ))
            ) (
               (print-s UNCLOSED_PARENTHESES)
               (set depth ())
            ))
         ))
         (set expr (parse-many-expressions (reverse-list nested)))
         (set remainder r)
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is_variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

print-ctx := λctx. (
   while ctx (
      (print-s (tail ctx))
      (set ctx (head ctx))
   )
);

get-local := λctx v. (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (Global(l body)) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r15 \n
                     \t 'mov \s '0 \[ %r15 \] , \s %r12 \n
                     \t 'mov \s '8 \[ %r15 \] , \s %r13 \n
                     \t 'mov \s '16 \[ %r15 \] , \s %r14 \n
                     \t 'mov \s '24 \[ %r15 \] , \s %r15 \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (print-s (ReferenceToUndefinedLocal v))
   ))
   r
));
get-global := λctx v. (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Global(name body)) (
            if r () (
               if (eq(name v)) (
                  (set r (Global(name body)))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   r
));
set-local := λctx v. (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local((Set l) lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (Global(l body)) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r8 \n
                     \t 'mov \s %r12 , \s '0 \[ %r8 \] \n
                     \t 'mov \s %r13 , \s '8 \[ %r8 \] \n
                     \t 'mov \s %r14 , \s '16 \[ %r8 \] \n
                     \t 'mov \s %r15 , \s '24 \[ %r8 \] \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (print-s (AssignToUndefinedLocal v))
   ))
   r
));

parse-many-expressions := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (local return)
   (set return (head er))
   (local remainder)
   (set remainder (tail er))
   (while remainder (
      (set er (parse-one-expression remainder))
      (set return (App (return (head er))))
      (set remainder (tail er))
   ) (head er))
   return
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local key)
   (local rhs)
   (foreach-atom toks (
      (local a)
      (set a $_)
      (if (eq(a \:)) (
         (if key (
            (set program (program (Global (key (parse-many-expressions (reverse-list rhs))))))
            (set key ())
         ) ())
         (set rhs ())
      ) (
         (if a (set rhs (rhs a)) ())
         (match rhs (
            ()
            ( (((() k) ':) =) (
               (set key k)
               (set rhs ())
            ))
            ( _ () )
         ))
      ))
   ))
   (if key (
     (set program (program (Global (key (parse-many-expressions (reverse-list rhs))))))
   ) ())
   program
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
destructure-args := λctx e offset. (match e (
   ()
   ( Nil (tail(
      ()
      (Expr( () () () () () ctx offset ))
   )))
   ( (Variable n) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( ( (App( h t )) ) (tail(
      (local ta)
      (set ta (destructure-args(ctx t offset)))
      (set offset (get-offset ta))
      (set ctx (get-pc ta))
      (local ha)
      (set ha (destructure-args(ctx h offset)))
      (set offset (get-offset ha))
      (set ctx (get-pc ha))
      (local prog)
      (set prog (prog (_shadow-this()) ))
      (set prog (prog (\t 'call \s 'tail \n) ))
      (set prog (prog (get-prog ta) ))
      (set prog (prog (_unshadow-this()) ))
      (set prog (prog (\t 'call \s 'head \n) ))
      (set prog (prog (get-prog ha) ))
      (Expr(
         ( (get-frame ta) (get-frame ha) )
         prog
         ( (get-unframe ta) (get-unframe ha) )
         () () ctx offset
      ))
   )))
   ( _ (
      (print-s (InvalidFunctionParameters e))
   ))
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (': (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program ':))
      )))
      (= (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program =))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

reverse-list := λl. (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is_variable := λv. (tail(
   (local is_variable)
   (local passed_char)
   (foreach-char v (
      (local c)
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_variable True) (set passed_char True) ))
         ('_ ( (set is_variable True) (set passed_char True) ))
         ('a ( (set is_variable True) (set passed_char True) ))
         ('b ( (set is_variable True) (set passed_char True) ))
         ('c ( (set is_variable True) (set passed_char True) ))
         ('d ( (set is_variable True) (set passed_char True) ))
         ('e ( (set is_variable True) (set passed_char True) ))
         ('f ( (set is_variable True) (set passed_char True) ))
         ('g ( (set is_variable True) (set passed_char True) ))
         ('h ( (set is_variable True) (set passed_char True) ))
         ('i ( (set is_variable True) (set passed_char True) ))
         ('j ( (set is_variable True) (set passed_char True) ))
         ('k ( (set is_variable True) (set passed_char True) ))
         ('l ( (set is_variable True) (set passed_char True) ))
         ('m ( (set is_variable True) (set passed_char True) ))
         ('n ( (set is_variable True) (set passed_char True) ))
         ('o ( (set is_variable True) (set passed_char True) ))
         ('p ( (set is_variable True) (set passed_char True) ))
         ('q ( (set is_variable True) (set passed_char True) ))
         ('r ( (set is_variable True) (set passed_char True) ))
         ('s ( (set is_variable True) (set passed_char True) ))
         ('t ( (set is_variable True) (set passed_char True) ))
         ('u ( (set is_variable True) (set passed_char True) ))
         ('v ( (set is_variable True) (set passed_char True) ))
         ('w ( (set is_variable True) (set passed_char True) ))
         ('x ( (set is_variable True) (set passed_char True) ))
         ('y ( (set is_variable True) (set passed_char True) ))
         ('z ( (set is_variable True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_variable
));

label-case := λk. (tail(
   (local nk)
   (foreach-char k (match $_ (
      ()
      ('- (set nk (nk '_)))
      (c (set nk (nk (clone-rope c))))
   )))
   (clone-rope nk)
));

assemble := λconfig program. (
   (local target)
   (set target 'tmp\,s)
   (while config (
      (match (tail config) (
         ()
         ((Target t) (set target t))
      ))
      (set config (head config))
   ))
   (local output_p)
   (local output_d)
   (local has_main)
   (set output_p (_program-header()))
   (set output_d (_data-header()))
   (local main-ctx)
   (set main-ctx program)
   (local e)
   (local e2)
   (local offset)
   (local inner-ctx)

   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set program pc)
         (set offset ())
         (set output_p (output_p ('main: \n)))
         (set output_p (output_p (_before-main())))
         (set output_p (output_p (_enter-function())))
         (set e (compile-expr(main-ctx body offset Unused)))
         (set output_p (output_p (get-frame e)))
         (set output_p (output_p (get-prog e)))
         (set output_p (output_p (get-unframe e)))
         (set output_p (output_p (_exit-cleanup())))
         (set output_p (output_p (get-text e)))
         (set output_d (output_d (get-data e)))
         (set has_main True)
      ))
      ( (pc (Global (fname body))) (
         (set program pc)
         (set offset ())
         (set inner-ctx main-ctx)
         (match body (
            ()
            ( Nil (
               (set output_d (output_d( (label-case fname) ': \n \t '\,zero \s '32 \n )))
            ))
            ( (Lambda(lhs rhs)) (
               (set e (destructure-args(inner-ctx lhs offset)))
               (set offset (get-offset e))
               (set inner-ctx (get-pc e))
               (set e2 (compile-expr(inner-ctx rhs offset Used)))
               (set output_p (output_p ((label-case fname) ': \n)))
               (set output_p (output_p (_enter-function())))
               (set output_p (output_p (get-frame e)))
               (set output_p (output_p (get-frame e2)))
               (set output_p (output_p (get-prog e)))
               (set output_p (output_p (get-prog e2)))
               (set output_p (output_p (get-unframe e)))
               (set output_p (output_p (get-unframe e2)))
               (set output_p (output_p (_exit-function())))
               (set output_p (output_p (get-text e)))
               (set output_p (output_p (get-text e2)))
               (set output_d (output_d (get-data e)))
               (set output_d (output_d (get-data e2)))
            ))
         ))
      ))
   )))

   (if has_main () (
      (set output_p (output_p ('main: \n)))
      (set output_p (output_p (_exit-cleanup())))
   ))

   (write-file (target (clone-rope (output_p output_d))))
);

is-builtin := λf. (match f (
   ()
   ('eq True)
   ('not True)
   ('head True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('add True)
   ('mul True)
   ('div True)
   ('mod True)
   ('inv True)
   ('is-neg True)
   ('digit True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

get-frame := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

escape-sequences := λt. match t (
   ()
   ( () () )
   ( \\ \\\\ )
   ( \\: \: )
   ( \\o \o )
   ( \\n (\\ 'n))
   ( \\t \t )
   ( \\s \s )
   ( \\l \l )
   ( \\[ \[ )
   ( \\] \] )
   ( (l r) ( (escape-sequences l) (escape-sequences r) ) )
   ( s (tail(
      (local c)
      (local cs)
      (local is_escape)
      (foreach-char s (
         (set c $_)
         (match c (
            ()
            ( " (
               (set cs (cs \\ "))
               (set is_escape ())
            ))
            (\\ (
               (if is_escape (
                 (set cs ( cs \\\\ ))
                 (set is_escape ())
               ) (set is_escape True))
            ))
            (_ (
               (if is_escape (
                  (match c (
                     ()
                     ( , (set cs (cs \,)))
                     ( _ (print-s( InvalidEscapeCharacter (c s) )))
                  ))
               ) (set cs (cs (clone-rope c))))
               (set is_escape ())
            ))
         ))
      ))
      (clone-rope cs)
   )))
);

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
yield-atom := λctx a offset. (tail(
   (local id)
   (set id (uuid()))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
       \t 'mov \s '$0, \s '%r14    \n # $_.$3 = 0, .tail
       \t 'mov \s '$0, \s '%r15    \n # $_.$4 = 0, .flags
      )
      ()
      ()
      (id ': \n \t '\,ascii \s " (escape-sequences a) " \n \t '\,zero \s 1 \n)
      ctx
      offset
   ))
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
declare-local := λctx vname offset. (tail(
   (local frame_this)
   (set frame_this (_push-zero()))
   (local unframe_this)
   (set unframe_this (_unpush-this()))
   (local refer)
   (local eight)
   (set eight (
      inc(inc(inc(inc(inc(inc(inc(inc(
         ()
      ))))))))    
   ))
   (local sixteen)
   (set sixteen (mul( eight (inc(inc(()))) )))
   (local twentyfour)
   (set twentyfour ( mul( eight (inc(inc(inc(())))) ) ))
   (local thirtytwo)
   (set thirtytwo ( mul( eight (inc(inc(inc(inc(()))))) ) ))
   (local set_this)
   (set set_this (
      \t 'mov \s '%r12, \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r13, \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r14, \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) twentyfour)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r15, \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) thirtytwo)) (dec(())) )) ))
      ) \[ '%rbp \] \n
   ))
   (set refer (
      \t 'mov \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] , %r12 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] , %r13 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) twentyfour)) (dec(())) )) ))
      ) \[ '%rbp \] , %r14 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( thirtytwo offset )) thirtytwo)) (dec(())) )) ))
      ) \[ '%rbp \] , %r15 \n
   ))
   (set ctx (ctx (Local(vname refer)) ))
   (set ctx (ctx (Local((Set vname) set_this)) ))
   (Expr(frame_this set_this unframe_this () () ctx (inc offset)))
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
destructure-pattern-lhs := λctx lhs offset. (tail(
   (local e1)
   (local e1_frame)
   (local e1_prog)
   (local e1_unframe)
   (local e1_text)
   (local e1_data)
   (local e2)
   (local e2_frame)
   (local e2_prog)
   (local e2_unframe)
   (local e2_text)
   (local e2_data)
   (local prog)
   (local label_skip)
   (match lhs (
      ()
      ( (Variable '_) (tail(
         ()
         (Expr( () (\t 'mov \s '$1, \s %rsi \n) () () () ctx offset ))
      )))
      ( (Variable v) (tail(
         (set e1 (declare-local(ctx v offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (Expr( e1_frame (e1_prog \t 'mov \s '$1, \s %rsi \n) e1_unframe e1_text e1_data ctx offset ))
      )))
      ( (Literal l) (tail(
         (set e1 (yield-atom(ctx l offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set label_skip (uuid()))
         (set prog (prog (_push-this())))
         (set prog (prog (\t 'mov \s %r12, \s %rax \n)))
         (set prog (prog e1_prog))
         (set prog (prog (\t 'mov \s %r12, \s %rbx \n)))
         (set prog (prog (\t 'call \s '_streq \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s %rsi \n)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (_pop-this())))
         (Expr( e1_frame prog e1_unframe e1_text e1_data ctx offset ))
      )))
      ( Nil (tail(
         (set label_skip (uuid()))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r14 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s %rsi \n)))
         (set prog (prog (label_skip ': \n)))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( l r )) (tail(
         (set e1 (destructure-pattern-lhs(ctx l offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (destructure-pattern-lhs(ctx r offset)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (set label_skip (uuid()))
         (set prog (prog (\t 'mov \s '$0, \s %rsi \n)))
         (set prog (prog (_push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (_head())))
         (set prog (prog e1_prog))
         (set prog (prog (_pop-this())))
         (set prog (prog (_push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %rsi \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$0, \s %rsi \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r14 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (_tail())))
         (set prog (prog e2_prog))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (_pop-this())))
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      (_ (print-s (UnexpectedPattern lhs)))
   ))
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
yield-patterns := λctx p offset. match p (
   ()
   ( Nil (tail(
      ()
      (Expr( () (\t 'mov \s '$0, \s %rsi \n) () () () ctx offset ))
   )))
   ( (App( prev (App( lhs rhs )) )) (tail(
      (local e1)
      (local e1_frame)
      (local e1_prog)
      (local e1_unframe)
      (local e1_text)
      (local e1_data)
      (local e2)
      (local e2_frame)
      (local e2_prog)
      (local e2_unframe)
      (local e2_text)
      (local e2_data)
      (local e3)
      (local e3_frame)
      (local e3_prog)
      (local e3_unframe)
      (local e3_text)
      (local e3_data)
      (local prog)
      (set e1 (yield-patterns(ctx prev offset)))
      (set e1_frame (get-frame e1))
      (set e1_prog (get-prog e1))
      (set e1_unframe (get-unframe e1))
      (set e1_text (get-text e1))
      (set e1_data (get-data e1))
      (set ctx (get-pc e1))
      (set offset (get-offset e1))
      (set e2 (destructure-pattern-lhs(ctx lhs offset)))
      (set e2_frame (get-frame e2))
      (set e2_prog (get-prog e2))
      (set e2_unframe (get-unframe e2))
      (set e2_text (get-text e2))
      (set e2_data (get-data e2))
      (set ctx (get-pc e2))
      (set offset (get-offset e2))
      (set e3 (compile-expr(ctx rhs offset Used)))
      (set e3_frame (get-frame e3))
      (set e3_prog (get-prog e3))
      (set e3_unframe (get-unframe e3))
      (set e3_text (get-text e3))
      (set e3_data (get-data e3))
      (set ctx (get-pc e3))
      (set offset (get-offset e3))
      (local label_skip)
      (set label_skip (uuid()))
      (set prog (prog e1_prog))
      (set prog (prog (\t 'cmp \s '$0, \s %rsi \n)))
      (set prog (prog (\t 'jne \s label_skip \n)))
      (set prog (prog e2_prog))
      (set prog (prog (\t 'cmp \s '$0, \s %rsi \n)))
      (set prog (prog (\t 'je \s label_skip \n)))
      (set prog (prog e3_prog))
      (set prog (prog (\t 'mov \s '$1, \s %rsi \n)))
      (set prog (prog (label_skip ': \n)))
      (Expr( (e1_frame e2_frame e3_frame) prog (e1_unframe e2_unframe e3_unframe) (e1_text e2_text e3_text) (e1_data e2_data e3_data) ctx offset ))
   )))
   ( _ (
      (print-s (InvalidPatternsCase p))
   ))
);

yield-cons := λctx l r offset used. (tail(
   (local e1)
   (local e1_frame)
   (local e1_prog)
   (local e1_unframe)
   (local e1_text)
   (local e1_data)
   (local e2)
   (local e2_frame)
   (local e2_prog)
   (local e2_unframe)
   (local e2_text)
   (local e2_data)
   (local prog)
   (match used (
      ()
      ( Used (tail(
         (set e1 (compile-expr(ctx l offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx r offset Used)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (set prog (prog (e1_prog)))
         (set prog (prog (_push-this())))
         (set prog (prog (e2_prog)))
         (set prog (prog (_close-this())))
         (set prog (prog (\t 'mov \s '%rsi, \s '%rdi \n)))
         (set prog (prog (_pop-this())))
         (set prog (prog (_close-this())))
         (set prog (prog (\t 'mov \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'mov \s '%rsi, \s '%r13 \n)))
         (set prog (prog (\t 'mov \s '%rdi, \s '%r14 \n)))
         (set prog (prog (\t 'mov \s '$0, \s '%r15 \n)))
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      ( _ (tail(
         (local rused)
         (set rused ( if (eq(used Tail)) Used Unused ))
         (set e1 (compile-expr(ctx l offset Unused)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx r offset rused)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (Expr( (e1_frame e2_frame) (e1_prog e2_prog) (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))   
      )))
   ))
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
compile-expr := λctx e offset used. (tail(
   (local x)
   (local e1)
   (local e1_frame)
   (local e1_prog)
   (local e1_unframe)
   (local e1_text)
   (local e1_data)
   (local e2)
   (local e2_frame)
   (local e2_prog)
   (local e2_unframe)
   (local e2_text)
   (local e2_data)
   (local e3)
   (local e3_frame)
   (local e3_prog)
   (local e3_unframe)
   (local e3_text)
   (local e3_data)
   (local prog)
   (local tail_safe)
   (local return)
   (set return (match e (
      ()
      ( (Variable '$_) (tail(
         ()
         (Expr( () () () () () ctx offset ))
      )))
      ( (App( (Variable 'eq) (App( l r )) )) (tail(
         (set e1 (compile-expr(ctx l offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx r offset Used)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (set prog (
            e1_prog
            \t 'push \s '%r12                      \n
            e2_prog
            \t 'mov \s '%r12, \s '%rax             \n
            \t 'pop \s '%rbx                       \n
            \t 'call \s '_streq                    \n
         ))
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      ( (App ((Variable 'local) (Variable fname))) (tail(
         ()
         (set e1 (declare-local(ctx fname offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set tail_safe True)
         (Expr( e1_frame ((_yield-nil()) e1_prog) e1_unframe e1_text e1_data ctx offset ))
      )))
      ( (App( (App( (Variable 'set) (Variable vname) )) x )) (tail(
         ()
         (set e1 (compile-expr(ctx x offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set prog e1_prog)
         (set prog (prog (set-local(ctx vname))))
         (set tail_safe True)
         (Expr( e1_frame prog e1_unframe e1_text e1_data ctx offset ))
      )))
      ( (App( (App( (Variable 'match) t )) p )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (yield-patterns(ctx p offset)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (local label_skip)
         (set label_skip (uuid()))
         (set prog (e1_prog e2_prog))
         (set prog (prog ( \t 'cmp \s '$0, \s %rsi \n )))
         (set prog (prog ( \t 'jne \s label_skip \n )))
         (set prog (prog (_yield-nil())))
         (set prog (prog ( label_skip ': \n )))
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      ( (App( (App( (Variable 'foreach-atom) t )) d )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx d offset Unused)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (local foreach_atom_label)
         (set foreach_atom_label (uuid()))
         (local foreach_atom_notcons)
         (set foreach_atom_notcons (uuid()))
         (local foreach_atom_ignore)
         (set foreach_atom_ignore (uuid()))
         (local foreach_text)
         (set foreach_text (yield-foreach-atom( foreach_atom_label foreach_atom_notcons foreach_atom_ignore e2_prog )))
         (set prog ( e1_prog \t 'call \s foreach_atom_label \n ))
         (set tail_safe True)
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text foreach_text) (e1_data e2_data) ctx offset ))
      )))
      ( (App( (App( (Variable 'foreach-char) t )) d )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx d offset Unused)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (local foreach_char_head)
         (set foreach_char_head (uuid()))
         (local foreach_char_small)
         (set foreach_char_small (uuid()))
         (local foreach_char_end)
         (set foreach_char_end (uuid()))
         (local foreach_char_notcons)
         (set foreach_char_notcons (uuid()))
         (local foreach_char_data)
         (set foreach_char_data (uuid()))
         (local foreach_char_apply)
         (set foreach_char_apply (uuid()))
         (local foreach_data)
         (set foreach_data ( foreach_char_data ': \n \t '\,zero \s '2 \n ))
         (local foreach_text)
         (set foreach_text (yield-foreach-char( foreach_char_data foreach_char_head foreach_char_small foreach_char_end foreach_char_notcons foreach_char_apply e2_prog )))
         (set prog ( e1_prog \t 'call \s foreach_char_head \n ))
         (set tail_safe True)
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text foreach_text) (e1_data e2_data foreach_data) ctx offset ))
      )))
      ( (App( (App( (Variable 'while) c )) d )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx d offset Unused)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (local label_while_start)
         (set label_while_start (uuid()))
         (local label_while_end)
         (set label_while_end (uuid()))
         (set prog (prog (label_while_start ': \n)))
         (set prog (prog e1_prog))
         (set prog (prog (\t 'mov \s '$0, \s %rax \n)))
         (set prog (prog (\t 'add \s %r12, \s %rax \n)))
         (set prog (prog (\t 'add \s %r13, \s %rax \n)))
         (set prog (prog (\t 'add \s %r14, \s %rax \n)))
         (set prog (prog (\t 'add \s %r15, \s %rax \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %rax \n)))
         (set prog (prog (\t 'je \s label_while_end \n)))
         (set prog (prog e2_prog))
         (set prog (prog (\t 'jmp \s label_while_start \n)))
         (set prog (prog (label_while_end ': \n)))
         (set tail_safe True)
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      ( (App( (App( (App( (Variable 'if) c )) t )) f )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx t offset Used)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (set e3 (compile-expr(ctx f offset Used)))
         (set e3_frame (get-frame e3))
         (set e3_prog (get-prog e3))
         (set e3_unframe (get-unframe e3))
         (set e3_text (get-text e3))
         (set e3_data (get-data e3))
         (set ctx (get-pc e3))
         (set offset (get-offset e3))
         (local label_if_true)
         (set label_if_true (uuid()))
         (local label_if_end)
         (set label_if_end (uuid()))
         (set prog (prog e1_prog))
         (set prog (prog ( \t 'cmp \s '$0, '%r12 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r13 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r14 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog e3_prog))
         (set prog (prog ( \t 'jmp \s label_if_end \n )))
         (set prog (prog ( label_if_true ': \n )))
         (set prog (prog e2_prog))
         (set prog (prog ( label_if_end ': \n )))
         (Expr( (e1_frame e2_frame e3_frame) prog (e1_unframe e2_unframe e3_unframe) (e1_text e2_text e3_text) (e1_data e2_data e3_data) ctx offset ))
      )))
      ( (App ((Variable fname) arg)) (tail(
         ()
         (if (is-builtin fname) (tail(
            ()
            (if (eq(fname 'tail)) (tail(
               (set x (compile-expr(ctx arg offset Tail)))
               (set prog (get-prog x))
               (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
            )) (tail(
               (set x (compile-expr(ctx arg offset Used)))
               (set prog (get-prog x))
               (set prog (prog (\t 'call \s (label-case fname) \n)))
               (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
            )))
         )) (tail(
            ()
            (match (get-global(ctx fname)) (
               ()
               ( (Global (f body)) (tail(
                  ()
                  (set x (compile-expr(ctx arg offset Used)))
                  (set prog (get-prog x))
                  (set prog (prog (\t 'call \s (label-case fname) \n)))
                  (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
               )))
               ( _ (tail(
                  ()
                  (yield-cons(ctx (Variable fname) arg offset Used))
               )))
            ))
         )))
      )))
      ( (Literal l) (tail(
         ()
         (yield-atom (ctx l offset))
      )))
      ( (Variable 'argv) (tail(
         (set prog (prog ( \t 'mov \s '$__argv, \s '%rax \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%rax \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%rax \] , '%r13 \n )))
         (set prog (prog ( \t 'mov \s '16 \[ '%rax \] , '%r14 \n )))
         (set prog (prog ( \t 'mov \s '24 \[ '%rax \] , '%r15 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App (l r)) (tail(
         ()
         (set tail_safe True)
         (yield-cons(ctx l r offset used))
      )))
      ( Nil (tail(
         (set prog (prog ( \t 'mov \s '$0 , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r13 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r14 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r15 \n )))
         (set tail_safe True)
         (Expr( () prog () () () ctx offset ))
      )))
      ( (Variable vname) (tail(
         (set prog (get-local(ctx vname)))
         (Expr( () prog () () () ctx offset ))
      )))
      (x (print-s (TODO x)) )
   )))
   (if tail_safe return (tail(
      ()
      (if (eq(used Tail)) (tail(
         (set prog (get-prog return))
         (set prog (prog (\t 'call \s 'tail \n)))
         (Expr( (get-frame return) prog (get-unframe return) (get-text return) (get-data return) (get-pc return) (get-offset return) ))
      )) (
         return
      ))
   )))
));

_data-header := λ.(
  '\,data                              \n
  'load_file_bsz:                      \n
  \t '\,quad \s '1024                  \n
  'load_file_buf:                      \n
  \t '\,zero \s '1024                  \n
  '__nil:                              \n
  \t '\,zero \s '32                      \n
  '__argv:                             \n
  \t '\,zero \s '32                    \n
  '__s_counter:                        \n
  \t '\,zero \s '8                     \n
  '__s_section:                        \n
  \t '\,zero \s '536870912             \n
  '__a_counter:                        \n
  \t '\,zero \s '8                     \n
  '__a_section:                        \n
  \t '\,zero \s '536870912             \n
  '__nil_literal:                      \n
  \t '\,ascii \s " \[ \] "             \n
  \t '\,zero \s 1                      \n
  '__hex_buffer:                       \n
  \t '\,ascii \s "0123456789abcdef"    \n
  '__put64_buffer:                     \n
  \t '\,ascii \s "0x"                  \n
  '__put64_write_buffer:               \n
  \t '\,ascii \s "0000000000000000 \s "  \n
  \t '\,zero \s '1                     \n
  '__newline:                          \n
  \t '\,ascii \s " \\n "               \n
  '__lparen:                           \n
  \t '\,ascii \s " \[ "                \n
  '__rparen:                           \n
  \t '\,ascii \s " \] "                \n
  '__space:                            \n
  \t '\,ascii \s " \s "                \n
  '__true:                             \n
  \t '\,ascii \s "True"                \n
  \t '\,zero \s '1                     \n
  '__digit:                            \n
  \t '\,zero \s '2                     \n
  '__dump_i:                           \n
  \t '\,ascii \s '"0000000000000000"   \n
  \t '\,zero \s '1                     \n
  '__err_fopen:                        \n
  \t '\,ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t '\,zero \s '1                       \n
);

_exit-cleanup := λ.(
   \t 'mov \s '$60, \s '%eax           \n # _exit system call
   \t 'mov \s '$0, \s '%edi            \n # error code 0
   \t 'syscall                         \n
);

_before-main := λ.(
   # let argv = close ()
   # let t = argv
   # for a in argv:
   #    t.tail = (a ())
   #    t = t.tail
   \t 'pop \s %rax                        \n #argc
   \t 'mov \s '$__argv, \s '%rbx          \n
   \t 'movq \s '$0, \s '0 \[ '%rbx \]     \n
   \t 'movq \s '$0, \s '8 \[ '%rbx \]     \n
   \t 'movq \s '$0, \s '16 \[ '%rbx \]    \n
   \t 'movq \s '$0, \s '24 \[ '%rbx \]    \n

   '__before_main_argv:                   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s '__before_main_end           \n
   \t 'pop \s '%r12                       \n #argv[i]
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n

   #close this (move S onto the heap)
   \t 'mov \s '$__s_section, \s '%rsi     \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8      \n # %r8 now points to s counter
   \t 'mov \s '0 \[ '%r8 \] , \s '%r10     \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi             \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10              \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ '%r8 \]     \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ '%rsi \]    \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ '%rsi \]    \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ '%rsi \]   \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ '%rsi \]   \n # set top.flags
   \t 'mov \s '%rsi, \s '%rdi             \n

   #rdi is a
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n

   \t 'mov \s '$__s_section, \s '%rsi     \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8      \n # %r8 now points to s counter
   \t 'mov \s '0 \[ '%r8 \] , \s '%r10     \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi             \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10              \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ '%r8 \]     \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ '%rsi \]    \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ '%rsi \]    \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ '%rsi \]   \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ '%rsi \]   \n # set top.flags

   #rsi is clean closed ()
   \t 'mov \s '%rdi, \s '8 \[ '%rbx \]    \n
   \t 'mov \s '%rsi, \s '16 \[ '%rbx \]   \n
   \t 'mov \s '%rsi, \s '%rbx             \n
   #rbx is tail of argv
   \t 'dec \s '%rax                       \n
   \t 'jmp \s '__before_main_argv         \n
   '__before_main_end:                    \n
);

_program-header := λ.(
   '\,global \s '_start                   \n
   '\,text                                \n
   '_start:                               \n
   \t 'jmp \s 'main                       \n

   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   '_strlen:                              \n
   \t 'xor \s '%rbx, \s '%rbx             \n
   '_strlen_loop:                         \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]     \n
   \t 'jz \s '_strlen_exit                \n
   \t 'inc \s '%rax                       \n
   \t 'inc \s '%rbx                       \n
   \t 'jmp \s '_strlen_loop               \n
   '_strlen_exit:                         \n
   \t 'ret                                \n
   # result is stored in %rcx

   'digit:                                \n
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'add \s '$48, \s %rax               \n
   \t 'mov \s '$__digit, \s %r12          \n
   \t 'mov \s '%al, \s '0 \[ %r12 \]      \n
   \t 'mov \s '$0, \s %r13                \n
   \t 'mov \s '$0, \s %r14                \n
   \t 'mov \s '$0, \s %r15                \n
   \t 'ret                                \n

   'print_s:                              \n

   # if .atom != NULL 
   '__print_this_atom:                    \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s '__print_this_cons           \n
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'call \s '_strlen                   \n # %rbx is length of string
   \t 'mov \s '%r12, \s '%rsi             \n # address of string to output
   \t 'mov \s '%rbx, \s '%rdx             \n # length is %rcx
   \t 'mov \s '$1, \s '%rax               \n # system call 1 is write
   \t 'mov \s '$1, \s '%rdi               \n # file handle 1 is stdout
   \t 'syscall                            \n # invoke operating system to do the write
   \t 'ret                                \n

   # if .head != NULL && .tail != NULL
   '__print_this_cons:                    \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s '__print_this_nil            \n
   \t 'cmp \s '$0, \s '%r14               \n
   \t 'je \s '__print_this_nil            \n
   \t 'push \s '%r14                      \n
   \t 'push \s '%r13                      \n
   #show lparen
   \t 'mov \s '$1, \s '%rax               \n
   \t 'mov \s '$1, \s '%rdi               \n
   \t 'mov \s '$__lparen, \s '%rsi        \n
   \t 'mov \s '$1, \s '%rdx               \n
   \t 'syscall                            \n
   #show head
   \t 'pop \s '%r8                        \n
   \t 'mov \s '0 \[ '%r8 \] , '%r12       \n
   \t 'mov \s '8 \[ '%r8 \] , '%r13       \n
   \t 'mov \s '16 \[ '%r8 \] , '%r14      \n
   \t 'mov \s '24 \[ '%r8 \] , '%r15      \n
   \t 'call \s 'print_s                   \n
   #show space
   \t 'mov \s '$1, \s '%rax               \n
   \t 'mov \s '$1, \s '%rdi               \n
   \t 'mov \s '$__space, \s '%rsi         \n
   \t 'mov \s '$1, \s '%rdx               \n
   \t 'syscall                            \n
   #show tail
   \t 'pop \s '%r8                        \n
   \t 'mov \s '0 \[ '%r8 \] , '%r12       \n
   \t 'mov \s '8 \[ '%r8 \] , '%r13       \n
   \t 'mov \s '16 \[ '%r8 \] , '%r14      \n
   \t 'mov \s '24 \[ '%r8 \] , '%r15      \n
   \t 'call \s 'print_s                   \n
   #show rparen
   \t 'mov \s '$1, \s '%rax               \n
   \t 'mov \s '$1, \s '%rdi               \n
   \t 'mov \s '$__rparen, \s '%rsi        \n
   \t 'mov \s '$1, \s '%rdx               \n
   \t 'syscall                            \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   '__print_this_nil:                     \n
   \t 'mov \s '$1, \s '%rax               \n # system call 1 is write
   \t 'mov \s '$1, \s '%rdi               \n # file handle 1 is stdout
   \t 'mov \s '$__nil_literal, \s '%rsi   \n # address of string to output
   \t 'mov \s '$2, \s '%rdx               \n # nil is 2 bytes
   \t 'syscall                            \n # invoke operating system to do the write
   \t 'ret                                \n


   'head:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s '__head_is_nil               \n
   \t 'mov \s '0 \[ '%r13 \] ', '%r12     \n
   \t 'mov \s '16 \[ '%r13 \] ', '%r14    \n
   \t 'mov \s '24 \[ '%r13 \] ', '%r15    \n
   \t 'mov \s '8 \[ '%r13 \] ', '%r13     \n
   \t 'ret                                \n
   '__head_is_nil:                        \n
   \t 'mov \s '$0, \s %r12                \n
   \t 'mov \s '$0, \s %r13                \n
   \t 'mov \s '$0, \s %r14                \n
   \t 'mov \s '$0, \s %r15                \n
   \t 'ret                                \n

   'tail:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s '__tail_is_nil               \n
   \t 'mov \s '0 \[ '%r14 \] ', '%r12     \n
   \t 'mov \s '8 \[ '%r14 \] ', '%r13     \n
   \t 'mov \s '24 \[ '%r14 \] ', '%r15    \n
   \t 'mov \s '16 \[ '%r14 \] ', '%r14    \n
   \t 'ret                                \n
   '__tail_is_nil:                        \n
   \t 'mov \s '$0, \s %r12                \n
   \t 'mov \s '$0, \s %r13                \n
   \t 'mov \s '$0, \s %r14                \n
   \t 'mov \s '$0, \s %r15                \n
   \t 'ret                                \n

   'not:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jne \s '__not_is_some              \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'jne \s '__not_is_some              \n
   \t 'cmp \s '$0, \s '%r14               \n
   \t 'jne \s '__not_is_some              \n
   \t 'mov \s '$__true, \s '%r12          \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n
   '__not_is_some:                        \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   # _streq (%rax: *char, %rbx: *char)
   '_streq:                               \n
   '__streq_loop:                         \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s '__streq_false               \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s '__streq_false               \n
   \t 'mov \s '0 \[ %rax \] , \s '%cl     \n
   \t 'mov \s '0 \[ %rbx \] , \s '%dl     \n

   \t 'cmp \s '%cl, \s '%dl               \n
   \t 'jne \s '__streq_false              \n
   \t 'cmp \s '$0, \s '%cl                \n
   \t 'je \s '__streq_true                \n
   \t 'inc \s '%rax                       \n
   \t 'inc \s '%rbx                       \n
   \t 'jmp \s '__streq_loop               \n
   '__streq_true:                         \n
   \t 'mov \s '$__true, \s '%r12          \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n
   '__streq_false:                        \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   'dump_i:                               \n
   \t 'mov \s '%r12, \s '%r8              \n
   \t 'mov \s '$__dump_i, \s '%r12        \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'mov \s '$__dump_i, \s '%r11        \n
   \t 'cmp \s '$0, \s '%r8                \n
   \t 'jge \s 'dump_i_positive            \n
   \t 'jmp \s 'dump_i_negative            \n
   'dump_i_positive:                      \n
   \t 'call \s 'dump_i_digits             \n
   \t 'ret                                \n
   'dump_i_negative:                      \n
   \t 'neg \s '%r8                        \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$45, \s '0 \[ %r11 \]     \n
   \t 'ret                                \n
   # if return value is positive then open was a success

   'dump_i_digits:                        \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[0]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '0 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[1]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '1 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[2]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '2 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[3]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '3 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[4]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '4 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[5]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '5 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[6]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '6 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[7]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '7 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[8]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '8 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[9]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '9 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[10]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '10 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[11]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '11 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[12]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '12 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[13]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '13 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[14]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '14 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[15]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '15 \[ %r11 \]     \n
   \t 'ret                                \n

   #move ascii representation of lower byte of %r8 into %cl
   'put8:                                 \n
   \t 'mov \s '%r8b, \s '%al              \n # lower byte of %r11 goes into %rax
   \t 'and \s '$0xf, \s '%al              \n # only show lower 4 bits
   \t 'mov \s '$__hex_buffer, '%r10       \n # %r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b             \n # %r10 is index into char in hex buffer
   \t 'mov \s '0 \[ %r10 \] , \s '%cl     \n # %cl is a hexadecimal char
   \t 'ret                                \n

   'inc:                                  \n
   \t 'inc \s '%r12                       \n
   \t 'ret                                \n

   'dec:                                  \n
   \t 'dec \s '%r12                       \n
   \t 'ret                                \n

   'inv:                                  \n
   \t 'neg \s '%r12                       \n
   \t 'ret                                \n

   'is_neg:                               \n
   \t 'cmp \s '$0, \s %r12                \n
   \t 'jge \s 'is_neg_ispos               \n
   \t 'mov \s '$1, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n
   'is_neg_ispos:                         \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   'mul:                                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'mul_err                     \n
   \t 'cmp \s '$0, \s '%r14               \n
   \t 'je \s 'mul_err                     \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r14 \] , '%rbx      \n
   \t 'imul \s '%rax, \s '%rbx            \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n
   'mul_err:                              \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   'add:                                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'add_err                     \n
   \t 'cmp \s '$0, \s '%r14               \n
   \t 'je \s 'add_err                     \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r14 \] , '%rbx      \n
   \t 'add \s '%rax, \s '%rbx             \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n
   'add_err:                              \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   'div:                                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'div_err                     \n
   \t 'cmp \s '$0, \s '%r14               \n
   \t 'je \s 'div_err                     \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r14 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n
   'div_err:                              \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   'mod:                                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'mod_err                     \n
   \t 'cmp \s '$0, \s '%r14               \n
   \t 'je \s 'mod_err                     \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r14 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rdx, \s '%r12             \n
   \t 'ret                                \n
   'mod_err:                              \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n

   'clone_rope:                          \n
   \t 'mov \s '$__a_section, \s '%r8     \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '0 \[ %r10 \] , \s '%r11   \n
   \t 'add \s '%r11, \s '%r8             \n
   \t 'mov \s '%r8, \s '%r9              \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   \t 'call \s '__clone_rope             \n
   \t 'movb \s '$0, \s '0 \[ %r9 \]      \n
   \t 'inc \s '%r9                       \n
   \t 'mov \s '$__a_section, \s '%r10    \n
   \t 'sub \s '%r10, \s '%r9             \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '%r9, \s '0 \[ %r10 \]     \n
   \t 'mov \s '%r8, \s '%r12             \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n
   \t 'ret                               \n

   '__clone_rope:                        \n
   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13              \n
   \t 'je \s 'clone_rope_notcons         \n
   \t 'cmp \s '$0, \s '%r14              \n
   \t 'je \s 'clone_rope_notcons         \n
   \t 'push \s '%r12                     \n
   \t 'push \s '%r13                     \n
   \t 'push \s '%r14                     \n
   \t 'push \s '%r15                     \n
   \t 'mov \s '0 \[ %r13 \] , '%r12      \n
   \t 'mov \s '16 \[ %r13 \] , '%r14     \n
   \t 'mov \s '24 \[ %r13 \] , '%r15     \n
   \t 'mov \s '8 \[ %r13 \] , '%r13      \n
   \t 'call \s '__clone_rope             \n
   \t 'pop \s '%r15                      \n
   \t 'pop \s '%r14                      \n
   \t 'pop \s '%r13                      \n
   \t 'pop \s '%r12                      \n
   \t 'mov \s '0 \[ %r14 \] , '%r12      \n
   \t 'mov \s '24 \[ %r14 \] , '%r15     \n
   \t 'mov \s '8 \[ %r14 \] , '%r13      \n
   \t 'mov \s '16 \[ %r14 \] , '%r14     \n
   \t 'push \s '%r12                     \n
   \t 'push \s '%r13                     \n
   \t 'push \s '%r14                     \n
   \t 'push \s '%r15                     \n
   \t 'call \s '__clone_rope             \n
   \t 'pop \s '%r15                      \n
   \t 'pop \s '%r14                      \n
   \t 'pop \s '%r13                      \n
   \t 'pop \s '%r12                      \n
   \t 'jmp \s 'clone_rope_end            \n

   #if not cons, concat
   'clone_rope_notcons:                  \n

   #if nil, return
   \t 'cmp \s '$0, \s '%r12              \n
   \t 'je \s 'clone_rope_end             \n

   #if atom, break into characters and concat
   'clone_rope_small:                    \n
   \t 'cmpb \s '$0, \s '0 \[ %r12 \]     \n
   \t 'je \s 'clone_rope_end             \n
   \t 'movb \s '0 \[ %r12 \] , \s '%bl   \n
   \t 'movb \s '%bl, \s '0 \[ %r9 \]     \n
   \t 'inc \s '%r12                      \n
   \t 'inc \s '%r9                       \n
   \t 'jmp \s 'clone_rope_small          \n

   'clone_rope_end:                      \n
   \t 'ret                               \n

   'write_file:                          \n
   #open file
   \t 'mov \s '0 \[ %r13 \] , \s '%rdi   \n # file name
   \t 'pushq \s '0 \[ %r14 \]            \n # data to write
   \t 'mov \s '$2, \s '%rax              \n # syscall open
   \t 'mov \s '$577, \s %rsi             \n
   \t 'mov \s '$420, \s '%rdx            \n # mode
   \t 'syscall                           \n
   \t 'mov \s '%rax, \s '%r8             \n # r8 now holds file descriptor

   #write to file
   \t 'pop \s '%rax                      \n
   \t 'mov \s '%rax, \s '%r9             \n
   \t 'call \s '_strlen                  \n
   \t 'mov \s '%rbx, \s '%rdx            \n # length to write
   \t 'mov \s '%r9, \s '%rsi             \n # data to write
   \t 'mov \s '%r8, \s '%rdi             \n # file descriptor
   \t 'mov \s '$1, \s '%rax              \n # 'write' system call
   \t 'syscall                           \n

   #close file
   \t 'mov \s '%r8, \s '%rdi             \n # file descriptor
   \t 'mov \s '$3, \s '%rax              \n # close
   \t 'syscall                           \n
   \t 'ret                               \n

   'load_file:                           \n

   # open file
   \t 'mov \s '$2, \s '%rax              \n # syscall open
   \t 'mov \s '%r12, \s '%rdi            \n # file name
   \t 'mov \s '$0, \s '%rsi              \n # read-only mode
   \t 'syscall                           \n
   # file descriptor is in %rax

   \t 'cmp \s '$0, \s '%rax              \n
   # if return value is positive then open was a success
   \t 'jge \s 'load_file_contents        \n

   \t 'mov \s '$__err_fopen, \s '%r12    \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n
   \t 'ret                               \n

   'load_file_contents:                  \n
   \t 'mov \s '$__a_section, \s '%r8     \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '0 \[ %r10 \] , \s '%r11   \n
   \t 'add \s '%r11, \s '%r8             \n
   \t 'mov \s '%r8, \s '%r9              \n
   \t 'mov \s '$0, \s '%r10              \n
   \t 'mov \s '$load_file_buf, \s '%r11  \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   #r10 holds amount of data on buffer currently
   #r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:                      \n
   \t 'cmp \s '$0, \s '%r10              \n
   \t 'je \s 'load_file_bufempty         \n
   \t 'movb \s '0 \[ %r11 \] , \s '%bl   \n
   \t 'mov \s '%bl, \s '0 \[ %r9 \]      \n
   \t 'inc \s '%r9                       \n
   \t 'inc \s '%r11                      \n
   \t 'dec \s '%r10                      \n
   \t 'jmp \s 'load_file_loop            \n

      # read file
   'load_file_bufempty:                  \n
   \t 'push \s '%rax                     \n
   \t 'mov \s '%rax, \s '%rdi            \n # file descriptor
   \t 'mov \s '$0, \s '%rax              \n # read
   \t 'mov \s '$load_file_buf, \s '%rsi  \n # buffer
   \t 'mov \s '$load_file_bsz, \s '%rdx  \n
   \t 'mov \s '0 \[ %rdx \] , \s '%rdx   \n # buffer size
   \t 'syscall                           \n
   \t 'mov \s '%rax, \s '%r10            \n
   \t 'pop \s '%rax                      \n
   \t 'mov \s '$load_file_buf, \s '%r11  \n
   \t 'cmp \s '$0, \s '%r10              \n
   \t 'jne \s 'load_file_loop            \n

   # close file
   \t 'mov \s '%rax, \s '%rdi            \n # file descriptor
   \t 'mov \s '$3, \s '%rax              \n # close
   \t 'syscall                   \n

   \t 'movb \s '$0, \s '0 \[ %r9 \]      \n
   \t 'inc \s '%r9                       \n
   \t 'sub \s '%r8, \s '%r9              \n
   \t 'mov \s '$__a_counter, \s '%r10    \n
   \t 'mov \s '%r9, \s '0 \[ %r10 \]     \n
   \t 'mov \s '%r8, \s '%r12             \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n
   \t 'ret                               \n

);

_push-this := λ.(
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'push \s '%r14                      \n
   \t 'push \s '%r15                      \n
);

_push-zero := λ.(
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
);

_unpush-this := λ.(
   \t 'pop \s '%r8                        \n
   \t 'pop \s '%r8                        \n
   \t 'pop \s '%r8                        \n
   \t 'pop \s '%r8                        \n
);

_pop-this := λ.(
   \t 'pop \s '%r15                       \n
   \t 'pop \s '%r14                       \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
);

_yield-nil := λ.(
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
);

_close-this := λ.(
   # move this S onto the heap
   # %rsi becomes pointer to new location
   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0 \[ %r8 \] , \s '%r10        \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ %r8 \]         \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ %rsi \]        \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ %rsi \]        \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ %rsi \]       \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ %rsi \]       \n # set top.flags
);

_head := λ.(
   \t 'mov \s '0 \[ %r13 \] , \s '%r12       \n
   \t 'mov \s '16 \[ %r13 \] , \s '%r14      \n
   \t 'mov \s '24 \[ %r13 \] , \s '%r15      \n
   \t 'mov \s '8 \[ %r13 \] , \s '%r13       \n
);
_tail := λ.(
   \t 'mov \s '0 \[ %r14 \] , \s '%r12       \n
   \t 'mov \s '24 \[ %r14 \] , \s '%r15      \n
   \t 'mov \s '8 \[ %r14 \] , \s '%r13       \n
   \t 'mov \s '16 \[ %r14 \] , \s '%r14      \n
);

_enter-function := λ.(
   \t 'push \s %rbp                          \n
   \t 'mov \s %rsp, \s %rbp                  \n
);
_exit-function := λ.(
   \t 'mov \s %rbp, \s %rsp                  \n
   \t 'pop \s %rbp                           \n
   \t 'ret                                   \n
);

_shadow-this := λ.(
   \t 'mov \s '%r12, \s '%r8                 \n
   \t 'mov \s '%r13, \s '%r9                 \n
   \t 'mov \s '%r14, \s '%r10                \n
   \t 'mov \s '%r15, \s '%r11                \n
);

_unshadow-this := λ.(
   \t 'mov \s '%r8, \s '%r12                 \n
   \t 'mov \s '%r9, \s '%r13                 \n
   \t 'mov \s '%r10, \s '%r14                \n
   \t 'mov \s '%r11, \s '%r15                \n
);

yield-foreach-atom := λforeach-head foreach-notcons foreach-ignore foreach-apply. (
   #define label for this function
   foreach-head ':                           \n

   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13                  \n
   \t 'je \s foreach-notcons                 \n
   \t 'cmp \s '$0, \s '%r14                  \n
   \t 'je \s foreach-notcons                 \n
   (_push-this())
   (_head())
   \t 'call \s foreach-head                  \n
   (_pop-this())
   (_push-this())
   (_tail())
   \t 'call \s foreach-head                  \n
   (_pop-this())
   \t 'ret                                   \n

   #if not cons, apply
   foreach-notcons ':                        \n
   \t 'cmp \s '$0, \s '%r12                  \n
   \t 'je \s foreach-ignore                  \n
   (_push-this())
   foreach-apply
   (_pop-this())
   \t 'ret                                   \n

   foreach-ignore ':                         \n
   \t 'ret                                   \n
);

yield-foreach-char := λforeach-data foreach-head foreach-small foreach-end foreach-notcons foreach-apply foreach-expr. (
   #define label for this function
   foreach-head ': \n

   #if this is a cons, recurse
   \t 'cmp \s '$0, \s %r13                   \n
   \t 'je \s foreach-notcons                 \n
   \t 'cmp \s '$0, \s '%r14                  \n
   \t 'je \s foreach-notcons                 \n
   (_push-this())
   (_head())
   \t 'call \s foreach-head                  \n
   (_pop-this())
   (_push-this())
   (_tail())
   \t 'call \s foreach-head                  \n
   (_pop-this())
   \t 'ret                                   \n

   #if not cons, apply
   foreach-notcons ':                        \n
   (_push-this())

   #if nil, apply and return
   \t 'mov \s '%r12, \s '%r8                 \n
   \t 'cmp \s '$0, \s '%r12                  \n
   \t 'jne \s foreach-small                  \n
   \t 'call \s foreach-apply                 \n
   (_pop-this())
   \t 'ret                                   \n

   #if atom, break into characters and apply
   foreach-small ':                          \n
   \t 'cmpb \s '$0, \s '0 \[ %r8 \]          \n
   \t 'je \s foreach-end                     \n
   \t 'push \s '%r8                          \n
   \t 'mov \s '$ foreach-data , \s '%r12     \n
   \t 'mov \s '$0, \s '%r13                  \n
   \t 'mov \s '$0, \s '%r14                  \n
   \t 'mov \s '$0, \s '%r15                  \n
   \t 'movb \s '0 \[ %r8 \] , \s '%bl        \n
   \t 'movb \s '%bl, \s '0 \[ %r12 \]        \n
   \t 'movb \s '$0, \s '1 \[ %r12 \]         \n
   \t 'call \s foreach-apply                 \n
   \t 'pop \s '%r8                           \n
   \t 'inc \s '%r8                           \n
   \t 'jmp \s foreach-small                  \n

   foreach-end ':                            \n
   (_pop-this())
   \t 'ret                                   \n

   foreach-apply ':                          \n
   foreach-expr
   \t 'ret                                   \n
);
