
main := (
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (local config)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config (config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Compile (
         (foreach-atom inputs (
            (set arg $_)
            (if arg (
               (assemble (config (parse-program (tokenize (load-file arg)))))
            ) ())
         ))
      ))
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
);

$uuid := ();
uuid := λ. (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

tokenize-file := λpath. (
   tokenize (load-file path)
);

parse-lambda := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (match er (
      ()
      (((Literal .) r) (() (parse-many-expressions r)))
      ((e r) (tail(
         (local lr)
         (set lr (parse-lambda r))
         (if (head lr)
             ( (e (head lr)) (tail lr) )
             ( e (tail lr) )
         )
      )))
   ))
));

parse-one-expression := λtoks. (tail(
   (local remainder)
   (local is_lambda)
   (local expr)
   (local is_literal)
   (local is_grouped)
   (local grouped_tokens)
   (foreach-atom toks (
      (local c)
      (set c $_)
      (if expr (set remainder (remainder c)) (
      (if is_grouped (
         #grouped
         (match c (
            ()
            (() ())
            ( \[ (
               (set grouped_tokens (grouped_tokens \[))
               (set is_grouped (\[ is_grouped))
            ))
            ( \] (
               (set is_grouped (tail is_grouped))
               (if is_grouped (
                  (set grouped_tokens (grouped_tokens \]))
               ) (
                  (set expr (parse-many-expressions grouped_tokens))
                  (set grouped_tokens ())
               ))
            ))
            ( a (
               (set grouped_tokens (grouped_tokens a))
            ))
         ))
      ) (
         #not grouped
         (match c (
            ()
            (() ())
            ( \l ((set is_lambda True) (set expr INVALID)))
            ( \' (set is_literal True))
            ( \[ (
               (set is_grouped (\[ is_grouped))
            ))
            ( \] (
               (print-s DANGLING_PARENTHESES)
            ))
            ( a (
               (if is_literal (
                  (set expr (Literal a))
                  (set is_literal ())
               ) (
                  (if (is_variable a)
                     (set expr (Variable a))
                     (set expr (Literal a))
                  )
              ))
            ))
         ))
      ))
      ))
   ))
   (if expr () (set expr Nil))
   (if is_lambda
      ((Lambda (parse-lambda remainder)) ())
      (expr remainder)
   )
));

parse-many-expressions := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (local return)
   (set return (head er))
   (local remainder)
   (set remainder (tail er))
   (while remainder (
      (set er (parse-one-expression remainder))
      (set return (App (return (head er))))
      (set remainder (tail er))
   ) (head er))
   return
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local key)
   (local rhs)
   (foreach-atom toks (
      (local a)
      (set a $_)
      (if (eq(a \:)) (
         (if key (
            (set program (program (Global (key (parse-many-expressions rhs)))))
            (set key ())
         ) ())
         (set rhs ())
      ) (
         (if a (set rhs (rhs a)) ())
         (match rhs (
            ()
            ( (((() k) ':) =) (
               (set key k)
               (set rhs ())
            ))
            ( _ () )
         ))
      ))
   ))
   (if key (
     (set program (program (Global (key (parse-many-expressions rhs)))))
   ) ())
   program
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program '))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (': (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program ':))
      )))
      (= (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program =))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   program
));

is_variable := λv. (tail(
   (local is_variable)
   (local passed_char)
   (foreach-char v (
      (local c)
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_variable True) (set passed_char True) ))
         ('_ ( (set is_variable True) (set passed_char True) ))
         ('a ( (set is_variable True) (set passed_char True) ))
         ('b ( (set is_variable True) (set passed_char True) ))
         ('c ( (set is_variable True) (set passed_char True) ))
         ('d ( (set is_variable True) (set passed_char True) ))
         ('e ( (set is_variable True) (set passed_char True) ))
         ('f ( (set is_variable True) (set passed_char True) ))
         ('g ( (set is_variable True) (set passed_char True) ))
         ('h ( (set is_variable True) (set passed_char True) ))
         ('i ( (set is_variable True) (set passed_char True) ))
         ('j ( (set is_variable True) (set passed_char True) ))
         ('k ( (set is_variable True) (set passed_char True) ))
         ('l ( (set is_variable True) (set passed_char True) ))
         ('m ( (set is_variable True) (set passed_char True) ))
         ('n ( (set is_variable True) (set passed_char True) ))
         ('o ( (set is_variable True) (set passed_char True) ))
         ('p ( (set is_variable True) (set passed_char True) ))
         ('q ( (set is_variable True) (set passed_char True) ))
         ('r ( (set is_variable True) (set passed_char True) ))
         ('s ( (set is_variable True) (set passed_char True) ))
         ('t ( (set is_variable True) (set passed_char True) ))
         ('u ( (set is_variable True) (set passed_char True) ))
         ('v ( (set is_variable True) (set passed_char True) ))
         ('w ( (set is_variable True) (set passed_char True) ))
         ('x ( (set is_variable True) (set passed_char True) ))
         ('y ( (set is_variable True) (set passed_char True) ))
         ('z ( (set is_variable True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_variable
));

label-case := λk. (tail(
   (local nk)
   (foreach-char k (match $_ (
      ()
      (- (set nk (nk '_)))
      (c (set nk (nk (clone-rope c))))
   )))
   (clone-rope nk)
));

assemble := λconfig program. (
   (local target)
   (set target 'tmp.s)
   (while config (
      (match (tail config) (
         ()
         ((Target t) (set target t))
      ))
      (set config (head config))
   ))
   (local output_p)
   (local output_d)
   (local has_main)
   (set output_p (_program-header()))
   (set output_d (_data-header()))
   (local main_ctx)
   (set main_ctx program)
   (local e)

   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set program pc)
         (set output_p (output_p ('main: \n)))
         (set output_p (output_p (_before-main())))
         (set output_p (output_p (_enter-function())))
         (set e (compile-expr(main_ctx body 0)))
         (set output_p (output_p (get-frame e)))
         (set output_p (output_p (get-prog e)))
         (set output_p (output_p (get-unframe e)))
         (set output_p (output_p (get-text e)))
         (set output_p (output_p (_exit-cleanup())))
         (set output_d (output_d (get-data e)))
         (set has_main True)
      ))
      ( (pc (Global (fname body))) (
         (set program pc)
         (set fname (label-case fname))
         (print-s (F fname body))
         (set output_p (output_p (fname ': \n)))
         (set output_p (output_p (_enter-function())))
         (set e (compile-expr(main_ctx body 0)))
         #TODO unpack expression $body
      ))
   )))

   (if has_main () (
      (set output_p (output_p ('main: \n)))
      (set output_p (output_p (_exit-cleanup())))
   ))

   (write-file (target (clone-rope (output_p output_d))))
);

is-builtin := λf. (match f (
   ()
   ('eq True)
   ('not True)
   ('head True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('mul True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

get-frame := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
yield-atom := λctx a offset. (tail(
   (local id)
   (set id (uuid()))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
       \t 'mov \s '$0, \s '%r14    \n # $_.$3 = 0, .tail
       \t 'mov \s '$0, \s '%r15    \n # $_.$4 = 0, .flags
      )
      ()
      ()
      (id ': \n \t '.ascii \s " a " \n \t .zero \s 1 \n)
      ctx
      offset
   ))
));

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
declare-local := λctx vname offset. (tail(
   (local frame_this)
   (set frame_this (_push-zero()))
   (local unframe_this)
   (set unframe_this (_unpush-this()))
   (local refer)
   (set refer (TODO REFER))
   (local set_this)
   (set set_this (TODO SETTHIS))
   (Expr(frame_this set_this unframe_this () () ctx (inc offset)))
));

#   let refer = local(&format!(
#      "\tmov {}(%rbp), %r12\n \
#       \tmov {}(%rbp), %r13\n \
#       \tmov {}(%rbp), %r14\n \
#       \tmov {}(%rbp), %r15\n",
#      -offset*32 - 8,
#      -offset*32 - 16,
#      -offset*32 - 24,
#      -offset*32 - 32,
#   ));
#   let assign = local(&format!(
#      "\tmov %r12, {}(%rbp)\n \
#       \tmov %r13, {}(%rbp)\n \
#       \tmov %r14, {}(%rbp)\n \
#       \tmov %r15, {}(%rbp)\n",
#      -offset*32 - 8,
#      -offset*32 - 16,
#      -offset*32 - 24,
#      -offset*32 - 32,
#   ));
#   let assign_vname = s_atom(&format!("set {}",vname));
#   let program_ctx = kv_add( program_ctx, &vname, &refer );
#   let program_ctx = kv_add( &program_ctx, &assign_vname, &assign );

#returns (frame program, expression program, unframe program, text, data, new program_ctx, new offset)
compile-expr := λctx e offset. (tail(
   (local x)
   (local e1)
   (local e1_frame)
   (local e1_prog)
   (local e1_unframe)
   (local e1_text)
   (local e1_data)
   (local e2)
   (local e2_frame)
   (local e2_prog)
   (local e2_unframe)
   (local e2_text)
   (local e2_data)
   (local e3)
   (local e3_frame)
   (local e3_prog)
   (local e3_unframe)
   (local e3_text)
   (local e3_data)
   (local prog)
   (match e (
      ()
      ( (App ((Variable 'local) (Variable fname))) (tail(
         (declare-local (ctx fname offset))
      )))
      ( (App( (App( (Variable 'while) c )) d )) (tail(
         (set e1 (compile-expr(ctx c offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx d offset)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (local label_while_start)
         (set label_while_start (uuid()))
         (local label_while_end)
         (set label_while_end (uuid()))
         (set prog (prog (label_while_start ': \n)))
         (set prog (prog e1_prog))
         (set prog (prog (\t 'mov \s '$0, \s %rax \n)))
         (set prog (prog (\t 'add \s %r12, \s %rax \n)))
         (set prog (prog (\t 'add \s %r13, \s %rax \n)))
         (set prog (prog (\t 'add \s %r14, \s %rax \n)))
         (set prog (prog (\t 'add \s %r15, \s %rax \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %rax \n)))
         (set prog (prog (\t 'je \s label_while_end \n)))
         (set prog (prog e2_prog))
         (set prog (prog (\t 'jmp \s label_while_start \n)))
         (set prog (prog (label_while_end ': \n)))
         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      ( (App( (App( (App( (Variable 'if) c )) t )) f )) (tail(
         (set e1 (compile-expr(ctx c offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx t offset)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))
         (set e3 (compile-expr(ctx f offset)))
         (set e3_frame (get-frame e3))
         (set e3_prog (get-prog e3))
         (set e3_unframe (get-unframe e3))
         (set e3_text (get-text e3))
         (set e3_data (get-data e3))
         (set ctx (get-pc e3))
         (set offset (get-offset e3))
         (local label_if_true)
         (set label_if_true (uuid()))
         (local label_if_end)
         (set label_if_end (uuid()))
         (set prog (prog e1_prog))
         (set prog (prog ( \t 'cmp \s '$0, '%r12 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r13 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r14 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog e3_prog))
         (set prog (prog ( \t 'jmp \s label_if_end \n )))
         (set prog (prog ( label_if_true ': \n )))
         (set prog (prog e2_prog))
         (set prog (prog ( label_if_end ': \n )))
         (Expr( (e1_frame e2_frame e3_frame) prog (e1_unframe e2_unframe e3_unframe) (e1_text e2_text e3_text) (e1_data e2_data e3_data) ctx offset ))
      )))
      ( (App ((Variable fname) arg)) (tail(
         if (is-builtin fname) (
            (set x (compile-expr(ctx arg offset)))
            (set prog (get-prog x))
            (set prog (prog (\t 'call \s (label-case fname) \n)))
            (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
         ) (
            print-s((TODOAPP fname arg))
         )
      )))
      ( (Literal l) (tail(
         ()
         (yield-atom (ctx l offset))
      )))
      ( (Variable 'argv) (tail(
         (set prog (prog ( \t 'mov \s '$__argv, \s '%rax \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%rax \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%rax \] , '%r13 \n )))
         (set prog (prog ( \t 'mov \s '16 \[ '%rax \] , '%r14 \n )))
         (set prog (prog ( \t 'mov \s '24 \[ '%rax \] , '%r15 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App (l r)) (tail(
         (set e1 (compile-expr(ctx l offset)))
         (set e1_frame (get-frame e1))
         (set e1_prog (get-prog e1))
         (set e1_unframe (get-unframe e1))
         (set e1_text (get-text e1))
         (set e1_data (get-data e1))
         (set ctx (get-pc e1))
         (set offset (get-offset e1))
         (set e2 (compile-expr(ctx r offset)))
         (set e2_frame (get-frame e2))
         (set e2_prog (get-prog e2))
         (set e2_unframe (get-unframe e2))
         (set e2_text (get-text e2))
         (set e2_data (get-data e2))
         (set ctx (get-pc e2))
         (set offset (get-offset e2))

         (set prog (prog (e1_prog)))
         (set prog (prog (_push-this())))
         (set prog (prog (e2_prog)))
         (set prog (prog (_close-this())))
         (set prog (prog (\t 'mov \s '%rsi, \s '%rdi \n)))
         (set prog (prog (_pop-this())))
         (set prog (prog (_close-this())))
         (set prog (prog (\t 'mov \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'mov \s '%rsi, \s '%r13 \n)))
         (set prog (prog (\t 'mov \s '%rdi, \s '%r14 \n)))
         (set prog (prog (\t 'mov \s '$0, \s '%r12 \n)))

         (Expr( (e1_frame e2_frame) prog (e1_unframe e2_unframe) (e1_text e2_text) (e1_data e2_data) ctx offset ))
      )))
      ( Nil (tail(
         (set prog (prog ( \t 'mov \s '$0 , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r13 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r14 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r15 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      (x (print-s (TODO x)) )
   ))
));

_data-header := λ.(
   .data                               \n
  'load_file_bsz:                      \n
  \t .quad \s '1024                    \n
  'load_file_buf:                      \n
  \t .zero \s '1024                    \n
  '__nil:                              \n
  \t .zero \s '32                      \n
  '__argv:                             \n
  \t .zero \s '32                      \n
  '__s_counter:                        \n
  \t .zero \s '8                       \n
  '__s_section:                        \n
  \t .zero \s '268435456               \n
  '__a_counter:                        \n
  \t .zero \s '8                       \n
  '__a_section:                        \n
  \t .zero \s '268435456               \n
  '__nil_literal:                      \n
  \t .ascii \s " \[ \] "               \n
  \t .zero \s 1                        \n
  '__hex_buffer:                       \n
  \t .ascii \s "0123456789abcdef"      \n
  '__put64_buffer:                     \n
  \t .ascii \s "0x"                    \n
  '__put64_write_buffer:               \n
  \t .ascii \s "0000000000000000 \s "  \n
  \t .zero \s '1                       \n
  '__newline:                          \n
  \t .ascii \s " \\ 'n "               \n
  '__lparen:                           \n
  \t .ascii \s " \[ "                  \n
  '__rparen:                           \n
  \t .ascii \s " \] "                  \n
  '__space:                            \n
  \t .ascii \s " \s "                  \n
  '__true:                             \n
  \t .ascii \s "True"                  \n
  \t .zero \s '1                       \n
  '__dump_i:                           \n
  \t '.ascii \s '"0000000000000000"    \n
  \t '.zero \s '1                      \n
  '__err_fopen:                        \n
  \t .ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t .zero \s '1                       \n
);

_exit-cleanup := λ.(
   \t 'mov \s '$60, \s '%eax   \n # _exit system call
   \t 'mov \s '$0, \s '%edi    \n # error code 0
   \t 'syscall                 \n
);

_before-main := λ.(
   # let argv = close ()
   # let t = argv
   # for a in argv:
   #    t.tail = (a ())
   #    t = t.tail
   \t 'pop \s %rax                        \n #argc
   \t 'mov \s '$__argv, \s '%rbx          \n
   \t 'movq \s '$0, \s '0 \[ '%rbx \]     \n
   \t 'movq \s '$0, \s '8 \[ '%rbx \]     \n
   \t 'movq \s '$0, \s '16 \[ '%rbx \]    \n
   \t 'movq \s '$0, \s '24 \[ '%rbx \]    \n

   '__before_main_argv:                   \n
   \t 'cmp \s '$0, \s '%rax              \n
   \t 'je \s '__before_main_end         \n
   \t 'pop \s '%r12                     \n #argv[i]
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n

   #close this (move S onto the heap)
   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0\[ '%r8 \] , \s '%r10         \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ '%r8 \]         \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ '%rsi \]        \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ '%rsi \]        \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ '%rsi \]       \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ '%rsi \]       \n # set top.flags
   \t 'mov \s '%rsi, \s '%rdi            \n

   #rdi is a
   \t 'mov \s '$0, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13              \n
   \t 'mov \s '$0, \s '%r14              \n
   \t 'mov \s '$0, \s '%r15              \n

   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0\[ '%r8 \] , \s '%r10         \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ '%r8 \]         \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ '%rsi \]        \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ '%rsi \]        \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ '%rsi \]       \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ '%rsi \]       \n # set top.flags
   \t 'mov \s '%rsi, \s '%rdi            \n

   #rsi is clean closed ()
   \t 'mov \s '%rdi, \s '8 \[ '%rbx \]    \n
   \t 'mov \s '%rsi, \s '16 \[ '%rbx \]   \n
   \t 'mov \s '%rsi, \s '%rbx            \n
   #rbx is tail of argv
   \t 'dec \s '%rax                     \n
   \t 'jmp \s '__before_main_argv       \n
   '__before_main_end:                 \n
);

_enter-function := λ.(
   \t 'push \s '%rbp                        \n
   \t 'mov \s '%rsp, \s '%rbp                \n
);
_leave-function := λ.(
   \t 'mov \s '%rbp, \s '%rsp                \n
   \t 'pop \s '%rbp                         \n
   \t 'ret                                 \n
);

_program-header := λ.(
   '.global \s '_start                 \n
   '.text                              \n
   '_start:                            \n
   \t 'jmp \s 'main                    \n

   # internal _strlen (%rax: *char) -> %rbx
   # not a call-convention function
   '_strlen:                           \n
   \t 'xor \s '%rbx, \s '%rbx          \n
   \t '_strlen_loop:                   \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]  \n
   \t 'jz \s '_strlen_exit             \n
   \t 'inc \s '%rax                    \n
   \t 'inc \s '%rbx                    \n
   \t 'jmp \s '_strlen_loop            \n
   '_strlen_exit:                      \n
   \t 'ret                             \n
   # result is stored in %rcx

   'print_s:                           \n

   # if .atom != NULL 
   '__print_this_atom:                 \n
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s '__print_this_cons        \n
   \t 'mov \s '%r12, \s '%rax          \n
   \t 'call \s '_strlen                \n # %rbx is length of string
   \t 'mov \s '%r12, \s '%rsi          \n # address of string to output
   \t 'mov \s '%rbx, \s '%rdx          \n # length is %rcx
   \t 'mov \s '$1, \s '%rax            \n # system call 1 is write
   \t 'mov \s '$1, \s '%rdi            \n # file handle 1 is stdout
   \t 'syscall                         \n # invoke operating system to do the write
   \t 'ret                             \n

   # if .head != NULL && .tail != NULL
   '__print_this_cons:                 \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__print_this_nil         \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'je \s '__print_this_nil         \n
   \t 'push \s '%r14                   \n
   \t 'push \s '%r13                   \n
   #show lparen
   \t 'mov \s '$1, \s '%rax            \n
   \t 'mov \s '$1, \s '%rdi            \n
   \t 'mov \s '$__lparen, \s '%rsi     \n
   \t 'mov \s '$1, \s '%rdx            \n
   \t 'syscall                         \n
   #show head
   \t 'pop \s '%r8                     \n
   \t 'mov \s '0 \[ '%r8 \] , '%r12    \n
   \t 'mov \s '8 \[ '%r8 \] , '%r13    \n
   \t 'mov \s '16 \[ '%r8 \] , '%r14   \n
   \t 'mov \s '24 \[ '%r8 \] , '%r15   \n
   \t 'call \s 'print_s                \n
   #show space
   \t 'mov \s '$1, \s '%rax            \n
   \t 'mov \s '$1, \s '%rdi            \n
   \t 'mov \s '$__space, \s '%rsi      \n
   \t 'mov \s '$1, \s '%rdx            \n
   \t 'syscall                         \n
   #show tail
   \t 'pop \s '%r8                     \n
   \t 'mov \s '0 \[ '%r8 \] , '%r12    \n
   \t 'mov \s '8 \[ '%r8 \] , '%r13    \n
   \t 'mov \s '16 \[ '%r8 \] , '%r14   \n
   \t 'mov \s '24 \[ '%r8 \] , '%r15   \n
   \t 'call \s 'print_s                \n
   #show rparen
   \t 'mov \s '$1, \s '%rax            \n
   \t 'mov \s '$1, \s '%rdi            \n
   \t 'mov \s '$__rparen, \s '%rsi     \n
   \t 'mov \s '$1, \s '%rdx            \n
   \t 'syscall                         \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n

   '__print_this_nil:                  \n
   \t 'mov \s '$1, \s '%rax            \n # system call 1 is write
   \t 'mov \s '$1, \s '%rdi            \n # file handle 1 is stdout
   \t 'mov \s '$__nil_literal, \s '%rsi \n # address of string to output
   \t 'mov \s '$2, \s '%rdx            \n # nil is 2 bytes
   \t 'syscall                         \n # invoke operating system to do the write
   \t 'ret                             \n


   'head:                              \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__head_is_nil            \n
   \t 'mov \s '0 \[ '%r13 \] ', '%r12  \n
   \t 'mov \s '16 \[ '%r13 \] ', '%r14 \n
   \t 'mov \s '24 \[ '%r13 \] ', '%r15 \n
   \t 'mov \s '8 \[ '%r13 \] ', '%r13  \n
   \t 'ret                             \n
   '__head_is_nil:                     \n
   \t 'mov \s '$0, \s %r12             \n
   \t 'mov \s '$0, \s %r13             \n
   \t 'mov \s '$0, \s %r14             \n
   \t 'mov \s '$0, \s %r15             \n
   \t 'ret                             \n

   'tail:                              \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__tail_is_nil            \n
   \t 'mov \s '0 \[ '%r14 \] ', '%r12  \n
   \t 'mov \s '8 \[ '%r14 \] ', '%r13  \n
   \t 'mov \s '24 \[ '%r14 \] ', '%r15 \n
   \t 'mov \s '16 \[ '%r14 \] ', '%r14 \n
   \t 'ret                             \n
   '__tail_is_nil:                     \n
   \t 'mov \s '$0, \s %r12             \n
   \t 'mov \s '$0, \s %r13             \n
   \t 'mov \s '$0, \s %r14             \n
   \t 'mov \s '$0, \s %r15             \n
   \t 'ret                             \n

   'not:                               \n
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'jne \s '__not_is_some           \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'jne \s '__not_is_some           \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'jne \s '__not_is_some           \n
   \t 'mov \s '$__true, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n
   '__not_is_some:                     \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n

   'eq:                                \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s '__equal_nil              \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'je \s '__equal_nil              \n
   \t 'mov \s '0 \[ %r13 \] , \s '%rax \n # mov x.atom into %rax
   \t 'mov \s '0 \[ %r14 \] , \s '%rbx \n # mov y.atom into %rbx
   \t 'cmp \s '$0, \s '%rax            \n
   \t 'je \s '__equal_nil              \n
   \t 'cmp \s '$0, \s '%rbx            \n
   \t 'je \s '__equal_nil              \n
   \t 'call \s '_streq                 \n
   \t 'ret                             \n
   '__equal_nil:                       \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n

   # _streq (%rax: *char, %rbx: *char)
   '_streq:                            \n
   '__streq_loop:                      \n
   \t 'cmp \s '$0, \s '%rax            \n
   \t 'je \s '__streq_false            \n
   \t 'cmp \s '$0, \s '%rbx            \n
   \t 'je \s '__streq_false            \n
   \t 'mov \s '0 \[ %rax \] , \s '%cl  \n
   \t 'mov \s '0 \[ %rbx \] , \s '%dl  \n

   \t 'cmp \s '%cl, \s '%dl            \n
   \t 'jne \s '__streq_false           \n
   \t 'cmp \s '$0, \s '%cl             \n
   \t 'je \s '__streq_true             \n
   \t 'inc \s '%rax                    \n
   \t 'inc \s '%rbx                    \n
   \t 'jmp \s '__streq_loop            \n
   '__streq_true:                      \n
   \t 'mov \s '$__true, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n
   '__streq_false:                     \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n

   'dump_i:                            \n
   \t 'mov \s '%r12, \s '%r8           \n
   \t 'mov \s '$__dump_i, \s '%r12     \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'mov \s '$__dump_i, \s '%r11     \n
   \t 'cmp \s '$0, \s '%r8             \n
   \t 'jge \s 'dump_i_positive         \n
   \t 'jmp \s 'dump_i_negative         \n
   'dump_i_positive:                   \n
   \t 'call \s 'dump_i_digits          \n
   \t ret                              \n
   'dump_i_negative:                   \n
   \t 'neg \s '%r8                     \n
   \t 'call \s 'dump_i_digits          \n
   \t 'movb \s '$45, \s '0 \[ %r11 \]  \n
   \t ret                              \n
   # if return value is positive then open was a success

   'dump_i_digits:                     \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[0]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '0 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[1]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '1 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[2]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '2 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[3]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '3 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[4]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '4 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[5]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '5 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[6]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '6 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[7]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '7 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[8]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '8 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[9]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '9 \[ %r11 \]   \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[10]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '10 \[ %r11 \]  \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[11]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '11 \[ %r11 \]  \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[12]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '12 \[ %r11 \]  \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[13]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '13 \[ %r11 \]  \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[14]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '14 \[ %r11 \]  \n
   \t 'rol \s '$4, \s '%r8             \n   # %r8[15]
   \t 'call \s 'put8                   \n
   \t 'mov \s '%cl, \s '15 \[ %r11 \]  \n
   \t ret                              \n

   #move ascii representation of lower byte of %r8 into %cl
   'put8:                              \n
   \t 'mov \s '%r8b, \s '%al           \n # lower byte of %r11 goes into %rax
   \t 'and \s '$0xf, \s '%al           \n # only show lower 4 bits
   \t 'mov \s '$__hex_buffer, '%r10    \n # %r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b          \n # %r10 is index into char in hex buffer
   \t 'mov \s '0 \[ %r10 \] , \s '%cl  \n # %cl is a hexadecimal char
   \t 'ret                             \n

   'inc:                               \n
   \t 'inc \s '%r12                    \n
   \t 'ret                             \n

   'dec:                               \n
   \t 'dec \s '%r12                    \n
   \t 'ret                             \n

   'mul:                               \n
   \t 'dec \s '%r12                    \n
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'mul_err                  \n
   \t 'cmp \s '$0, \s '%r14            \n
   \t 'je \s 'mul_err                  \n
   \t 'mov \s '0 \[ '%r13 \] , '%rax   \n  
   \t 'mov \s '0 \[ '%r14 \] , '%rbx   \n
   \t 'imul \s '%rax, \s '%rbx         \n
   \t 'mov \s '%rbx, \s '%r12          \n
   \t 'ret                             \n
   'mul_err:                           \n
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   \t 'mov \s '$0, \s '%r14            \n
   \t 'mov \s '$0, \s '%r15            \n
   \t 'ret                             \n
);

_push-this := λ.(
   \t 'push \s '%r12 \n
   \t 'push \s '%r13 \n
   \t 'push \s '%r14 \n
   \t 'push \s '%r15 \n
);

_push-zero := λ.(
   \t 'pushq \s '$0 \n
   \t 'pushq \s '$0 \n
   \t 'pushq \s '$0 \n
   \t 'pushq \s '$0 \n
);

_unpush-this := λ.(
   \t 'pop \s '%r8 \n
   \t 'pop \s '%r8 \n
   \t 'pop \s '%r8 \n
   \t 'pop \s '%r8 \n
);

_pop-this := λ.(
   \t 'pop \s '%r15 \n
   \t 'pop \s '%r14 \n
   \t 'pop \s '%r13 \n
   \t 'pop \s '%r12 \n
);

_close-this := λ.(
   # move this S onto the heap
   # %rsi becomes pointer to new location
   \t 'mov \s '$__s_section, \s '%rsi        \n # %rsi now points to root s
   \t 'mov \s '$__s_counter, \s '%r8         \n # %r8 now points to s counter
   \t 'mov \s '0 \[ %r8 \] , \s '%r10        \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%rsi                \n # %rsi now points to top free cons
   \t 'add \s '$32, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ %r8 \]         \n # overwrite new s counter
   \t 'mov \s '%r12, \s '0 \[ %rsi \]        \n # set top.atom
   \t 'mov \s '%r13, \s '8 \[ %rsi \]        \n # set top.head
   \t 'mov \s '%r14, \s '16 \[ %rsi \]       \n # set top.tail
   \t 'mov \s '%r15, \s '24 \[ %rsi \]       \n # set top.flags
);
