
c-type-index := (: (HashtableEq( 0_u64 0_u64 (as 0_u64 Tuple<String,U64>[]) )) HashtableEq<String,U64>);

index-c-type := λ(: s String). (: (
   (set c-type-index (.bind( c-type-index s 1_u64 )))
) Nil);

c-parse := λ(: tokens List<String>). (: (
   (while (non-zero tokens) (
      (let ht (head tokens))
      (if (==( (head tokens) '\:_s )) (set tokens (tail tokens)) ())
      (if (==( (head tokens) 'typedef_s )) (set tokens (c-parse-typedef tokens)) ())
      (if (c-is-typename(head tokens)) (set tokens (c-parse-declaration tokens)) ())
      (if (is( (head tokens) ht )) (
         (print 'Unrecognized\sTop\sLevel\sStatement\s_s)(print ht)(print '\n_s)(exit 1_u64)
      ) ())
   ))
) Nil);

c-parse-typedef := λ(: tokens List<String>). (: (
   (let original-tokens tokens)
   (set tokens (tail tokens)) # remove typedef token
   (while (&&( (non-zero tokens) (c-is-typename(head tokens)) )) (
      (set tokens (tail tokens))
   ))
   (if (non-zero tokens) (
      (print 'Typedef\s_s)(print (head tokens))(print '\n_s)
      (index-c-type(head tokens))
      (set tokens (tail tokens))
   ) ())
   (if (non-zero tokens) (
      (if (==( (head tokens) '\:_s )) (set tokens (tail tokens)) (
         (print 'Expected\sSemicolon\sIn\sTypedef_s)
         (while (not(is( (head tokens) (head original-tokens) ))) (
            (print '\s_s)(print (head original-tokens))
            (set original-tokens (tail original-tokens))
         ))
         (print '\n_s)(exit 1_u64)
      ))
   ) (
      (print 'Malformed\sTypedef\s_s)(print original-tokens)(print '\n_s)(exit 1_u64)
   ))
   tokens
) List<String>);

c-parse-declaration := λ(: tokens List<String>). (: (
   (print 'TODO\sParse\sDeclaration\n_s)(exit 1_u64)
   tokens
) List<String>);

c-is-typename := λ(: s String). (: (
   (.lookup( c-type-index s 0_u64 ))
) U64);
