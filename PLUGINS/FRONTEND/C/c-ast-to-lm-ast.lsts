
let std-c-declare(t: CTerm): Nil = (
   match t {
      CFunctionDefinition{spec=specifiers,decl=declarator,dl=declaration-list,stmt=statement} => std-c-declare-function(spec, decl, dl, stmt);
      CBinaryOp{op:c"Declaration",spec=arg1,arg2:CMaybe{value:Some{content:CList{inits=value}}}} => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         return-type = return-type && t1(c"C-FFI");
         for init in inits { match init {
            CBinaryOp{op:c"=", arg1:CIdentifier{name=value}, value=arg2} => (
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(std-c-expr-of-statement(value)),
                        close(AType{ return-type })
                     })
                  })
               };
            );
            CIdentifier{name=value} => (
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(Var{c"__uninitialized", mk-token(c"__uninitialized")}),
                        close(AType{ return-type })
                     })
                  })
               };
            );
         }};
      );
      _ => fail("Unsupported C Declaration:\n\{t}\n");
   };
);

let std-c-declare-function(specifiers: CTerm, declarator: CTerm, declaration-list: CTerm, statement: CTerm): Nil = (
   (let return-type, let misc-types) = std-c-type-of-specifiers(specifiers);
   (let name, let pointer) = std-c-name-of-declarator(declarator);
   let params = std-c-lhs-of-parameter-list(declaration-list);
   let body = std-c-expr-of-statement(statement);
   let symbol = Glb{
      mk-token(name), close(Abs{
         close(params),
         close(App{ false,
            close(Lit{c":", mk-token(c":")}),
            close(App{
               close(body),
               close(AType{ return-type })
            })
         }),
         misc-types && t1(c"C-FFI")
      })
   };
   ast-parsed-program = ast-parsed-program + symbol;
);

let std-c-type-of-specifiers(specifiers: CTerm): Tuple<Type,Type> = (
   match specifiers {
      CMaybe{value:Some{content=content}} => std-c-type-of-specifiers(content);
      CList{value:[CType1{rv=value}..]} => ( t2(c"C", t1(untern(rv))), TAny );
      _ => fail("Unsupported C Specifiers:\n\{specifiers}\n");
   };
);

let std-c-name-of-declarator(declarator: CTerm): Tuple<String,Type> = (
   match declarator {
      CUnaryPrefix{op:"Declarator(", arg:CIdentifier{name=value}} => (name, TAny);
      _ => fail("Unsupported C Declarator:\n\{declarator}\n");
   };
);

let std-c-lhs-of-parameter-list(declaration-list: CTerm): AST = (
   match declaration-list {
      CMaybe{value:None{}} => ASTNil;
      _ => fail("Unsupported C Parameter List:\n\{declaration-list}\n");
   };
);

let std-c-expr-of-statement(t: CTerm): AST = (
   match t {
      CCompound{terms=terms} => (
         let inner = ASTNil;
         for it in terms {
            inner = App{ true, close(inner), close(std-c-expr-of-statement(it)) };
         };
         App{ false, close(Var{c"c::compound", mk-token(c"c::compound")}), close(inner) }
      );
      CUnaryPrefix{op:"return", arg=arg} => (
         let inner = std-c-expr-of-statement(arg);
         App{ false, close(Var{c"c::return", mk-token(c"c::return")}), close(inner) }
      );
      CUnaryPrefix{op:"sizeof", arg=arg} => (
         match std-c-expr-of-statement(arg) {
            AType{tt=tt} => (
               App{ false, close(Var{c"prefix:sizeof", mk-token(c"prefix:sizeof")}), close(AType{t2(c"Type", tt)}) }
            );
            inner => (
               App{ false, close(Var{c"prefix:sizeof", mk-token(c"prefix:sizeof")}), close(inner) }
            );
         }
      );
      CUnaryPrefix{op:"alignof", arg=arg} => (
         match std-c-expr-of-statement(arg) {
            AType{tt=tt} => (
               App{ false, close(Var{c"prefix:alignof", mk-token(c"prefix:alignof")}), close(AType{t2(c"Type", tt)}) }
            );
            inner => (
               App{ false, close(Var{c"prefix:alignof", mk-token(c"prefix:alignof")}), close(inner) }
            );
         }
      );
      CBinaryOp{op=op:"cast", arg1=arg1, arg2=arg2} => (
         App{
            close(Var{c"as", mk-token(c"as")}),
            close(App{
               close(std-c-expr-of-statement(arg2)),
               close(std-c-expr-of-statement(arg1))
            })
         }
      );
      CIdentifier{value=value} => (
         Var{ untern(value), mk-token(value) }
      );
      CInteger{value=value} => (
         App{
            close(Lit{c":", mk-token(c":")}),
            close(App{
               close(Lit{ untern(value), mk-token(value) }),
               close(AType{ std-c-type-of-integer(value) })
            })
         }
      );
      CBinaryOp{op:c"Declaration", spec=arg1, arg2:CMaybe{value:Some{content:CList{decls=value}}} } => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         return-type = return-type && t1(c"C-FFI");
         let expr = ASTEOF;
         for decl in decls {match decl {
            CIdentifier{name=value} => (
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(Var{ c"__uninitialized", mk-token(c"__uninitialized") }),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            CBinaryOp{op:c"=", arg1:CIdentifier{name=value}, value=arg2 } => (
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(std-c-expr-of-statement(value)),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            CBinaryOp{op:c"Declarator*", ptr=arg1, arg2:CIdentifier{name=value}} => (
               return-type = std-c-decorate-pointer(return-type, ptr);
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(Var{ c"__uninitialized", mk-token(c"__uninitialized") }),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            _ => fail("Unsupported Declaration: \{decl}\n");
         }};
         expr;
      );
      CTernaryOp{op=op, arg1=arg1, arg2=arg2, arg3=arg3 } => (
         App{
            close(Var{ untern(op), mk-token(op) }),
            close(App{
               true,
               close(App{
                  true,
                  close(std-c-expr-of-statement(arg1)),
                  close(std-c-expr-of-statement(arg2))
               }),
               close(std-c-expr-of-statement(arg3))
            })
         };
      );
      CBinaryOp{op:c"TypeName", arg1=arg1, arg2=arg2 } => (
         (let rt, let mt) = std-c-type-of-specifiers(arg1);
         AType{rt}
      );
      CBinaryOp{op=op, arg1=arg1, arg2=arg2 } => (
         App{
            close(Var{ untern(op), mk-token(op) }),
            close(App{
               true,
               close(std-c-expr-of-statement(arg1)),
               close(std-c-expr-of-statement(arg2))
            })
         };
      );
      CUnaryPrefix{op=op, arg=arg } => (
         App{
            close(Var{ c"prefix:" + untern(op), mk-token("prefix:" + op) }),
            close(std-c-expr-of-statement(arg))
         };
      );
      CUnaryPostfix{op=op, arg=arg } => (
         App{
            close(Var{ c"postfix:" + untern(op), mk-token("postfix:" + op) }),
            close(std-c-expr-of-statement(arg))
         };
      );
      _ => fail("Unsupported C Statement:\n\{t}\n");
   };
);

let std-c-decorate-pointer(tt: Type, ptr: CTerm): Type = (
   match ptr {
      CPointer{ qualifiers=qualifiers, next=next } => (
         if next.is-some then tt = std-c-decorate-pointer(tt, next.get-or-panic);
         tt = t3(c"Array", tt, TAny);
      );
   };
   tt
);

let std-c-type-of-integer(i: String): Type = (
   if i.has-prefix("-") {
      let n = to-u64(untern(tail-string(i)));
      if n <= 128 then t2(c"C",t1(c"uint8_t")) else
      if n <= 32768 then t2(c"C",t1(c"uint16_t")) else
      if n <= 2147483648 then t2(c"C",t1(c"uint32_t")) else
      t2(c"C",t1(c"uint64_t"))
   } else {
      let n = to-u64(untern(i));
      if n <= 255 then t2(c"C",t1(c"int8_t")) else
      if n <= 65535 then t2(c"C",t1(c"int16_t")) else
      if n <= 4294967295 then t2(c"C",t1(c"int32_t")) else
      t2(c"C",t1(c"int64_t"))
   };
);
