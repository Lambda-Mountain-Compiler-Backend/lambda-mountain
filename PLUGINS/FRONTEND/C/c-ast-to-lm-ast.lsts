
let std-c-declare(t: CTerm): Nil = (
   match t {
      CFunctionDefinition{spec=specifiers,decl=declarator,dl=declaration-list,stmt=statement} => std-c-declare-function(spec, decl, dl, stmt);
      CBinaryOp{op:c"Declaration",spec=arg1,arg2:CMaybe{value:Some{content:CList{inits=value}}}} => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         return-type = return-type && t1(c"C-FFI");
         for init in inits { match init {
            CBinaryOp{op:c"=", arg1:CIdentifier{name=value}, value=arg2} => (
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(std-c-expr-of-statement(value)),
                        close(AType{ return-type })
                     })
                  })
               };
            );
            CIdentifier{name=value} => (
               if can-unify( t2(c"C",t1(c"typedef")), return-type ) {
                  std-c-typedef-name-index = std-c-typedef-name-index.bind(name, true);
               };
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(Var{c"__uninitialized", mk-token(c"__uninitialized")}),
                        close(AType{ return-type })
                     })
                  })
               };
            );
            CUnaryPrefix{op:c"Declarator(", arg=arg} => (
               (let name, let body) = std-c-sig-of-declarator(return-type, arg, TAny, None :: Maybe<CTerm>);
               if can-unify( t2(c"C",t1(c"typedef")), return-type ) {
                  std-c-typedef-name-index = std-c-typedef-name-index.bind(name.into(type(String)), true);
               };
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(body)
               };
            );
            CBinaryOp{op:c"Declarator(", arg1=arg1, arg2=arg2 } => (
               (let name, let body) = std-c-sig-of-declarator(return-type, arg1, TAny, Some(arg2));
               if can-unify( t2(c"C",t1(c"typedef")), return-type ) {
                  std-c-typedef-name-index = std-c-typedef-name-index.bind(name.into(type(String)), true);
               };
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(body)
               };
            );
            CBinaryOp{op:c"Declarator*", ptr=arg1, arg2:CIdentifier{name=value} } => (
               if can-unify( t2(c"C",t1(c"typedef")), return-type ) {
                  std-c-typedef-name-index = std-c-typedef-name-index.bind(name, true);
               };
               return-type = std-c-decorate-pointer(return-type, ptr);
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(Var{c"__uninitialized", mk-token(c"__uninitialized")}),
                        close(AType{ return-type })
                     })
                  })
               };
            );
            _ => print("Unsupported C Declaration Init\n\{init}\n");
         }};
      );
      _ => print("Unsupported C Declaration:\n\{t}\n");
   };
);

let std-c-sig-of-params-list(params: List<CTerm>): AST = (
   let return = ASTEOF;
   for p in params { match p {
      CBinaryOp{op:c"ParameterDeclaration", spec=arg1, arg2:CIdentifier{name=value}} => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         let pe = App{ false,
            close(Lit{c":", mk-token(c":")}),
            close(App{ false,
               close(Var{untern(name), mk-token(name)}),
               close(AType{ return-type })
            })
         };
         if non-zero(return) {
            return = App{ false, close(return), close(pe) };
         } else {
            return = pe;
         }
      );
      CBinaryOp{op:c"ParameterDeclaration", spec=arg1, arg2:CBinaryOp{op:c"Declarator*",ptr=arg1,arg2:CIdentifier{name=value}}} => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         return-type = std-c-decorate-pointer(return-type, ptr);
         let pe = App{ false,
            close(Lit{c":", mk-token(c":")}),
            close(App{ false,
               close(Var{untern(name), mk-token(name)}),
               close(AType{ return-type })
            })
         };
         if non-zero(return) {
            return = App{ false, close(return), close(pe) };
         } else {
            return = pe;
         }
      );
      _ => print("std-c-sig-of-params-list: Unexpected Parameter \{p}\n");
   }};
   if non-zero(return) then return else ASTNil
);

let std-c-sig-of-declarator(return-type: Type, declarator: CTerm, misc-type: Type, ps: Maybe<CTerm>): (CString, AST) = (
   let params = match ps {
      None{} => ASTNil;
      Some{content:CList{value=value}} => std-c-sig-of-params-list(value);
      Some{content=content} => (print("std-c-sig-of-declarator unrecognized params \{content}\n"); ASTNil);
   };
   match declarator {
      CBinaryOp{op:c"Declarator*", ptr=arg1, arg2:CIdentifier{name=value}} => (
         misc-type = std-c-decorate-pointer(misc-type, ptr);
         (untern(name), Abs{ close(params), close(App{ false,
               close(Lit{c":", mk-token(c":")}),
               close(App{ false,
                  close(Var{c"__uninitialized", mk-token(c"__uninitialized")}),
                  close(AType{ return-type })
               })
            }), misc-type && t1(c"C-FFI")
         })
      );
      CIdentifier{name=value} => (
         (untern(name), Abs{ close(params), close(App{ false,
               close(Lit{c":", mk-token(c":")}),
               close(App{ false,
                  close(Var{c"__uninitialized", mk-token(c"__uninitialized")}),
                  close(AType{ return-type })
               })
            }), misc-type && t1(c"C-FFI")
         })
      );
      _ => (
         fail("std-c-sig-of-declarator: Unknown Declarator\n\{declarator}\n");
         (c"", ASTEOF)
      );
   }
);

let std-c-declare-function(specifiers: CTerm, declarator: CTerm, declaration-list: CTerm, statement: CTerm): Nil = (
   (let return-type, let misc-types) = std-c-type-of-specifiers(specifiers);
   (let name, let pointer) = std-c-name-of-declarator(declarator);
   let params = std-c-lhs-of-parameter-list(declaration-list);
   let body = std-c-expr-of-statement(statement);
   let symbol = Glb{
      mk-token(name), close(Abs{
         close(params),
         close(App{ false,
            close(Lit{c":", mk-token(c":")}),
            close(App{
               close(body),
               close(AType{ return-type })
            })
         }),
         misc-types && t1(c"C-FFI")
      })
   };
   ast-parsed-program = ast-parsed-program + symbol;
);

let std-c-type-of-specifiers(specifiers: CTerm): Tuple<Type,Type> = (
   match specifiers {
      CMaybe{value:Some{content=content}} => std-c-type-of-specifiers(content);
      CList{value=value} => std-c-type-of-specifiers(value);
      CType1{value=value} => ( t2(c"C",t1(untern(value))), TAny );
      CBinaryOp{op:c"struct", arg1:CIdentifier{name=value}, decl=arg2} => (
         let cname = if name=="" then uuid() else name.into(type(CString));
         print("TODO typedef C struct \{cname} \{decl}\n");
         (t1(cname), TAny)
      );
      CBinaryOp{op:c"union", arg1:CIdentifier{name=value}, decl=arg2} => (
         let cname = if name=="" then uuid() else name.into(type(CString));
         print("TODO typedef C union \{cname} \{decl}\n");
         (t1(cname), TAny)
      );
      CBinaryOp{op:c"enum", arg1:CIdentifier{name=value}, decl=arg2} => (
         let cname = if name=="" then uuid() else name.into(type(CString));
         print("TODO typedef C enum \{cname} \{decl}\n");
         (t1(cname), TAny)
      );
      _ => fail("Unsupported C Specifiers:\n\{specifiers}\n");
   };
);

let std-c-type-of-specifiers(specifiers: List<CTerm>): Tuple<Type,Type> = (
   let return-type = TAny;
   let misc-type = TAny;
   for ct in specifiers {
      (let rt, let mt) = std-c-type-of-specifiers(ct);
      return-type = return-type && rt;
      misc-type = misc-type && mt;
   };
   (return-type, misc-type)
);

let std-c-name-of-declarator(declarator: CTerm): Tuple<String,Type> = (
   match declarator {
      CUnaryPrefix{op:"Declarator(", arg:CIdentifier{name=value}} => (name, TAny);
      CBinaryOp{op:"Declarator(", arg1:CIdentifier{name=value}} => (name, TAny);
      _ => fail("Unsupported C Declarator:\n\{declarator}\n");
   };
);

let std-c-lhs-of-parameter-list(declaration-list: CTerm): AST = (
   match declaration-list {
      CMaybe{value:None{}} => ASTNil;
      _ => fail("Unsupported C Parameter List:\n\{declaration-list}\n");
   };
);

let std-c-lift-lhs(rhs: AST): (AST, AST) = (
    let lhs = ASTEOF;
    match rhs {
       App{ is-cons:1_u8, left=left, right=right } => (
          (lhs, rhs) = std-c-lift-lhs(left);
          (let new-lhs, let new-rhs) = std-c-lift-lhs(right);
          if is(lhs, ASTEOF) then (lhs = new-lhs) else (lhs = App{ true, close(lhs), close(new-lhs) });
          if is(rhs, ASTEOF) then (rhs = new-rhs) else (rhs = App{ true, close(rhs), close(new-rhs) });
       );
       App{ left:App{ left:Var{key:c"let"}, binding=right }, right:App{ left:Lit{key:c":"}, right:App{ left:Var{key:c"__uninitialized"}, right:AType{tt=tt}  } } } => (
          let new-lhs = rhs;
          rhs = ASTEOF;
          if is(lhs, ASTEOF) then (lhs = new-lhs) else (lhs = App{ true, close(lhs), close(new-lhs) });
       );
       App{ left:App{ left:Var{key:c"let"}, binding=right }, right:App{ left:Lit{key:c":"}, right:App{ assignment=left, right:AType{tt=tt}  } } } => (
          let new-lhs = App {
             close(App{
                close(Var{ c"let", mk-token(c"let") }),
                close(binding)
             }),
             close(App{
                close(Lit{ c":", mk-token(c":") }),
                close(App{
                   close(Var{ c"__uninitialized", mk-token(c"__uninitialized") }),
                   close(AType{ tt })
                })
             })
          };
          rhs = mk-app(mk-app( mk-var(c"set"), binding), assignment);
          if is(lhs, ASTEOF) then (lhs = new-lhs) else (lhs = App{ true, close(lhs), close(new-lhs) });
       );
       _ => ();
    };
    (lhs, rhs)
);

let std-c-expr-of-statement(t: CTerm): AST = (
   match t {
      CCompound{terms=terms} => (
         let inner = ASTNil;
         for it in terms {
            inner = App{ true, close(inner), close(std-c-expr-of-statement(it)) };
         };
         App{ false, close(Var{c"c::compound", mk-token(c"c::compound")}), close(inner) }
      );
      CBinaryOp{op:"c::label", arg1=arg1, arg2=arg2} => (
         match std-c-expr-of-statement(arg1) {
            Var{key=key} => (
               mk-cons(
                  mk-app( mk-app( mk-var("let"), mk-var(key) ), mk-var("__uninitialized").ascript(t2(c"C",t1(c":Label"))) ),
                  std-c-expr-of-statement(arg2)
               )
            );
         }
      );
      CUnaryPrefix{op:"sizeof", arg=arg} => (
         match std-c-expr-of-statement(arg) {
            AType{tt=tt} => (
               App{ false, close(Var{c"prefix:sizeof", mk-token(c"prefix:sizeof")}), close(AType{t2(c"Type", tt)}) }
            );
            inner => (
               App{ false, close(Var{c"prefix:sizeof", mk-token(c"prefix:sizeof")}), close(inner) }
            );
         }
      );
      CUnaryPrefix{op:"alignof", arg=arg} => (
         match std-c-expr-of-statement(arg) {
            AType{tt=tt} => (
               App{ false, close(Var{c"prefix:alignof", mk-token(c"prefix:alignof")}), close(AType{t2(c"Type", tt)}) }
            );
            inner => (
               App{ false, close(Var{c"prefix:alignof", mk-token(c"prefix:alignof")}), close(inner) }
            );
         }
      );
      CBinaryOp{op=op:"cast", arg1=arg1, arg2=arg2} => (
         App{
            close(Var{c"as", mk-token(c"as")}),
            close(App{
               close(std-c-expr-of-statement(arg2)),
               close(std-c-expr-of-statement(arg1))
            })
         }
      );
      CIdentifier{value=value} => (
         Var{ untern(value), mk-token(value) }
      );
      CInteger{value=value} => (
         App{
            close(Lit{c":", mk-token(c":")}),
            close(App{
               close(Lit{ untern(value), mk-token(value) }),
               close(AType{ std-c-type-of-integer(value) })
            })
         }
      );
      CBinaryOp{op:c"Declaration", spec=arg1, arg2:CMaybe{value:Some{content:CList{decls=value}}} } => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         return-type = return-type && t1(c"C-FFI");
         let expr = ASTEOF;
         for decl in decls {match decl {
            CIdentifier{name=value} => (
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(Var{ c"__uninitialized", mk-token(c"__uninitialized") }),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            CBinaryOp{op:c"=", arg1:CIdentifier{name=value}, value=arg2 } => (
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(std-c-expr-of-statement(value)),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            CBinaryOp{op:c"Declarator*", ptr=arg1, arg2:CIdentifier{name=value}} => (
               return-type = std-c-decorate-pointer(return-type, ptr);
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(Var{ c"__uninitialized", mk-token(c"__uninitialized") }),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            _ => fail("Unsupported Declaration: \{decl}\n");
         }};
         expr;
      );
      CTernaryOp{op=op, arg1=arg1, arg2=arg2, arg3=arg3 } => (
         App{
            close(Var{ untern(op), mk-token(op) }),
            close(App{
               true,
               close(App{
                  true,
                  close(std-c-expr-of-statement(arg1)),
                  close(std-c-expr-of-statement(arg2))
               }),
               close(std-c-expr-of-statement(arg3))
            })
         };
      );
      CBinaryOp{op:c"TypeName", arg1=arg1, arg2=arg2 } => (
         (let rt, let mt) = std-c-type-of-specifiers(arg1);
         AType{rt}
      );
      CBinaryOp{op=op, arg1=arg1, arg2=arg2 } => (
         App{
            close(Var{ untern(op), mk-token(op) }),
            close(App{
               true,
               close(std-c-expr-of-statement(arg1)),
               close(std-c-expr-of-statement(arg2))
            })
         };
      );
      CUnaryPrefix{op=op, arg=arg } => (
         App{
            close(Var{ c"prefix:" + untern(op), mk-token("prefix:" + op) }),
            close(std-c-expr-of-statement(arg))
         };
      );
      CUnaryPostfix{op=op, arg=arg } => (
         App{
            close(Var{ c"postfix:" + untern(op), mk-token("postfix:" + op) }),
            close(std-c-expr-of-statement(arg))
         };
      );
      CZOp{op=op} => (
         App{
            close(Var{ untern("c::" + op), mk-token("c::" + op) }),
            close(ASTNil)
         };
      );
      CFor{op=op, arg1=arg1, arg2=arg2, arg3=arg3, stmt=stmt} => (
         let preamble = ASTEOF;
         let args = if arg1.is-some then {
            (preamble, let arg1-rhs) = std-c-lift-lhs(std-c-expr-of-statement(arg1.get-or-panic));
            if non-zero(arg1-rhs)
            then arg1-rhs
            else mk-lit(c"").ascript(t1(c"L"))
         } else { mk-lit(c"").ascript(t1(c"L")) };
         if arg2.is-some then { args = mk-cons(args, std-c-expr-of-statement(arg2.get-or-panic)); }
         else { args = mk-cons(args, mk-lit(c"").ascript(t1(c"L"))); };
         if arg3.is-some then { args = mk-cons(args, std-c-expr-of-statement(arg3.get-or-panic)); }
         else { args = mk-cons(args, mk-lit(c"").ascript(t1(c"L"))); };
         args = mk-cons(args, std-c-expr-of-statement(stmt));
         let for-expr = mk-app(
            Var{ c"c::for", with-location(mk-token("c::for"),op.location) },
            args
         );
         for-expr = if non-zero(preamble)
         then App{ true, close(preamble), close(for-expr) }
         else for-expr;
         for-expr;
      );
      _ => fail("Unsupported C Statement:\n\{t}\n");
   };
);

let std-c-decorate-pointer(tt: Type, ptr: CTerm): Type = (
   match ptr {
      CPointer{ qualifiers=qualifiers, next=next } => (
         if next.is-some then tt = std-c-decorate-pointer(tt, next.get-or-panic);
         tt = t3(c"Array", tt, TAny);
      );
   };
   tt
);

let std-c-type-of-integer(i: String): Type = (
   if i.has-prefix("-") {
      let n = to-u64(untern(tail-string(i)));
      if n <= 128 then t2(c"C",t1(c"uint8_t")) else
      if n <= 32768 then t2(c"C",t1(c"uint16_t")) else
      if n <= 2147483648 then t2(c"C",t1(c"uint32_t")) else
      t2(c"C",t1(c"uint64_t"))
   } else {
      let n = to-u64(untern(i));
      if n <= 255 then t2(c"C",t1(c"int8_t")) else
      if n <= 65535 then t2(c"C",t1(c"int16_t")) else
      if n <= 4294967295 then t2(c"C",t1(c"int32_t")) else
      t2(c"C",t1(c"int64_t"))
   };
);
