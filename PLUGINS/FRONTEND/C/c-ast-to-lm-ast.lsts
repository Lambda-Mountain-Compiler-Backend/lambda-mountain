
let std-c-declare(t: CTerm): Nil = (
   match t {
      CFunctionDefinition{spec=specifiers,decl=declarator,dl=declaration-list,stmt=statement} => std-c-declare-function(spec, decl, dl, stmt);
      CBinaryOp{op:c"Declaration",spec=arg1,arg2:CMaybe{value:Some{content:CList{inits=value}}}} => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         return-type = return-type && t1(c"C");
         for init in inits { match init {
            CBinaryOp{op:c"=", arg1:CIdentifier{name=value}, value=arg2} => (
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(std-c-expr-of-statement(value)),
                        close(AType{ return-type })
                     })
                  })
               };
            );
            CIdentifier{name=value} => (
               ast-parsed-program = ast-parsed-program + Glb{
                  mk-token(name), close(App{ false,
                     close(Lit{c":", mk-token(c":")}),
                     close(App{ false,
                        close(Var{c"__uninitialized", mk-token(c"__uninitialized")}),
                        close(AType{ return-type })
                     })
                  })
               };
            );
         }};
      );
      _ => fail("Unsupported C Declaration:\n\{t}\n");
   };
);

let std-c-declare-function(specifiers: CTerm, declarator: CTerm, declaration-list: CTerm, statement: CTerm): Nil = (
   (let return-type, let misc-types) = std-c-type-of-specifiers(specifiers);
   (let name, let pointer) = std-c-name-of-declarator(declarator);
   let params = std-c-lhs-of-parameter-list(declaration-list);
   let body = std-c-expr-of-statement(statement);
   ast-parsed-program = ast-parsed-program + Glb{
      mk-token(name), close(Abs{
         close(params),
         close(App{ false,
            close(Lit{c":", mk-token(c":")}),
            close(App{
               close(body),
               close(AType{ return-type })
            })
         }),
         misc-types && t1(c"C")
      })
   };
);

let std-c-type-of-specifiers(specifiers: CTerm): Tuple<Type,Type> = (
   let misc = TAny;
   let rtype = match specifiers {
      CList{value:[CType1{rv=value}..]} => t2(c"C", t1(untern(rv)));
      _ => fail("Unsupported C Specifiers:\n\{specifiers}\n");
   };
   (rtype, misc);
);

let std-c-name-of-declarator(declarator: CTerm): Tuple<String,Type> = (
   match declarator {
      CUnaryPrefix{op:"Declarator(", arg:CIdentifier{name=value}} => (name, TAny);
      _ => fail("Unsupported C Declarator:\n\{declarator}\n");
   };
);

let std-c-lhs-of-parameter-list(declaration-list: CTerm): AST = (
   match declaration-list {
      CMaybe{value:None{}} => ASTNil;
      _ => fail("Unsupported C Parameter List:\n\{declaration-list}\n");
   };
);

let std-c-expr-of-statement(t: CTerm): AST = (
   match t {
      CCompound{terms=terms} => (
         let inner = ASTNil;
         for it in terms {
            inner = App{ true, close(inner), close(std-c-expr-of-statement(it)) };
         };
         App{ false, close(Var{c"c::compound", mk-token(c"c::compound")}), close(inner) }
      );
      CUnaryPrefix{op:"return", arg=arg} => (
         let inner = std-c-expr-of-statement(arg);
         App{ false, close(Var{c"c::return", mk-token(c"c::return")}), close(inner) }
      );
      CInteger{value=value} => (
         App{ false,
            close(Lit{c":", mk-token(c":")}),
            close(App{
               close(Lit{ untern(value), mk-token(value) }),
               close(AType{ std-c-type-of-integer(value) })
            })
         }
      );
      CBinaryOp{op:c"Declaration", spec=arg1, arg2:CMaybe{value:Some{content:CList{decls=value}}} } => (
         (let return-type, let misc-types) = std-c-type-of-specifiers(spec);
         let expr = ASTEOF;
         for decl in decls {match decl {
            CIdentifier{name=value} => (
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(Var{ c"__uninitialized", mk-token(c"__uninitialized") }),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
            CBinaryOp{op:c"=", arg1:CIdentifier{name=value}, value=arg2 } => (
               let d = App{
                  close(App{
                     close(Var{ c"let", mk-token(c"let") }),
                     close(Var{ untern(name), mk-token(name) })
                  }),
                  close(App{
                     close(Lit{ c":", mk-token(c":") }),
                     close(App{
                        close(std-c-expr-of-statement(value)),
                        close(AType{ return-type })
                     })
                  })
               };
               if non-zero(expr) {
                  expr = App{ close(expr), close(d) };
               } else expr = d;
            );
         }};
         expr;
      );
      _ => fail("Unsupported C Statement:\n\{t}\n");
   };
);

let std-c-type-of-integer(i: String): Type = (
   if i.has-prefix("-") {
      let n = to-u64(untern(tail-string(i)));
      if n <= 128 then t2(c"C",t1(c"uint8_t")) else
      if n <= 32768 then t2(c"C",t1(c"uint16_t")) else
      if n <= 2147483648 then t2(c"C",t1(c"uint32_t")) else
      t2(c"C",t1(c"uint64_t"))
   } else {
      let n = to-u64(untern(i));
      if n <= 255 then t2(c"C",t1(c"int8_t")) else
      if n <= 65535 then t2(c"C",t1(c"int16_t")) else
      if n <= 4294967295 then t2(c"C",t1(c"int32_t")) else
      t2(c"C",t1(c"int64_t"))
   };
);
