
# Loosely based on this EBNF for ANSI C
# https://gist.github.com/Chubek/52884d1fa766fa16ae8d8f226ba105ad (Katayama Hirofumi MZ. License: MIT)
#
# The naming of production rules try to follow this format.
# However, there are also a large number of compiler-specific extensions that are parsed but mostly ignored
# Example: __extension__ ( f, g )

let std-c-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) { tokens = std-c-parse-external-declaration(tokens); }
);

let std-c-parse-external-declaration(tokens: List<Token>): Nil = (
   tokens = std-c-parse-function-definition();
   tokens = std-c-parse-declaration();
   tokens;
);

let std-c-parse-function-definition(tokens: List<Token>): List<Token> = (
   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
   if declaration-specifiers.first.is-some {
      let declarator = std-c-parse-declarator(tokens); tokens = declarator.second;
      if declarator.first.is-some {
         let declaration-list = std-c-parse-declaration-list(tokens); tokens = declaration-list.second;
         let compound-statement = std-c-parse-compound-statement(tokens); tokens = compound-statement.second;
         if compound-statement.first.is-some {
            # TODO Add to namespace
         }
      }
   };
   tokens;
);

let std-c-parse-declaration(tokens: List<Token>): List<Token> = (
   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
   if declaration-specifiers.first.is-some {
      let init-declarator-list = std-parse-init-declarator-list(tokens); tokens = init-declarator-list.second;
      tokens = std-c-take-expect(tokens, c";");
      # TODO Add to namespace
   };
   tokens = std-c-parse-static-assert-declaration(tokens);
   tokens = std-c-take-maybe(tokens, c";");
   tokens;
);

let std-c-parse-declaration-specifiers(tokens: List<Token>): Tuple<Maybe<List<CSpecifier>>,List<Token>> = (
   let declaration-specifier = std-c-parse-declaration-specifier(tokens); tokens = declaration-specifier.second;
   if let Some{spec=content} = declaration-specifier.first {
      let specs = [spec];
      while declaration-specifier.first.is-some {
         declaration-specifier = std-c-parse-declaration-specifier(tokens); tokens = declaration-specifier.second;
         if let Some{next-spec=content} = declaration-specifier.first {
            specs = cons( next-spec, specs );
         };
      };
      Tuple{ Some{specs}, tokens }
   } else Tuple{ (None :: Maybe<List<CSpecifier>>), tokens };
);

let std-c-parse-declaration-specifier(tokens: List<Token>): Tuple<Maybe<CSpecifier>,List<Token>> = (
   let storage-class-specifier = std-c-parse-storage-class-specifier(tokens);
   if storage-class-specifier.first.is-some then storage-class-specifier else {
      let type-specifier = std-c-parse-type-specifier(tokens);
      if type-specifier.first.is-some then type-specifier else {
         let type-qualifier = std-c-parse-type-qualifier(tokens);
         if type-qualifier.first.is-some then type-qualifier else {
            let function-specifier = std-c-parse-function-specifier(tokens);
            if function-specifier.first.is-some then function-specifier
            else std-c-parse-alignment-specifier(tokens);
         }
      }
   }
);

let std-c-parse-declarator(tokens: List<Token>): Tuple<Maybe<CDeclarator>,List<Token>> = (
   let original-tokens = tokens;
   let pointer = std-c-parse-pointer(tokens); tokens = pointer.second;
   let direct-declarator = std-c-direct-declarator(tokens);
   if let Some{dd=content} = direct-declarator.first {
      Tuple{ Some{CDeclarator{ pointer.first, dd }}, direct-declarator.second }
   } else {
      Tuple{ (None :: Maybe<CDeclarator>), original-tokens }
   }
);

let std-c-declaration-list(tokens: List<Token>): Tuple<Maybe<List<CDeclaration>>,List<Token>> = (
   let declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
   if let Some{decl=content} = declaration.first {
      let decls = [decl];
      declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
      while declaration.first.is-some {
         if let Some{decl-next=content} = declaration.first {
            decls = cons(decl-next, decls);
         }
      };
      Tuple{ Some{decls}, tokens }
   } else (Tuple{ (None :: Maybe<List<CDeclaration>>), tokens })
);

let std-c-parse-compound-statement(tokens: List<Token>): Tuple<Maybe<CDeclarationOrStatement>,List<Token>> = (
   if std-c-can-take(c"{") {
      tokens = std-c-take-maybe(tokens, c"{");
      let declaration-or-statement = std-c-parse-declaration-or-statement(tokens); tokens = declaration-or-statement.second;
      tokens = std-c-take-maybe(tokens, c"}");
      Tuple{ declaration-or-statement.first, tokens };
   } else Tuple{(None :: Maybe<CDeclarationOrStatement>), tokens}
);

let std-c-parse-declaration-or-statement(tokens: List<Token>): Tuple<Maybe<CDeclarationOrStatement>,List<Token>> = (
   let declaration = std-c-parse-declaration(tokens);
   if declaration.first.is-some then declaration else std-c-parse-statement(tokens);
);

let std-c-parse-init-declarator-list(tokens: List<Token>): Tuple<Maybe<List<CInitDeclarator>>,List<Token>> = (
   let init-declarator = std-c-parse-init-declarator(tokens);
   if let Some{dc=content} = init-declarator {
      let dcs = [dc];
      while init-declarator.first.is-some {
         init-declarator = std-c-parse-init-declarator(tokens);
         if let Some{dc2=content} = init-declarator {
            dcs = cons(dc, dcs);
         }
      };
      Tuple{ Some{dcs}, tokens }
   } else init-declarator;
);

let std-c-parse-init-declarator(tokens: List<Token>): Tuple<Maybe<CInitDeclarator>,List<Token>> = (
   let declarator = c-parse-declarator(tokens); tokens = declarator.second;
   if declarator.first.is-some {
      tokens = std-c-take-expect(tokens, c"=");
      let initializer = std-c-parse-initializer(tokens); tokens = declarator.second;
      Tuple{ CInitDeclarator{ declarator.first, initializer.first }, tokens }
   } else declarator
);

static-assert-declaration = '_Static_assert', '(', constant-expression, ',', string-literal, ')', ';';

storage-class-specifier = 'typedef'
                        | 'extern'
                        | 'static'
                        | '_Thread_local'
                        | 'auto'
                        | 'register';

type-specifier = 'void'
               | 'char'
               | 'short'
               | 'int'
               | 'long'
               | 'float'
               | 'double'
               | 'signed'
               | 'unsigned'
               | '_Bool'
               | '_Complex'
               | '_Imaginary'       (* non-mandated extension *)
               | atomic-type-specifier
               | struct-or-union-specifier
               | enum-specifier
               | typedef-name;

(* NOTE: Please define typedef-name as result of 'typedef'. *)
typedef-name = identifier;

type-qualifier = 'const'
               | 'restrict'
               | 'volatile'
               | '_Atomic';

function-specifier = 'inline'
                   | '_Noreturn';

alignment-specifier = '_Alignas', '(', type-name, ')'
                    | '_Alignas', '(', constant-expression, ')';

pointer = '*', [type-qualifier-list], [pointer];

direct-declarator = identifier
                  | '(', declarator, ')'
                  | direct-declarator, '[', ['*'], ']'
                  | direct-declarator, '[', 'static', [type-qualifier-list], assignment-expression, ']'
                  | direct-declarator, '[', type-qualifier-list, ['*'], ']'
                  | direct-declarator, '[', type-qualifier-list, ['static'], assignment-expression, ']'
                  | direct-declarator, '[', assignment-expression, ']'
                  | direct-declarator, '(', parameter-type-list, ')'
                  | direct-declarator, '(', identifier-list, ')'
                  | direct-declarator, '(', ')';

identifier-list = identifier, {',', identifier};

initializer-list = designative-initializer, {',', designative-initializer};

designative-initializer = [designation], initializer;

initializer = '{', initializer-list, [','], '}'
            | assignment-expression;

constant-expression = conditional-expression;  (* with constraints *)

atomic-type-specifier = '_Atomic', '(', type-name, ')';

struct-or-union-specifier = struct-or-union, '{', struct-declaration-list, '}'
                          | struct-or-union, identifier, ['{', struct-declaration-list, '}'];

struct-or-union = 'struct'
                | 'union';

struct-declaration-list = struct-declaration, {struct-declaration};

struct-declaration = specifier-qualifier-list, ';'     (* for anonymous struct/union *)
                   | specifier-qualifier-list, struct-declarator-list, ';'
                   | static-assert-declaration;

enum-specifier = 'enum', '{', enumerator-list, [','], '}'
               | 'enum', identifier, ['{', enumerator-list, [','], '}'];

enumerator-list = enumerator, {',', enumerator};

(* NOTE: Please define enumeration-constant for identifier inside enum { ... }. *)
enumerator = enumeration-constant, ['=', constant-expression];

enumeration-constant = identifier;

type-name = specifier-qualifier-list, [abstract-declarator];

specifier-qualifier-list = specifier-qualifier, {specifier-qualifier};

specifier-qualifier = type-specifier | type-qualifier;

abstract-declarator = pointer, [direct-abstract-declarator]
                    | direct-abstract-declarator;

direct-abstract-declarator = '(', abstract-declarator, ')'
                           | '(', parameter-type-list, ')'
                           | '(', ')'
                           | '[', ['*'], ']'
                           | '[', 'static', [type-qualifier-list], assignment-expression, ']'
                           | '[', type-qualifier-list, [['static'], assignment-expression], ']'
                           | '[', assignment-expression, ']'
                           | direct-abstract-declarator, '[', ['*'], ']'
                           | direct-abstract-declarator, '[', 'static', [type-qualifier-list], assignment-expression, ']'
                           | direct-abstract-declarator, '[', type-qualifier-list, [['static'], assignment-expression], ']'
                           | direct-abstract-declarator, '[', assignment-expression, ']'
                           | direct-abstract-declarator, '(', parameter-type-list, ')'
                           | direct-abstract-declarator, '(', ')';

struct-declarator-list = struct-declarator, {',', struct-declarator};

type-qualifier-list = type-qualifier, {type-qualifier};

parameter-type-list = parameter-list, [',', '...'];

struct-declarator = ':', constant-expression
                  | declarator, [':', constant-expression];

assignment-operator = '=' 
                    | '*=' 
                    | '/=' 
                    | '%=' 
                    | '+=' 
                    | '-=' 
                    | '<<=' 
                    | '>>=' 
                    | '&=' 
                    | '^=' 
                    | '|=';

parameter-list = parameter-declaration, {',', parameter-declaration};

parameter-declaration = declaration-specifiers, [declarator | abstract-declarator];

expression = assignment-expression, {',', assignment-expression};

assignment-expression = conditional-expression
                      | unary-expression, assignment-operator, assignment-expression;

conditional-expression = logical-or-expression, ['?', expression, ':', conditional-expression];

logical-or-expression = logical-and-expression, {'||', logical-and-expression};

logical-and-expression = inclusive-or-expression, {'&&', inclusive-or-expression};

inclusive-or-expression = exclusive-or-expression, {'|', exclusive-or-expression};

exclusive-or-expression = and-expression, {'^', and-expression};

and-expression = equality-expression, {'&', equality-expression};

equality-expression = relational-expression, {('==' | '!='), relational-expression};

relational-expression = shift-expression, {('<' | '>' | '<=' | '>='), shift-expression};

shift-expression = additive-expression, {('<<' | '>>'), additive-expression};

additive-expression = multiplicative-expression, {('+' | '-'), multiplicative-expression};

multiplicative-expression = cast-expression, {('*' | '/' | '%'), cast-expression};

cast-expression = unary-expression
                | '(', type-name, ')', cast-expression;

unary-expression = postfix-expression
                 | ('++' | '--'), unary-expression
                 | unary-operator, cast-expression
                 | 'sizeof', unary-expression
                 | 'sizeof', '(', type-name, ')'
                 | '_Alignof', '(', type-name, ')';

postfix-expression = primary-expression
                   | postfix-expression, '[', expression, ']'
                   | postfix-expression, '(', [argument-expression-list], ')'
                   | postfix-expression, ('.' | '->'), identifier
                   | postfix-expression, ('++' | '--')
                   | '(', type-name, ')', '{', initializer-list, [','], '}';

unary-operator = '&'
               | '*'
               | '+'
               | '-'
               | '~'
               | '!';

primary-expression = identifier
                   | constant
                   | string
                   | '(', expression, ')'
                   | generic-selection;

argument-expression-list = assignment-expression, {',', assignment-expression};

constant = integer-constant
         | character-constant
         | floating-constant
         | enumeration-constant;

string = string-literal
       | '__func__';

generic-selection = '_Generic', '(', assignment-expression, ',', generic-assoc-list, ')';

generic-assoc-list = generic-association, {',', generic-association};

generic-association = type-name, ':', assignment-expression
                    | 'default', ':', assignment-expression;

designation = designator-list, '=';

designator-list = designator, {designator};

designator = '[', constant-expression, ']'
           | '.', identifier;

statement = labeled-statement
          | compound-statement
          | expression-statement
          | selection-statement
          | iteration-statement
          | jump-statement;

labeled-statement = identifier, ':', statement
                  | 'case', constant-expression, ':', statement
                  | 'default', ':', statement;

expression-statement = [expression], ';';

selection-statement = 'if', '(', expression, ')', statement, 'else', statement
                    | 'if', '(', expression, ')', statement
                    | 'switch', '(', expression, ')', statement;

 iteration-statement = 'while', '(', expression, ')', statement
                     | 'do', statement, 'while', '(', expression, ')', ';'
                     | 'for', '(', [expression], ';', [expression], ';', [expression], ')', statement
                     | 'for', '(', declaration, [expression], ';', [expression], ')', statement;

jump-statement = 'goto', identifier, ';'
               | 'continue', ';'
               | 'break', ';'
               | 'return', [expression], ';';
