
# Loosely based on the attached EBNF (c-grammar.ebnf) for ANSI C
# (Katayama Hirofumi MZ. License: MIT)
#
# The naming of production rules try to follow this format.
# However, there are also a large number of compiler-specific extensions that are parsed but mostly ignored
# Example: __extension__ ( f, g )

type CTerm = CInteger{value:String}
           | CCharacter{value:String}
           | CFloating{value:String}
           | CEnumeration{value:String}
           | CString{value:String}
           | CIdentifier{value:String}
           | CType1{value:String}
           | CList{value:List<CTerm>[]}
           | CMaybe{value:Maybe<CTerm>[]}
           | CZOp{op:String}
           | CCompound{terms:List<CTerm>[]}
           | CPointer{qualifiers:Maybe<List<CTerm>>[], next:Maybe<CTerm>[]}
           | CInitializer{designator:List<CTerm>[], initializer:CTerm[]}
           | CInitializerList{terms:List<CTerm>[]}
           | CUnaryPostfix{op:String, arg:CTerm[]}
           | CUnaryPrefix{op:String, arg:CTerm[]}
           | CBinaryOp{op:String, arg1:CTerm[], arg2:CTerm[]}
           | CTernaryOp{op:String, arg1:CTerm[], arg2:CTerm[], arg3: CTerm[]}
           | CFor{op:String, arg1:Maybe<CTerm>[], arg2:Maybe<CTerm>[], arg3: Maybe<CTerm>[], stmt:CTerm[]}
           | CAccessor{accessor:String, field:String, arg:CTerm[]};

let cmp(l: CTerm, r: CTerm): Ord = (
   if $".0"(l) != $".0"(r) then cmp($".0"(l), $".0"(r))
   else match Tuple{l, r} {
      Tuple{ first:CInteger{lv=value}, second:CInteger{rv=value} } => cmp(lv, rv);
      Tuple{ first:CCharacter{lv=value}, second:CCharacter{rv=value} } => cmp(lv, rv);
      Tuple{ first:CFloating{lv=value}, second:CFloating{rv=value} } => cmp(lv, rv);
      Tuple{ first:CEnumeration{lv=value}, second:CEnumeration{rv=value} } => cmp(lv, rv);
      Tuple{ first:CString{lv=value}, second:CString{rv=value} } => cmp(lv, rv);
      Tuple{ first:CIdentifier{lv=value}, second:CIdentifier{rv=value} } => cmp(lv, rv);
      Tuple{ first:CType1{lv=value}, second:CType1{rv=value} } => cmp(lv, rv);
      Tuple{ first:CList{lv=value}, second:CList{rv=value} } => cmp(lv, rv);
      Tuple{ first:CMaybe{lv=value}, second:CMaybe{rv=value} } => cmp(lv, rv);
      Tuple{ first:CZOp{lv=op}, second:CZOp{rv=op} } => cmp(lv, rv);
      Tuple{ first:CCompound{lterms=terms}, second:CCompound{rterms=terms} } => cmp(lterms, rterms);
      Tuple{ first:CPointer{lq=qualifiers,ln=next}, second:CPointer{rq=qualifiers,rn=next} } => cmp(lq,rq) && cmp(ln,rn);
      Tuple{ first:CInitializer{ld=designator,li=initializer}, second:CInitializer{rd=designator,ri=initializer} } => cmp(ld,rd) && cmp(li,ri);
      Tuple{ first:CInitializerList{lterms=terms}, second:CInitializerList{rterms=terms} } => cmp(lterms, rterms);
      Tuple{ first:CUnaryPrefix{lop=op,larg=arg}, second:CUnaryPrefix{rop=op,rarg=arg} } => cmp(lop, rop) && cmp(larg,rarg);
      Tuple{ first:CUnaryPostfix{lop=op,larg=arg}, second:CUnaryPostfix{rop=op,rarg=arg} } => cmp(lop, rop) && cmp(larg,rarg);
      Tuple{ first:CBinaryOp{lop=op,larg1=arg1,larg2=arg2}, second:CBinaryOp{rop=op,rarg1=arg1,rarg2=arg2} } => cmp(lop, rop) && cmp(larg1,rarg1) && cmp(larg2,rarg2);
      Tuple{ first:CTernaryOp{lop=op,larg1=arg1,larg2=arg2,larg3=arg3}, second:CTernaryOp{rop=op,rarg1=arg1,rarg2=arg2,rarg3=arg3} } => cmp(lop, rop) && cmp(larg1,rarg1) && cmp(larg2,rarg2) && cmp(larg3,rarg3);
      Tuple{ first:CFor{lop=op,larg1=arg1,larg2=arg2,larg3=arg3,lst=stmt}, second:CFor{rop=op,rarg1=arg1,rarg2=arg2,rarg3=arg3,rst=stmt} } =>
      cmp(lop, rop) && cmp(larg1,rarg1) && cmp(larg2,rarg2) && cmp(larg3,rarg3) && cmp(lst,rst);
      Tuple{ first:CAccessor{lacc=accessor,lf=field,larg=arg}, second:CAccessor{racc=accessor,rf=field,rarg=arg} } => cmp(lacc,racc) && cmp(lf,rf) && cmp(larg,rarg);
   }
);

let to-smart-string(l: CTerm): String = (
   match l {
      CInteger{rv=value} => "{Integer \{rv}}";
      CCharacter{rv=value} => "{Character \{rv}}";
      CFloating{rv=value} => "{Floating \{rv}}";
      CEnumeration{rv=value} => "{Enumeration \{rv}}";
      CMaybe{rv=value} => "{Maybe \{rv}}";
      CList{rv=value} => "{List \{rv}}";
      CString{rv=value} => "{String \{rv}}";
      CType1{rv=value} => "{Type \{rv}}";
      CZOp{op=op} => "{ZOp \{op}}";
      CIdentifier{rv=value} => "{Identifier \{rv}}";
      CUnaryPrefix{rop=op,rarg=arg} => "{Prefix \{rop} \{rarg}}";
      CUnaryPostfix{rop=op,rarg=arg} => "{Postfix \{rop} \{rarg}}";
      CBinaryOp{op=op,arg1=arg1,arg2=arg2} => "{BinaryOp \{op} \{arg1} \{arg2}}";
      CAccessor{racc=accessor,rf=field,rarg=arg} => "{Accessor \{racc} \{rf} \{rarg}}";
   }
);

let std-c-parse(tokens: List<Token>): Nil = (
#   while non-zero(tokens) { tokens = std-c-parse-external-declaration(tokens); }
);

let std-c-is-reserved-word(tk: String): U64 = (
   let reserved = false;
   if tk == "auto" then (reserved = true);
   if tk == "double" then (reserved = true);
   if tk == "int" then (reserved = true);
   if tk == "struct" then (reserved = true);
   if tk == "break" then (reserved = true);
   if tk == "else" then (reserved = true);
   if tk == "long" then (reserved = true);
   if tk == "switch" then (reserved = true);
   if tk == "case" then (reserved = true);
   if tk == "enum" then (reserved = true);
   if tk == "register" then (reserved = true);
   if tk == "typedef" then (reserved = true);
   if tk == "char" then (reserved = true);
   if tk == "extern" then (reserved = true);
   if tk == "return" then (reserved = true);
   if tk == "union" then (reserved = true);
   if tk == "const" then (reserved = true);
   if tk == "float" then (reserved = true);
   if tk == "short" then (reserved = true);
   if tk == "unsigned" then (reserved = true);
   if tk == "continue" then (reserved = true);
   if tk == "for" then (reserved = true);
   if tk == "signed" then (reserved = true);
   if tk == "void" then (reserved = true);
   if tk == "default" then (reserved = true);
   if tk == "goto" then (reserved = true);
   if tk == "sizeof" then (reserved = true);
   if tk == "volatile" then (reserved = true);
   if tk == "do" then (reserved = true);
   if tk == "if" then (reserved = true);
   if tk == "static" then (reserved = true);
   if tk == "while" then (reserved = true);
   if tk == "_Bool" then (reserved = true);
   if tk == "_Imaginary" then (reserved = true);
   if tk == "restrict" then (reserved = true);
   if tk == "_Complex" then (reserved = true);
   if tk == "inline" then (reserved = true);
   if tk == "_Alignas" then (reserved = true);
   if tk == "_Generic" then (reserved = true);
   if tk == "_Thread_local" then (reserved = true);
   if tk == "_Alignof" then (reserved = true);
   if tk == "_Noreturn" then (reserved = true);
   if tk == "_Atomic" then (reserved = true);
   if tk == "_Static_assert" then (reserved = true);
   reserved
);

let std-c-has-class(tks: String, cls: String): U64 = (
   let tk = untern(tks);
   match cls {
      "identifier" => tk == r/^[a-zA-Z_][a-zA-Z0-9_]*/ && not(std-c-is-reserved-word(tks));
      "integer" => tk == r/^[0-9]+([uU]|[lL]|wb|WB)*/                # decimal constant
                || tk == r/^[0][0-7]+([uU]|[lL]|wb|WB)*/             # octal constant
                || tk == r/^[0][x][0-9a-fA-F]+([uU]|[lL]|wb|WB)*/    # hexadecimal constant
                || tk == r/^[0][bB][01]+([uU]|[lL]|wb|WB)*/;         # binary constant
      "character" => tk == r/^(u8|u|U|L)?[']([^']|([\\][']))+[']/;    # character constant
      "floating" => tk == r/^[0-9]+([.][0-9]+)?([eE][0-9]+)?[fF]?/                                        # decimal constant
                 || tk == r/^[0][x][0-9a-fA-F]+([.][0-9a-fA-F]+)?([eE][0-9a-fA-F]+)?([pP][0-9]+)[fF]?/;   # hexadecimal constant
      "string" => tk == r/^[RLuU8]*["]([^"\\]|([\\].))*["]/;
      "enumeration" => std-c-enumeration-constant-index.has(tks);
      _ => tk == cls;
   }
);

let std-c-can-take(tokens: List<Token>, cls: String): U64 = (
   non-zero(tokens) && std-c-has-class(head(tokens).skey, cls)
);

let std-c-take-expect(tokens: List<Token>, cls: String): List<Token> = (
   if non-zero(tokens) && std-c-has-class(head(tokens).skey, cls) then tail(tokens)
   else (print("Expected token [\{cls}] at \{tokens.formatted-location}\n"); exit(1); tokens);
);

let std-c-take-maybe(tokens: List<Token>, cls: String): List<Token> = (
   if non-zero(tokens) && std-c-has-class(head(tokens).skey, cls) then tail(tokens)
   else tokens;
);

#let std-c-parse-external-declaration(tokens: List<Token>): Nil = (
#   tokens = std-c-parse-function-definition();
#   tokens = std-c-parse-declaration();
#   tokens;
#);

#let std-c-parse-function-definition(tokens: List<Token>): List<Token> = (
#   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
#   if declaration-specifiers.first.is-some {
#      let declarator = std-c-parse-declarator(tokens); tokens = declarator.second;
#      if declarator.first.is-some {
#         let declaration-list = std-c-parse-declaration-list(tokens); tokens = declaration-list.second;
#         let compound-statement = std-c-parse-compound-statement(tokens); tokens = compound-statement.second;
#         if compound-statement.first.is-some {
#            # TODO Add to namespace
#         }
#      }
#   };
#   tokens;
#);

#let std-c-parse-declaration(tokens: List<Token>): List<Token> = (
#   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
#   if declaration-specifiers.first.is-some {
#      let init-declarator-list = std-parse-init-declarator-list(tokens); tokens = init-declarator-list.second;
#      tokens = std-c-take-expect(tokens, c";");
#      # TODO Add to namespace
#   };
#   tokens = std-c-parse-static-assert-declaration(tokens);
#   tokens = std-c-take-maybe(tokens, c";");
#   tokens;
#);

#let std-c-parse-declaration-specifiers(tokens: List<Token>): Tuple<Maybe<List<CSpecifier>>,List<Token>> = (
#   let declaration-specifier = std-c-parse-declaration-specifier(tokens); tokens = declaration-specifier.second;
#   if let Some{spec=content} = declaration-specifier.first {
#      let specs = [spec];
#      while declaration-specifier.first.is-some {
#         declaration-specifier = std-c-parse-declaration-specifier(tokens); tokens = declaration-specifier.second;
#         if let Some{next-spec=content} = declaration-specifier.first {
#            specs = cons( next-spec, specs );
#         };
#      };
#      Tuple{ Some{specs}, tokens }
#   } else Tuple{ (None :: Maybe<List<CSpecifier>>), tokens };
#);

#let std-c-parse-declaration-specifier(tokens: List<Token>): Tuple<Maybe<CSpecifier>,List<Token>> = (
#   let storage-class-specifier = std-c-parse-storage-class-specifier(tokens);
#   if storage-class-specifier.first.is-some then storage-class-specifier else {
#      let type-specifier = std-c-parse-type-specifier(tokens);
#      if type-specifier.first.is-some then type-specifier else {
#         let type-qualifier = std-c-parse-type-qualifier(tokens);
#         if type-qualifier.first.is-some then type-qualifier else {
#            let function-specifier = std-c-parse-function-specifier(tokens);
#            if function-specifier.first.is-some then function-specifier
#            else std-c-parse-alignment-specifier(tokens);
#         }
#      }
#   }
#);

#let std-c-parse-declarator(tokens: List<Token>): Tuple<Maybe<CDeclarator>,List<Token>> = (
#   let original-tokens = tokens;
#   let pointer = std-c-parse-pointer(tokens); tokens = pointer.second;
#   let direct-declarator = std-c-direct-declarator(tokens);
#   if let Some{dd=content} = direct-declarator.first {
#      Tuple{ Some{CDeclarator{ pointer.first, dd }}, direct-declarator.second }
#   } else {
#      Tuple{ (None :: Maybe<CDeclarator>), original-tokens }
#   }
#);

#let std-c-declaration-list(tokens: List<Token>): Tuple<Maybe<List<CDeclaration>>,List<Token>> = (
#   let declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
#   if let Some{decl=content} = declaration.first {
#      let decls = [decl];
#      declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
#      while declaration.first.is-some {
#         if let Some{decl-next=content} = declaration.first {
#            decls = cons(decl-next, decls);
#         }
#      };
#      Tuple{ Some{decls}, tokens }
#   } else (Tuple{ (None :: Maybe<List<CDeclaration>>), tokens })
#);

let std-c-parse-compound-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "{") {
      let stmts = [] :: List<CTerm>;
      tokens = std-c-take-expect(tokens, "{");
      let declaration-or-statement = std-c-parse-declaration-or-statement(tokens); tokens = declaration-or-statement.second;
      while declaration-or-statement.first.is-some {
         stmts = cons( declaration-or-statement.first.get-or-panic, stmts );
         declaration-or-statement = std-c-parse-declaration-or-statement(tokens); tokens = declaration-or-statement.second;
      };
      tokens = std-c-take-expect(tokens, "}");
      Tuple{ Some{CCompound{close(stmts.reverse)}}, tokens };
   } else Tuple{ no, tokens}
);

let std-c-parse-declaration-or-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#   TODO: declaration?
#   let declaration = std-c-parse-declaration(tokens);
#   if declaration.first.is-some then declaration else std-c-parse-statement(tokens);
   std-c-parse-statement(tokens);
);

#let std-c-parse-init-declarator-list(tokens: List<Token>): Tuple<Maybe<List<CInitDeclarator>>,List<Token>> = (
#   let init-declarator = std-c-parse-init-declarator(tokens);
#   if let Some{dc=content} = init-declarator {
#      let dcs = [dc];
#      while init-declarator.first.is-some {
#         init-declarator = std-c-parse-init-declarator(tokens);
#         if let Some{dc2=content} = init-declarator {
#            dcs = cons(dc, dcs);
#         }
#      };
#      Tuple{ Some{dcs}, tokens }
#   } else init-declarator;
#);

#let std-c-parse-init-declarator(tokens: List<Token>): Tuple<Maybe<CInitDeclarator>,List<Token>> = (
#   let declarator = c-parse-declarator(tokens); tokens = declarator.second;
#   if declarator.first.is-some {
#      tokens = std-c-take-expect(tokens, c"=");
#      let initializer = std-c-parse-initializer(tokens); tokens = declarator.second;
#      Tuple{ CInitDeclarator{ declarator.first, initializer.first }, tokens }
#   } else declarator
#);

#let std-c-parse-static-assert-declaration(tokens: List<Token>): Tuple<Maybe<CStaticAssertDeclaration>,List<Token>> = (
#   if std-c-can-take(tokens, c"_Static_assert") {
#      tokens = std-c-take-expect(tokens, c"_Static_assert");
#      tokens = std-c-take-expect(tokens, c"(");
#      let constant-expression = std-c-parse-constant-expression(tokens);
#      if constant-expression.first.is-none { std-c-take-expect(tokens, c"[Constant Expression]"); };
#      tokens = std-c-take-expect(tokens, c",");
#      tokens = std-c-take-expect(tokens, c")");
#      tokens = std-c-take-expect(tokens, c";");
#      let string-literal = std-c-parse-string-literal(tokens);
#      if let Some{ce=content} = constant-expression {
#         if let Some{sl=content} = string-literal {
#            Tuple{ Some{CStaticAssertDeclaration{ ce, sl }}, tokens }
#         } else Tuple{ (None :: Maybe<CStaticAssertDeclaration>), tokens };
#      } else Tuple{ (None :: Maybe<CStaticAssertDeclaration>), tokens };
#      Tuple{ Some{CStaticAssertDeclaration{ constant-expression. }} }
#   } else Tuple{ (None :: Maybe<CStaticAssertDeclaration>), tokens }
#);

let std-c-parse-storage-class-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "typedef") then (tokens = std-c-take-expect(tokens, "typedef"); Tuple{Some{CType1{"typedef"}}, tokens} )
   else if std-c-can-take(tokens, "extern") then (tokens = std-c-take-expect(tokens, "extern"); Tuple{Some{CType1{"extern"}}, tokens} )
   else if std-c-can-take(tokens, "static") then (tokens = std-c-take-expect(tokens, "static"); Tuple{Some{CType1{"static"}}, tokens} )
   else if std-c-can-take(tokens, "_Thread_local") then (tokens = std-c-take-expect(tokens, "_Thread_local"); Tuple{Some{CType1{"_Thread_local"}}, tokens} )
   else if std-c-can-take(tokens, "auto") then (tokens = std-c-take-expect(tokens, "auto"); Tuple{Some{CType1{"auto"}}, tokens} )
   else if std-c-can-take(tokens, "register") then (tokens = std-c-take-expect(tokens, "register"); Tuple{Some{CType1{"register"}}, tokens} )
   else Tuple{no, tokens}
);

let std-c-parse-type-qualifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "const") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "const"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "restrict") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "restrict"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "volatile") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "volatile"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "_Atomic") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Atomic"); Tuple{Some{CType1{t}}, tokens} )
   else Tuple{no, tokens}
);

#let std-c-parse-function-specifier(tokens: List<Token>): Tuple<Maybe<CFunctionSpecifier>,List<Token>> = (
#   if std-c-can-take("inline", tokens) then (tokens = std-c-take-expect("inline", tokens); Tuple{Some{CType{c"inline"}}, tokens} )
#   else if std-c-can-take("_Noreturn", tokens) then (tokens = std-c-take-expect("_Noreturn", tokens); Tuple{Some{CType{c"_Noreturn"}}, tokens} )
#   else Tuple{None :: Maybe<CTypeQualifier>, tokens}
#);

#let std-c-parse-alignment-specifier(tokens: List<Token>): Tuple<Maybe<CAlignmentSpecifier>,List<Token>> = (
#   if std-c-can-take("_Alignas", tokens) then {
#      tokens = std-c-take-expect("_Alignas", tokens);
#      tokens = std-c-take-expect("(", tokens);
#      if let Tuple{first:Some{tn=content},tokens2=second} = std-c-parse-type-name(tokens) {
#         tokens = std-c-take-expect(")", tokens);
#         Tuple{ Some{ tn }, tokens }
#      } else if let Tuple{first:Some{ce=content},tokens2=second} = std-c-parse-constant-expression(tokens) {
#         Tuple{ Some{ ce }, tokens }
#      } else std-c-take-expect(c"[Alignment Specifier]");
#   } else Tuple{None :: Maybe<CFunctionSpecifier>, tokens}
#);

#let std-c-parse-direct-declarator(tokens: List<Token>): Tuple<Maybe<CDeclarator>,List<Token>> = (
#   let base-declarator = if let Tuple{Some{ident=contents}=first,tokens2=second} = std-c-parse-identifier(tokens) then {
#      tokens = tokens2;
#      CDeclaratorIdentifier{ ident }
#   } else if std-c-can-take(c"(") then {
#      tokens = std-c-take-expect(c"(");
#      let declarator = std-c-parse-declarator(tokens); tokens = declarator.second;
#      if declarator.is-none { tokens = std-c-take-expect("[Declarator]", tokens); };
#      tokens = std-c-take-expect(c")");
#      declarator;
#   } else std-c-take-expect("[Direct Declarator]", tokens);
#   while std-c-can-take("(") || std-c-can-take("[") {
#      if std-c-can-take("(") {
#         tokens = std-c-take-expect("(");
#         if let Tuple{first:Some{tl=content},tokens3=second} = std-c-parse-type-list(tokens) {
#            tokens = std-c-take-expect(")");
#            tokens = tokens3;
#            base-declarator = CDeclaratorParamList{ base-declarator, tl };
#         } else if let Tuple{first:Some{tl=content},tokens4=second} = std-c-parse-identifier-list(tokens) {
#            tokens = std-c-take-expect(")");
#            tokens = tokens4;
#            base-declarator = CDeclaratorParamList{ base-declarator, tl };
#         } else {
#            tokens = std-c-take-expect(")");
#            base-declarator = CDeclaratorParamList{ base-declarator, [] :: List<Tuple<CString,CType>> };
#         };
#      } else {
#         tokens = std-c-take-expect("[");
#         let type-qualifiers = [] :: List<CType>;
#         if std-c-can-take(c"static", tokens) then {
#            tokens = std-c-take-expect("static");
#            type-qualifiers = cons( CType{c"static"}, type-qualifiers );
#         };
#         if let Tuple{first:Some{tq=content},tokens5=second} = std-c-parse-type-qualifier-list(tokens) {
#            type-qualifiers = type-qualifiers + tq;
#         };
#         if std-c-can-take(c"static", tokens) then {
#            tokens = std-c-take-expect("static");
#            type-qualifiers = cons( CType{c"static"}, type-qualifiers );
#         };
#         let indirect = if std-c-can-take(c"*", tokens) then {
#            tokens = std-c-take-expect("*");
#            true;
#         } else false;
#         let assignment-expression = None :: Maybe<CAssignmentExpression>;
#         if let Tuple{first:Some{ae=content},tokens6=second} = std-c-parse-assignment-expression(tokens) {
#            tokens = tokens6;
#            assignment-expression = ae;
#         };
#         tokens = std-c-take-expect("]");
#         base-declarator = CDeclaratorBracket{ base-declarator, type-qualifiers, indirect, assignment-expression };
#      };
#   };
#   Tuple{ Some{base-declarator}, tokens };
#);

let std-c-parse-identifier-list(tokens: List<Token>): Tuple<Maybe<List<String>>,List<Token>> = (
   let no = None :: Maybe<List<String>>;
   if std-c-can-take(tokens, "identifier") then {
      let ids = [head(tokens).skey];
      tokens = std-c-take-expect(tokens, "identifier");
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         if non-zero(tokens) {
            ids = cons( head(tokens).skey, ids );
         };
         tokens = std-c-take-expect(tokens, "identifier");
      };
      Tuple{ Some{ids.reverse}, tokens }
   } else Tuple{no, tokens};
);

let std-c-parse-designative-initializer(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   let designation = std-c-parse-designation(tokens); tokens = designation.second;
   let initializer = std-c-parse-initializer(tokens); tokens = initializer.second;
   if designation.first.is-some && initializer.first.is-some
   then Tuple{ Some{CInitializer{close(designation.first.get-or-panic),close(initializer.first.get-or-panic)}}, tokens }
   else if initializer.first.is-some
   then Tuple{ Some{CInitializer{close([] :: List<CTerm>),close(initializer.first.get-or-panic)}}, tokens }
   else Tuple{ no, tokens };
);

let std-c-parse-initializer-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = None :: Maybe<List<CTerm>>;
   let di = std-c-parse-designative-initializer(tokens); tokens = di.second;
   if di.first.is-some {
      let dis = [di.first.get-or-panic];
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         di = std-c-parse-designative-initializer(tokens); tokens = di.second;
         if di.first.is-some { dis = cons(di.first.get-or-panic, dis); };
      };
      Tuple{ Some{dis.reverse}, tokens }
   } else Tuple{ no, tokens }
);

let std-c-parse-initializer(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "{") {
      tokens = std-c-take-expect(tokens, "{");
      let initializer-list = std-c-parse-initializer-list(tokens); tokens = initializer-list.second;
      if std-c-can-take(tokens, ",") {
         initializer-list.second = std-c-take-expect(tokens, ",");
      };
      initializer-list.second = std-c-take-expect(tokens, "}");
      if initializer-list.first.is-some
      then Tuple{ Some{CInitializerList{close(initializer-list.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else std-c-parse-assignment-expression(tokens);
);


#atomic-type-specifier = '_Atomic', '(', type-name, ')';

#struct-or-union-specifier = struct-or-union, '{', struct-declaration-list, '}'
#                          | struct-or-union, identifier, ['{', struct-declaration-list, '}'];

#struct-declaration-list = struct-declaration, {struct-declaration};

#struct-declaration = specifier-qualifier-list, ';'     (* for anonymous struct/union *)
#                   | specifier-qualifier-list, struct-declarator-list, ';'
#                   | static-assert-declaration;

#enum-specifier = 'enum', '{', enumerator-list, [','], '}'
#               | 'enum', identifier, ['{', enumerator-list, [','], '}'];

#enumerator-list = enumerator, {',', enumerator};

#(* NOTE: Please define enumeration-constant for identifier inside enum { ... }. *)
#enumerator = enumeration-constant, ['=', constant-expression];

#type-name = specifier-qualifier-list, [abstract-declarator];

let std-c-parse-type-name(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   let sql = std-c-parse-specifier-qualifier-list(tokens);
   if sql.first.is-some then {
      tokens = sql.second;
      let ad = std-c-parse-abstract-declarator(tokens); tokens = ad.second;
      Tuple{ Some{CBinaryOp{ "TypeName", close(CList{close(sql.first.get-or-panic)}), close(CMaybe{close(ad.first)}) }}, tokens }
   } else Tuple{ no, tokens }
);

let std-c-parse-specifier-qualifier-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = None :: Maybe<List<CTerm>>;
   let sq = std-c-parse-specifier-qualifier(tokens);
   if sq.first.is-some {
      let sql = [sq.first.get-or-panic];
      tokens = sq.second;
      while sq.first.is-some {
         sq = std-c-parse-specifier-qualifier(tokens);
         if sq.first.is-some {
            sql = cons( sq.first.get-or-panic, sql );
            tokens = sq.second;
         };
      };
      Tuple{ Some{sql.reverse}, tokens }
   } else Tuple { no, tokens }
);

let std-c-parse-specifier-qualifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let sq = std-c-parse-type-specifier(tokens);
   if sq.first.is-none { sq = std-c-parse-type-qualifier(tokens); };
   sq
);

let std-c-typedef-name-index = {} :: HashtableEq<String,Bool>;
let std-c-parse-typedef-name(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if non-zero(tokens) && std-c-typedef-name-index.has(head(tokens).skey) {
      Tuple{ Some{CType1{head(tokens).skey}}, tokens }
   } else Tuple{ no, tokens }
);

let std-c-parse-type-specifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   if std-c-can-take(tokens, "void") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "void"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "char") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "char"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "short") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "short"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "int") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "int"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "long") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "long"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "float") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "float"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "double") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "double"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "signed") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "signed"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "unsigned") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "unsigned"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "_Bool") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Bool"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "_Complex") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Complex"); Tuple{Some{CType1{t}}, tokens} )
   else if std-c-can-take(tokens, "_Imaginary") then (let t = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Imaginary"); Tuple{Some{CType1{t}}, tokens} )
#   else if let Tuple{Some{ats=contents}=first,tokens2=second} = std-c-atomic-type-specifier(tokens) then Tuple{Some{ats}, tokens2}
#   else if let Tuple{Some{sou=contents}=first,tokens3=second} = std-c-struct-or-union-specifier(tokens) then Tuple{Some{sou}, tokens3}
#   else if let Tuple{Some{enm=contents}=first,tokens4=second} = std-c-enum-specifier(tokens) then Tuple{Some{enm}, tokens4}
   else std-c-parse-typedef-name(tokens)
);

let std-c-parse-pointer(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "*") then {
      tokens = std-c-take-expect(tokens, "*");
      let type-qualifier-list = std-c-parse-type-qualifier-list(tokens); tokens = type-qualifier-list.second;
      let next-pointer = std-c-parse-pointer(tokens); tokens = next-pointer.second;
      Tuple{ Some{CPointer{ close(type-qualifier-list.first), close(next-pointer.first) }}, tokens }
   } else Tuple{no, tokens}   
);

let std-c-parse-abstract-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   let p = std-c-parse-pointer(tokens); tokens = p.second;
   let dac = std-c-parse-direct-abstract-declarator(tokens); tokens = dac.second;
   if p.first.is-some && dac.first.is-some
   then Tuple{ Some{CBinaryOp{"AbstractDeclarator",close(p.first.get-or-panic),close(dac.first.get-or-panic)}}, tokens }
   else if dac.first.is-some
   then Tuple{ dac.first, tokens }
   else Tuple{ no, tokens }
);

let std-c-parse-direct-abstract-declarator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#direct-abstract-declarator = '(', abstract-declarator, ')'
#                           | '(', parameter-type-list, ')'
#                           | '(', ')'
#                           | '[', ['*'], ']'
#                           | '[', 'static', [type-qualifier-list], assignment-expression, ']'
#                           | '[', type-qualifier-list, [['static'], assignment-expression], ']'
#                           | '[', assignment-expression, ']'
#                           | direct-abstract-declarator, '[', ['*'], ']'
#                           | direct-abstract-declarator, '[', 'static', [type-qualifier-list], assignment-expression, ']'
#                           | direct-abstract-declarator, '[', type-qualifier-list, [['static'], assignment-expression], ']'
#                           | direct-abstract-declarator, '[', assignment-expression, ']'
#                           | direct-abstract-declarator, '(', parameter-type-list, ')'
#                           | direct-abstract-declarator, '(', ')';
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "(") then {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "(");
      let ad = std-c-parse-abstract-declarator(tokens);
      # '(', parameter-type-list, ')'
      if ad.first.is-none {
         ad.first = Some{CUnaryPrefix{"AbstractDeclarator",close(CZOp{op})}};
      };
      ad.second = std-c-take-expect(tokens, ")");
      ad
   } else if std-c-can-take(tokens, "[") then {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "[");
      if std-c-can-take(tokens, "*") {
         let p = head(tokens).skey; tokens = std-c-take-expect(tokens, "*");
         tokens = std-c-take-expect(tokens, "]");
         Tuple{ Some{CBinaryOp{"AbstractDeclarator",close(CZOp{op}),close(CType1{p})}}, tokens }
      } else if std-c-can-take(tokens, "]") {
         tokens = std-c-take-expect(tokens, "]");
         Tuple{ Some{CUnaryPrefix{"AbstractDeclarator",close(CZOp{op})}}, tokens }
      } else if std-c-can-take(tokens, "static") {
         Tuple{ no, tokens }
      } else {
         Tuple{ no, tokens }
      }
   } else Tuple{ no, tokens }   
);

#struct-declarator-list = struct-declarator, {',', struct-declarator};

let std-c-parse-type-qualifier-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = None :: Maybe<List<CTerm>>;
   let tq = std-c-parse-type-qualifier(tokens);
   if tq.first.is-some {
      tokens = tq.second;
      let tqs = [tq.first.get-or-panic];
      while tq.first.is-some {
         tq = std-c-parse-type-qualifier(tokens); tokens = tq.second;
         if tq.first.is-some { tqs = cons(tq.first.get-or-panic, tqs); };
      };
      Tuple{ Some{tqs.reverse}, tokens }
   } else Tuple{ no, tokens }
);

#parameter-type-list = parameter-list, [',', '...'];

#struct-declarator = ':', constant-expression
#                  | declarator, [':', constant-expression];

let std-c-parse-assignment-operator(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = None :: Maybe<String>;
   if not(non-zero(tokens)) then Tuple{ no, tokens }
   else if head(tokens).skey == "=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "*=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "/=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "%=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "+=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "-=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "<<=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == ">>=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "&=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "^=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "|=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-unary-operator(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = None :: Maybe<String>;
   if not(non-zero(tokens)) then Tuple{ no, tokens }
   else if head(tokens).skey == "&" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "*" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "+" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "-" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "~" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "!" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-struct-or-union(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = None :: Maybe<String>;
   if not(non-zero(tokens)) then Tuple{ no, tokens }
   else if head(tokens).skey == "struct" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "union" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-identifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "identifier") then Tuple{ Some{CIdentifier{head(tokens).skey}}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-enumeration-constant-index = {} :: HashtableEq<String,Bool>;

let std-c-parse-constant(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "integer") then Tuple{ Some{CInteger{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "character") then Tuple{ Some{CCharacter{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "floating") then Tuple{ Some{CFloating{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "enumeration") then Tuple{ Some{CEnumeration{head(tokens).skey}}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-string(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "string") then Tuple{ Some{CString{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "__func__") then Tuple{ Some{CString{head(tokens).skey}}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-primary-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let ts = std-c-parse-generic-selection(tokens);
   if ts.first.is-none then (ts = std-c-parse-constant(tokens));
   if ts.first.is-none then (ts = std-c-parse-identifier(tokens));
   if ts.first.is-none then (ts = std-c-parse-string(tokens));
   if ts.first.is-none && std-c-can-take(tokens, "(") {
      let tokens2 = std-c-take-expect(tokens, "(");
      ts = std-c-parse-expression(tokens2);
      ts.second = std-c-take-expect(ts.second, ")");
   };
   ts
);

#parameter-list = parameter-declaration, {',', parameter-declaration};

#parameter-declaration = declaration-specifiers, [declarator | abstract-declarator];

let std-c-parse-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-assignment-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, ",")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-assignment-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-assignment-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let ue = std-c-parse-unary-expression(tokens);
   if ue.first.is-some && (
      std-c-can-take(ue.second, "=")
   || std-c-can-take(ue.second, "*=")
   || std-c-can-take(ue.second, "/=")
   || std-c-can-take(ue.second, "%=")
   || std-c-can-take(ue.second, "+=")
   || std-c-can-take(ue.second, "-=")
   || std-c-can-take(ue.second, "<<=")
   || std-c-can-take(ue.second, ">>=")
   || std-c-can-take(ue.second, "&=")
   || std-c-can-take(ue.second, "^=")
   || std-c-can-take(ue.second, "|=")) {
      let op = head(ue.second).skey;
      let rest = std-c-parse-assignment-expression(tail(ue.second));
      if rest.first.is-some {
         Tuple{ Some{CBinaryOp{op, close(ue.first.get-or-panic), close(rest.first.get-or-panic)}}, rest.second }
      } else std-c-parse-conditional-expression(tokens);
   } else std-c-parse-conditional-expression(tokens);
);

let std-c-parse-constant-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   std-c-parse-conditional-expression(tokens)
);

let std-c-parse-conditional-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#conditional-expression = logical-or-expression, ['?', expression, ':', conditional-expression];
   std-c-parse-logical-or-expression(tokens);   
);

let std-c-parse-logical-or-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-logical-and-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "||")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-logical-and-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-logical-and-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-inclusive-or-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "&&")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-inclusive-or-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-inclusive-or-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-exclusive-or-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "|")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-exclusive-or-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-exclusive-or-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-and-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "^")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-and-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-and-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-equality-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "&")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-equality-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-equality-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-relational-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "==")  || std-c-can-take(tokens, "!=")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-relational-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-relational-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-shift-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "<")  || std-c-can-take(tokens, ">") ||
      std-c-can-take(tokens, "<=") || std-c-can-take(tokens, ">=")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-shift-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-shift-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-additive-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "<<") || std-c-can-take(tokens, ">>")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-additive-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-additive-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-multiplicative-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "+") || std-c-can-take(tokens, "-")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-multiplicative-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);

let std-c-parse-multiplicative-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-cast-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "*") || std-c-can-take(tokens, "/") || std-c-can-take(tokens, "%")
   ) {
      let op = head(tokens).skey; tokens = tail(tokens);
      let re = std-c-parse-cast-expression(tokens); tokens = re.second;
      let e = CBinaryOp{ op, close(expression.first.get-or-panic), close(re.first.get-or-panic) };
      expression = Tuple{ Some{e}, tokens };
   };
   expression
);


let std-c-parse-cast-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#cast-expression = unary-expression
#                | '(', type-name, ')', cast-expression;
   std-c-parse-unary-expression(tokens);
);


let std-c-parse-unary-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#unary-expression = postfix-expression
#                 | unary-operator, cast-expression
#                 | 'sizeof', '(', type-name, ')'
#                 | '_Alignof', '(', type-name, ')';
   if std-c-can-take(tokens, "++") || std-c-can-take(tokens, "--") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let inner = std-c-parse-unary-expression(tokens);
      if inner.first.is-some then Tuple{ Some{CUnaryPrefix{op, close(inner.first.get-or-panic)}}, inner.second }
      else inner;
   } else if std-c-can-take(tokens, "sizeof") {
      let op = head(tokens).skey; tokens = tail(tokens);
      if std-c-can-take(tokens, "(") {
         print("TODO: C parse unary expression sizeof(type)"); exit(1); std-c-parse-postfix-expression(tokens);
      } else {
         let inner = std-c-parse-unary-expression(tokens);
         if inner.first.is-some then Tuple{ Some{CUnaryPrefix{op, close(inner.first.get-or-panic)}}, inner.second }
         else inner;
      };
   } else std-c-parse-postfix-expression(tokens)
);


let std-c-parse-postfix-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-primary-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "[") || std-c-can-take(tokens, "(") ||
      std-c-can-take(tokens, ".") || std-c-can-take(tokens, "->") ||
      std-c-can-take(tokens, "++") || std-c-can-take(tokens, "--")
   ) {
      if std-c-can-take(tokens, "++") || std-c-can-take(tokens, "--") {
         let e = CUnaryPostfix{ head(tokens).skey, close(expression.first.get-or-panic) };
         tokens = tail(tokens);
         expression = Tuple{ Some{e}, tokens };
      } else if std-c-can-take(tokens, ".") || std-c-can-take(tokens, "->") {
         let accessor = head(tokens).skey; tokens = tail(tokens);
         if non-zero(tokens) {
            let e = CAccessor{ accessor, head(tokens).skey, close(expression.first.get-or-panic) };
            tokens = std-c-take-expect(tokens, "identifier");
            expression = Tuple{ Some{e}, tokens };
         } else std-c-take-expect(tokens, "identifier");
      } else {
         print("TODO: parse-postfix \{head(tokens).skey}"); exit(1);
#                   | postfix-expression, '[', expression, ']'
#                   | postfix-expression, '(', [argument-expression-list], ')'         
      };
   };
#postfix-expression = primary-expression
#                   | '(', type-name, ')', '{', initializer-list, [','], '}';
   expression
);


#argument-expression-list = assignment-expression, {',', assignment-expression};

let std-c-parse-generic-selection(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "_Generic") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "_Generic");
      tokens = std-c-take-expect(tokens, "(");
      let ae = std-c-parse-assignment-expression(tokens); tokens = ae.second;
      tokens = std-c-take-expect(tokens, ",");
      let ga = std-c-parse-generic-assoc-list(tokens); tokens = ga.second;
      tokens = std-c-take-expect(tokens, ")");
      if ae.first.is-some && ga.first.is-some
      then Tuple{ Some{CBinaryOp{op, close(ae.first.get-or-panic), close(ga.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens }
   } else Tuple{ no, tokens }
);

let std-c-parse-generic-assoc-list(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   let ga = std-c-parse-generic-association(tokens);
   if ga.first.is-some then {
      tokens = ga.second;
      let gas = [ga.first.get-or-panic];
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         ga = std-c-parse-generic-association(tokens);
         tokens = ga.second;
         if ga.first.is-some then { gas = cons( ga.first.get-or-panic, gas ); };
      };
      Tuple{ Some{CList{close(gas.reverse)}}, tokens }
   } else Tuple{ no, tokens }
);

let std-c-parse-generic-association(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "default") {
      tokens = std-c-take-expect(tokens, "default");
      tokens = std-c-take-expect(tokens, ":");
      let ae = std-c-parse-assignment-expression(tokens);
      if ae.first.is-some
      then Tuple{ Some{CUnaryPrefix{"GenericAssociation", close(ae.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens }
   } else {
      let tn = std-c-parse-type-name(tokens); tokens = tn.second;
      tokens = std-c-take-expect(tokens, ":");
      let ae = std-c-parse-assignment-expression(tokens);
      if tn.first.is-some && ae.first.is-some
      then Tuple{ Some{CBinaryOp{"GenericAssociation", close(tn.first.get-or-panic), close(ae.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens }
   }
);

let std-c-parse-designator(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "[") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, "[");
      let ce = std-c-parse-constant-expression(tokens); tokens = ce.second;
      tokens = std-c-take-expect(tokens, "]");
      if ce.first.is-some
      then Tuple{ Some{CUnaryPrefix{op,close(ce.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens }
   } else if std-c-can-take(tokens,".") {
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, ".");
      let id = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      Tuple{ Some{CUnaryPrefix{op,close(CIdentifier{id})}}, tokens }
   } else Tuple{ no, tokens }
);

let std-c-parse-designator-list(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = None :: Maybe<List<CTerm>>;
   let des = std-c-parse-designator(tokens); tokens = des.second;
   if des.first.is-some {
      let dess = [des.first.get-or-panic];
      while des.first.is-some {
         des = std-c-parse-designator(tokens); tokens = des.second;
         if des.first.is-some { dess = cons(des.first.get-or-panic, dess); };
      };
      Tuple{ Some{dess.reverse}, tokens }
   } else Tuple{ no, tokens };
);

let std-c-parse-designation(tokens: List<Token>): Tuple<Maybe<List<CTerm>>,List<Token>> = (
   let no = None :: Maybe<List<CTerm>>;
   let dl = std-c-parse-designator-list(tokens); tokens = dl.second;
   if dl.first.is-some { tokens = std-c-take-expect(tokens, "="); };
   if dl.first.is-some then Tuple{ Some{dl.first.get-or-panic}, tokens }
   else Tuple{ no, tokens }
);

let std-c-parse-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let e = std-c-parse-jump-statement(tokens);
   if e.first.is-none { e = std-c-parse-compound-statement(tokens); };
   if e.first.is-none { e = std-c-parse-iteration-statement(tokens); };
   if e.first.is-none { e = std-c-parse-selection-statement(tokens); };
   if e.first.is-none { e = std-c-parse-labeled-statement(tokens); };
   if e.first.is-none { e = std-c-parse-expression-statement(tokens); };
   if e.first.is-none && std-c-can-take(tokens,";") {
      tokens = std-c-take-expect(tokens,";");
      e = Tuple{ Some{CZOp{";"}}, tokens };
   };
   e;
);

let std-c-parse-expression-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let e = std-c-parse-expression(tokens);
   if e.first.is-some { e.second = std-c-take-expect(e.second, ";"); };
   e;
);

let std-c-parse-declaration(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   Tuple{ no, tokens }
);

let std-c-parse-labeled-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "identifier") && std-c-can-take(tail(tokens), ":") {
      let lname = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      let op = head(tokens).skey; tokens = std-c-take-expect(tokens, ":");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if stmt.first.is-some
      then Tuple{ Some{CBinaryOp{op,close(CIdentifier{lname}),close(stmt.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else if std-c-can-take(tokens, "case") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let expr = std-c-parse-constant-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ":");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if expr.first.is-some && stmt.first.is-some
      then Tuple{ Some{CBinaryOp{op,close(expr.first.get-or-panic),close(stmt.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else if std-c-can-take(tokens, "default") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, ":");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if stmt.first.is-some
      then Tuple{ Some{CUnaryPrefix{op,close(stmt.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else Tuple{ no, tokens };
);

let std-c-parse-selection-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "if") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt1 = std-c-parse-statement(tokens); tokens = stmt1.second;
      let stmt2 = if std-c-can-take(tokens, "else") {
         tokens = std-c-take-expect(tokens, "else");
         std-c-parse-statement(tokens);
      } else Tuple{ Some{CZOp{";"}}, tokens }; tokens = stmt2.second;
      if expr.first.is-some && stmt1.first.is-some && stmt2.first.is-some
      then Tuple{ Some{CTernaryOp{op,close(expr.first.get-or-panic),close(stmt1.first.get-or-panic),close(stmt2.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else if std-c-can-take(tokens, "switch") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if expr.first.is-some && stmt.first.is-some
      then Tuple{ Some{CBinaryOp{op,close(expr.first.get-or-panic),close(stmt.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else Tuple{ no, tokens };
);

let std-c-parse-iteration-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "while") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if expr.first.is-some && stmt.first.is-some
      then Tuple{ Some{CBinaryOp{op,close(expr.first.get-or-panic),close(stmt.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else if std-c-can-take(tokens, "do") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      tokens = std-c-take-expect(tokens, "while");
      tokens = std-c-take-expect(tokens, "(");
      let expr = std-c-parse-expression(tokens); tokens = expr.second;
      tokens = std-c-take-expect(tokens, ")");
      tokens = std-c-take-expect(tokens, ";");
      if expr.first.is-some && stmt.first.is-some
      then Tuple{ Some{CBinaryOp{op,close(stmt.first.get-or-panic),close(expr.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else if std-c-can-take(tokens, "for") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, "(");
      let decl = std-c-parse-declaration(tokens); tokens = decl.second;
      let expr1 = std-c-parse-expression(tokens); tokens = expr1.second;
      tokens = std-c-take-expect(tokens, ";");
      let expr2 = std-c-parse-expression(tokens); tokens = expr2.second;
      let expr3 = if std-c-can-take(tokens, ";") {
         tokens = std-c-take-expect(tokens, ";");
         std-c-parse-expression(tokens);
      } else Tuple{ no, tokens }; tokens = expr3.second;
      tokens = std-c-take-expect(tokens, ")");
      let stmt = std-c-parse-statement(tokens); tokens = stmt.second;
      if decl.first.is-some && stmt.first.is-some
      then Tuple{ Some{CFor{op,close(decl.first),close(expr1.first),close(expr2.first),close(stmt.first.get-or-panic)}}, tokens }
      else if stmt.first.is-some
      then Tuple{ Some{CFor{op,close(expr1.first),close(expr2.first),close(expr3.first),close(stmt.first.get-or-panic)}}, tokens }
      else Tuple{ no, tokens };
   } else Tuple{ no, tokens };
);

let std-c-parse-jump-statement(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "goto") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let id = head(tokens).skey; tokens = std-c-take-expect(tokens, "identifier");
      tokens = std-c-take-expect(tokens, ";");
      Tuple{ Some{CUnaryPrefix{op,close(CIdentifier{id})}}, tokens }
   } else if std-c-can-take(tokens, "continue") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, ";");
      Tuple{ Some{CZOp{op}}, tokens }
   } else if std-c-can-take(tokens, "break") {
      let op = head(tokens).skey; tokens = tail(tokens);
      tokens = std-c-take-expect(tokens, ";");
      Tuple{ Some{CZOp{op}}, tokens }
   } else if std-c-can-take(tokens, "return") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let e = std-c-parse-expression(tokens); tokens = e.second;
      tokens = std-c-take-expect(tokens, ";");
      if e.first.is-some
      then Tuple{ Some{CUnaryPrefix{op,close(e.first.get-or-panic)}}, tokens }
      else Tuple{ Some{CZOp{op}}, tokens }
   } else Tuple{ no, tokens };
);

