
# Loosely based on this EBNF for ANSI C
# https://gist.github.com/Chubek/52884d1fa766fa16ae8d8f226ba105ad (Katayama Hirofumi MZ. License: MIT)
#
# The naming of production rules try to follow this format.
# However, there are also a large number of compiler-specific extensions that are parsed but mostly ignored
# Example: __extension__ ( f, g )

type CTerm = CInteger{value:String}
           | CCharacter{value:String}
           | CFloating{value:String}
           | CEnumeration{value:String}
           | CString{value:String}
           | CIdentifier{value:String}
           | CUnaryPostfix{op:String, arg:CTerm[]}
           | CUnaryPrefix{op:String, arg:CTerm[]}
           | CAccessor{accessor:String, field:String, arg:CTerm[]};

let cmp(l: CTerm, r: CTerm): Ord = (
   if $".0"(l) != $".0"(r) then cmp($".0"(l), $".0"(r))
   else match Tuple{l, r} {
      Tuple{ first:CInteger{lv=value}, second:CInteger{rv=value} } => cmp(lv, rv);
      Tuple{ first:CCharacter{lv=value}, second:CCharacter{rv=value} } => cmp(lv, rv);
      Tuple{ first:CFloating{lv=value}, second:CFloating{rv=value} } => cmp(lv, rv);
      Tuple{ first:CEnumeration{lv=value}, second:CEnumeration{rv=value} } => cmp(lv, rv);
      Tuple{ first:CString{lv=value}, second:CString{rv=value} } => cmp(lv, rv);
      Tuple{ first:CIdentifier{lv=value}, second:CIdentifier{rv=value} } => cmp(lv, rv);
      Tuple{ first:CUnaryPrefix{lop=op,larg=arg}, second:CUnaryPrefix{rop=op,rarg=arg} } => cmp(lop, rop) && cmp(larg,rarg);
      Tuple{ first:CUnaryPostfix{lop=op,larg=arg}, second:CUnaryPostfix{rop=op,rarg=arg} } => cmp(lop, rop) && cmp(larg,rarg);
      Tuple{ first:CAccessor{lacc=accessor,lf=field,larg=arg}, second:CAccessor{racc=accessor,rf=field,rarg=arg} } => cmp(lacc,racc) && cmp(lf,rf) && cmp(larg,rarg);
   }
);

let to-smart-string(l: CTerm): String = (
   match l {
      CInteger{rv=value} => "{Integer \{rv}}";
      CCharacter{rv=value} => "{Character \{rv}}";
      CFloating{rv=value} => "{Floating \{rv}}";
      CEnumeration{rv=value} => "{Enumeration \{rv}}";
      CString{rv=value} => "{String \{rv}}";
      CIdentifier{rv=value} => "{Identifier \{rv}}";
      CUnaryPrefix{rop=op,rarg=arg} => "{Prefix \{rop} \{rarg}}";
      CUnaryPostfix{rop=op,rarg=arg} => "{Postfix \{rop} \{rarg}}";
      CAccessor{racc=accessor,rf=field,rarg=arg} => "{Accessor \{racc} \{rf} \{rarg}}";
   }
);

let std-c-parse(tokens: List<Token>): Nil = (
#   while non-zero(tokens) { tokens = std-c-parse-external-declaration(tokens); }
);

let std-c-is-reserved-word(tk: String): U64 = (
   let reserved = false;
   if tk == "auto" then (reserved = true);
   if tk == "double" then (reserved = true);
   if tk == "int" then (reserved = true);
   if tk == "struct" then (reserved = true);
   if tk == "break" then (reserved = true);
   if tk == "else" then (reserved = true);
   if tk == "long" then (reserved = true);
   if tk == "switch" then (reserved = true);
   if tk == "case" then (reserved = true);
   if tk == "enum" then (reserved = true);
   if tk == "register" then (reserved = true);
   if tk == "typedef" then (reserved = true);
   if tk == "char" then (reserved = true);
   if tk == "extern" then (reserved = true);
   if tk == "return" then (reserved = true);
   if tk == "union" then (reserved = true);
   if tk == "const" then (reserved = true);
   if tk == "float" then (reserved = true);
   if tk == "short" then (reserved = true);
   if tk == "unsigned" then (reserved = true);
   if tk == "continue" then (reserved = true);
   if tk == "for" then (reserved = true);
   if tk == "signed" then (reserved = true);
   if tk == "void" then (reserved = true);
   if tk == "default" then (reserved = true);
   if tk == "goto" then (reserved = true);
   if tk == "sizeof" then (reserved = true);
   if tk == "volatile" then (reserved = true);
   if tk == "do" then (reserved = true);
   if tk == "if" then (reserved = true);
   if tk == "static" then (reserved = true);
   if tk == "while" then (reserved = true);
   if tk == "_Bool" then (reserved = true);
   if tk == "_Imaginary" then (reserved = true);
   if tk == "restrict" then (reserved = true);
   if tk == "_Complex" then (reserved = true);
   if tk == "inline" then (reserved = true);
   if tk == "_Alignas" then (reserved = true);
   if tk == "_Generic" then (reserved = true);
   if tk == "_Thread_local" then (reserved = true);
   if tk == "_Alignof" then (reserved = true);
   if tk == "_Noreturn" then (reserved = true);
   if tk == "_Atomic" then (reserved = true);
   if tk == "_Static_assert" then (reserved = true);
   reserved
);

let std-c-has-class(tks: String, cls: String): U64 = (
   let tk = untern(tks);
   match cls {
      "identifier" => tk == r/^[a-zA-Z_][a-zA-Z0-9_]*/ && not(std-c-is-reserved-word(tks));
      "integer" => tk == r/^[0-9]+([uU]|[lL]|wb|WB)*/                # decimal constant
                || tk == r/^[0][0-7]+([uU]|[lL]|wb|WB)*/             # octal constant
                || tk == r/^[0][x][0-9a-fA-F]+([uU]|[lL]|wb|WB)*/    # hexadecimal constant
                || tk == r/^[0][bB][01]+([uU]|[lL]|wb|WB)*/;         # binary constant
      "character" => tk == r/^(u8|u|U|L)?[']([^']|([\\][']))+[']/;    # character constant
      "floating" => tk == r/^[0-9]+([.][0-9]+)?([eE][0-9]+)?[fF]?/                                        # decimal constant
                 || tk == r/^[0][x][0-9a-fA-F]+([.][0-9a-fA-F]+)?([eE][0-9a-fA-F]+)?([pP][0-9]+)[fF]?/;   # hexadecimal constant
      "string" => tk == r/^[RLuU8]*["]([^"\\]|([\\].))*["]/;
      "enumeration" => std-c-enumeration-constant-index.has(tks);
      _ => tk == cls;
   }
);

let std-c-can-take(tokens: List<Token>, cls: String): U64 = (
   non-zero(tokens) && std-c-has-class(head(tokens).skey, cls)
);

let std-c-take-expect(tokens: List<Token>, cls: String): List<Token> = (
   if non-zero(tokens) && std-c-has-class(head(tokens).skey, cls) then tail(tokens)
   else (print("Expected token [\{cls}] at \{tokens.formatted-location}\n"); exit(1); tokens);
);

let std-c-take-maybe(tokens: List<Token>, cls: String): List<Token> = (
   if non-zero(tokens) && std-c-has-class(head(tokens).skey, cls) then tail(tokens)
   else tokens;
);

#let std-c-parse-external-declaration(tokens: List<Token>): Nil = (
#   tokens = std-c-parse-function-definition();
#   tokens = std-c-parse-declaration();
#   tokens;
#);

#let std-c-parse-function-definition(tokens: List<Token>): List<Token> = (
#   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
#   if declaration-specifiers.first.is-some {
#      let declarator = std-c-parse-declarator(tokens); tokens = declarator.second;
#      if declarator.first.is-some {
#         let declaration-list = std-c-parse-declaration-list(tokens); tokens = declaration-list.second;
#         let compound-statement = std-c-parse-compound-statement(tokens); tokens = compound-statement.second;
#         if compound-statement.first.is-some {
#            # TODO Add to namespace
#         }
#      }
#   };
#   tokens;
#);

#let std-c-parse-declaration(tokens: List<Token>): List<Token> = (
#   let declaration-specifiers = std-c-parse-declaration-specifiers(tokens); tokens = declaration-specifiers.second;
#   if declaration-specifiers.first.is-some {
#      let init-declarator-list = std-parse-init-declarator-list(tokens); tokens = init-declarator-list.second;
#      tokens = std-c-take-expect(tokens, c";");
#      # TODO Add to namespace
#   };
#   tokens = std-c-parse-static-assert-declaration(tokens);
#   tokens = std-c-take-maybe(tokens, c";");
#   tokens;
#);

#let std-c-parse-declaration-specifiers(tokens: List<Token>): Tuple<Maybe<List<CSpecifier>>,List<Token>> = (
#   let declaration-specifier = std-c-parse-declaration-specifier(tokens); tokens = declaration-specifier.second;
#   if let Some{spec=content} = declaration-specifier.first {
#      let specs = [spec];
#      while declaration-specifier.first.is-some {
#         declaration-specifier = std-c-parse-declaration-specifier(tokens); tokens = declaration-specifier.second;
#         if let Some{next-spec=content} = declaration-specifier.first {
#            specs = cons( next-spec, specs );
#         };
#      };
#      Tuple{ Some{specs}, tokens }
#   } else Tuple{ (None :: Maybe<List<CSpecifier>>), tokens };
#);

#let std-c-parse-declaration-specifier(tokens: List<Token>): Tuple<Maybe<CSpecifier>,List<Token>> = (
#   let storage-class-specifier = std-c-parse-storage-class-specifier(tokens);
#   if storage-class-specifier.first.is-some then storage-class-specifier else {
#      let type-specifier = std-c-parse-type-specifier(tokens);
#      if type-specifier.first.is-some then type-specifier else {
#         let type-qualifier = std-c-parse-type-qualifier(tokens);
#         if type-qualifier.first.is-some then type-qualifier else {
#            let function-specifier = std-c-parse-function-specifier(tokens);
#            if function-specifier.first.is-some then function-specifier
#            else std-c-parse-alignment-specifier(tokens);
#         }
#      }
#   }
#);

#let std-c-parse-declarator(tokens: List<Token>): Tuple<Maybe<CDeclarator>,List<Token>> = (
#   let original-tokens = tokens;
#   let pointer = std-c-parse-pointer(tokens); tokens = pointer.second;
#   let direct-declarator = std-c-direct-declarator(tokens);
#   if let Some{dd=content} = direct-declarator.first {
#      Tuple{ Some{CDeclarator{ pointer.first, dd }}, direct-declarator.second }
#   } else {
#      Tuple{ (None :: Maybe<CDeclarator>), original-tokens }
#   }
#);

#let std-c-declaration-list(tokens: List<Token>): Tuple<Maybe<List<CDeclaration>>,List<Token>> = (
#   let declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
#   if let Some{decl=content} = declaration.first {
#      let decls = [decl];
#      declaration = std-c-parse-declaration(tokens); tokens = declaration.second;
#      while declaration.first.is-some {
#         if let Some{decl-next=content} = declaration.first {
#            decls = cons(decl-next, decls);
#         }
#      };
#      Tuple{ Some{decls}, tokens }
#   } else (Tuple{ (None :: Maybe<List<CDeclaration>>), tokens })
#);

#let std-c-parse-compound-statement(tokens: List<Token>): Tuple<Maybe<CDeclarationOrStatement>,List<Token>> = (
#   if std-c-can-take(c"{") {
#      tokens = std-c-take-maybe(tokens, c"{");
#      let declaration-or-statement = std-c-parse-declaration-or-statement(tokens); tokens = declaration-or-statement.second;
#      tokens = std-c-take-maybe(tokens, c"}");
#      Tuple{ declaration-or-statement.first, tokens };
#   } else Tuple{(None :: Maybe<CDeclarationOrStatement>), tokens}
#);

#let std-c-parse-declaration-or-statement(tokens: List<Token>): Tuple<Maybe<CDeclarationOrStatement>,List<Token>> = (
#   let declaration = std-c-parse-declaration(tokens);
#   if declaration.first.is-some then declaration else std-c-parse-statement(tokens);
#);

#let std-c-parse-init-declarator-list(tokens: List<Token>): Tuple<Maybe<List<CInitDeclarator>>,List<Token>> = (
#   let init-declarator = std-c-parse-init-declarator(tokens);
#   if let Some{dc=content} = init-declarator {
#      let dcs = [dc];
#      while init-declarator.first.is-some {
#         init-declarator = std-c-parse-init-declarator(tokens);
#         if let Some{dc2=content} = init-declarator {
#            dcs = cons(dc, dcs);
#         }
#      };
#      Tuple{ Some{dcs}, tokens }
#   } else init-declarator;
#);

#let std-c-parse-init-declarator(tokens: List<Token>): Tuple<Maybe<CInitDeclarator>,List<Token>> = (
#   let declarator = c-parse-declarator(tokens); tokens = declarator.second;
#   if declarator.first.is-some {
#      tokens = std-c-take-expect(tokens, c"=");
#      let initializer = std-c-parse-initializer(tokens); tokens = declarator.second;
#      Tuple{ CInitDeclarator{ declarator.first, initializer.first }, tokens }
#   } else declarator
#);

#let std-c-parse-static-assert-declaration(tokens: List<Token>): Tuple<Maybe<CStaticAssertDeclaration>,List<Token>> = (
#   if std-c-can-take(tokens, c"_Static_assert") {
#      tokens = std-c-take-expect(tokens, c"_Static_assert");
#      tokens = std-c-take-expect(tokens, c"(");
#      let constant-expression = std-c-parse-constant-expression(tokens);
#      if constant-expression.first.is-none { std-c-take-expect(tokens, c"[Constant Expression]"); };
#      tokens = std-c-take-expect(tokens, c",");
#      tokens = std-c-take-expect(tokens, c")");
#      tokens = std-c-take-expect(tokens, c";");
#      let string-literal = std-c-parse-string-literal(tokens);
#      if let Some{ce=content} = constant-expression {
#         if let Some{sl=content} = string-literal {
#            Tuple{ Some{CStaticAssertDeclaration{ ce, sl }}, tokens }
#         } else Tuple{ (None :: Maybe<CStaticAssertDeclaration>), tokens };
#      } else Tuple{ (None :: Maybe<CStaticAssertDeclaration>), tokens };
#      Tuple{ Some{CStaticAssertDeclaration{ constant-expression. }} }
#   } else Tuple{ (None :: Maybe<CStaticAssertDeclaration>), tokens }
#);

#let std-c-parse-storage-class-specifier(tokens: List<Token): Tuple<Maybe<CStorageClassSpecifier>,List<Token>> = (
#   if std-c-can-take("typedef", tokens) then (tokens = std-c-take-expect("typedef", tokens); Tuple{Some{CStorageClassTypedef}, tokens} )
#   else if std-c-can-take("extern", tokens) then (tokens = std-c-take-expect("extern", tokens); Tuple{Some{CStorageClassExtern}, tokens} )
#   else if std-c-can-take("static", tokens) then (tokens = std-c-take-expect("static", tokens); Tuple{Some{CStorageClassStatic}, tokens} )
#   else if std-c-can-take("_Thread_local", tokens) then (tokens = std-c-take-expect("_Thread_local", tokens); Tuple{Some{CStorageClassThreadLocal}, tokens} )
#   else if std-c-can-take("auto", tokens) then (tokens = std-c-take-expect("auto", tokens); Tuple{Some{CStorageClassAuto}, tokens} )
#   else if std-c-can-take("register", tokens) then (tokens = std-c-take-expect("register", tokens); Tuple{Some{CStorageClassRegister}, tokens} )
#   else Tuple{None :: Maybe<CStorageClassSpecifier>, tokens}
#);

#let std-c-parse-type-specifier(tokens: List<Token>): Tuple<Maybe<CTypeSpecifier>,List<Token>> = (
#   if std-c-can-take("void", tokens) then (tokens = std-c-take-expect("void", tokens); Tuple{Some{CType{c"void"}}, tokens} )
#   else if std-c-can-take("char", tokens) then (tokens = std-c-take-expect("char", tokens); Tuple{Some{CType{c"char"}}, tokens} )
#   else if std-c-can-take("short", tokens) then (tokens = std-c-take-expect("short", tokens); Tuple{Some{CType{c"short"}}, tokens} )
#   else if std-c-can-take("int", tokens) then (tokens = std-c-take-expect("int", tokens); Tuple{Some{CType{c"int"}}, tokens} )
#   else if std-c-can-take("long", tokens) then (tokens = std-c-take-expect("long", tokens); Tuple{Some{CType{c"long"}}, tokens} )
#   else if std-c-can-take("float", tokens) then (tokens = std-c-take-expect("float", tokens); Tuple{Some{CType{c"float"}}, tokens} )
#   else if std-c-can-take("double", tokens) then (tokens = std-c-take-expect("double", tokens); Tuple{Some{CType{c"double"}}, tokens} )
#   else if std-c-can-take("signed", tokens) then (tokens = std-c-take-expect("signed", tokens); Tuple{Some{CType{c"signed"}}, tokens} )
#   else if std-c-can-take("unsigned", tokens) then (tokens = std-c-take-expect("unsigned", tokens); Tuple{Some{CType{c"unsigned"}}, tokens} )
#   else if std-c-can-take("_Bool", tokens) then (tokens = std-c-take-expect("_Bool", tokens); Tuple{Some{CType{c"_Bool"}}, tokens} )
#   else if std-c-can-take("_Complex", tokens) then (tokens = std-c-take-expect("_Complex", tokens); Tuple{Some{CType{c"_Complex"}}, tokens} )
#   else if std-c-can-take("_Imaginary", tokens) then (tokens = std-c-take-expect("_Imaginary", tokens); Tuple{Some{CType{c"_Imaginary"}}, tokens} )
#   else if let Tuple{Some{ats=contents}=first,tokens2=second} = std-c-atomic-type-specifier(tokens) then Tuple{Some{ats}, tokens2}
#   else if let Tuple{Some{sou=contents}=first,tokens3=second} = std-c-struct-or-union-specifier(tokens) then Tuple{Some{sou}, tokens3}
#   else if let Tuple{Some{enm=contents}=first,tokens4=second} = std-c-enum-specifier(tokens) then Tuple{Some{enm}, tokens4}
#   else std-c-typedef-name(tokens)
#);

#let std-c-typedef-name-index = {} :: HashtableEq<CString,U64>;
#let std-c-parse-typedef-name(tokens: List<Token>): Tuple<Maybe<CType>,List<Token>> = (
#   if non-zero(tokens) && std-c-typedef-name.has(head(tokens).key) {
#      Tuple{ Some{CType{head(tokens).key}}, tokens }
#   } else Tuple{ None :: Maybe<CType>, tokens }
#);

#let std-c-parse-type-qualifier(tokens: List<Token>): Tuple<Maybe<CTypeQualifier>,List<Token>> = (
#   if std-c-can-take("const", tokens) then (tokens = std-c-take-expect("const", tokens); Tuple{Some{CType{c"const"}}, tokens} )
#   else if std-c-can-take("restrict", tokens) then (tokens = std-c-take-expect("restrict", tokens); Tuple{Some{CType{c"restrict"}}, tokens} )
#   else if std-c-can-take("volatile", tokens) then (tokens = std-c-take-expect("volatile", tokens); Tuple{Some{CType{c"volatile"}}, tokens} )
#   else if std-c-can-take("_Atomic", tokens) then (tokens = std-c-take-expect("_Atomic", tokens); Tuple{Some{CType{c"Atomic"}}, tokens} )
#   else Tuple{None :: Maybe<CTypeQualifier>, tokens}
#);

#let std-c-parse-function-specifier(tokens: List<Token>): Tuple<Maybe<CFunctionSpecifier>,List<Token>> = (
#   if std-c-can-take("inline", tokens) then (tokens = std-c-take-expect("inline", tokens); Tuple{Some{CType{c"inline"}}, tokens} )
#   else if std-c-can-take("_Noreturn", tokens) then (tokens = std-c-take-expect("_Noreturn", tokens); Tuple{Some{CType{c"_Noreturn"}}, tokens} )
#   else Tuple{None :: Maybe<CTypeQualifier>, tokens}
#);

#let std-c-parse-alignment-specifier(tokens: List<Token>): Tuple<Maybe<CAlignmentSpecifier>,List<Token>> = (
#   if std-c-can-take("_Alignas", tokens) then {
#      tokens = std-c-take-expect("_Alignas", tokens);
#      tokens = std-c-take-expect("(", tokens);
#      if let Tuple{first:Some{tn=content},tokens2=second} = std-c-parse-type-name(tokens) {
#         tokens = std-c-take-expect(")", tokens);
#         Tuple{ Some{ tn }, tokens }
#      } else if let Tuple{first:Some{ce=content},tokens2=second} = std-c-parse-constant-expression(tokens) {
#         Tuple{ Some{ ce }, tokens }
#      } else std-c-take-expect(c"[Alignment Specifier]");
#   } else Tuple{None :: Maybe<CFunctionSpecifier>, tokens}
#);

#let std-c-parse-pointer(tokens: List<Token>): Tuple<Maybe<CPointer>,List<Token>> = (
#   if std-c-can-take(c"*") then }
#      tokens = std-c-take-expect("*", tokens);
#      let type-qualifier-list = std-c-parse-type-qualifier-list(tokens); tokens = type-qualifier-list.second;
#      let next-pointer = std-c-parse-pointer(tokens); tokens = next-pointer.second;
#      Some{ CPointer{ type-qualifier-list.first, next-pointer.first }, tokens }
#   } else Tuple{None :: Maybe<CPointer>, tokens}   
#);

#let std-c-parse-direct-declarator(tokens: List<Token>): Tuple<Maybe<CDeclarator>,List<Token>> = (
#   let base-declarator = if let Tuple{Some{ident=contents}=first,tokens2=second} = std-c-parse-identifier(tokens) then {
#      tokens = tokens2;
#      CDeclaratorIdentifier{ ident }
#   } else if std-c-can-take(c"(") then {
#      tokens = std-c-take-expect(c"(");
#      let declarator = std-c-parse-declarator(tokens); tokens = declarator.second;
#      if declarator.is-none { tokens = std-c-take-expect("[Declarator]", tokens); };
#      tokens = std-c-take-expect(c")");
#      declarator;
#   } else std-c-take-expect("[Direct Declarator]", tokens);
#   while std-c-can-take("(") || std-c-can-take("[") {
#      if std-c-can-take("(") {
#         tokens = std-c-take-expect("(");
#         if let Tuple{first:Some{tl=content},tokens3=second} = std-c-parse-type-list(tokens) {
#            tokens = std-c-take-expect(")");
#            tokens = tokens3;
#            base-declarator = CDeclaratorParamList{ base-declarator, tl };
#         } else if let Tuple{first:Some{tl=content},tokens4=second} = std-c-parse-identifier-list(tokens) {
#            tokens = std-c-take-expect(")");
#            tokens = tokens4;
#            base-declarator = CDeclaratorParamList{ base-declarator, tl };
#         } else {
#            tokens = std-c-take-expect(")");
#            base-declarator = CDeclaratorParamList{ base-declarator, [] :: List<Tuple<CString,CType>> };
#         };
#      } else {
#         tokens = std-c-take-expect("[");
#         let type-qualifiers = [] :: List<CType>;
#         if std-c-can-take(c"static", tokens) then {
#            tokens = std-c-take-expect("static");
#            type-qualifiers = cons( CType{c"static"}, type-qualifiers );
#         };
#         if let Tuple{first:Some{tq=content},tokens5=second} = std-c-parse-type-qualifier-list(tokens) {
#            type-qualifiers = type-qualifiers + tq;
#         };
#         if std-c-can-take(c"static", tokens) then {
#            tokens = std-c-take-expect("static");
#            type-qualifiers = cons( CType{c"static"}, type-qualifiers );
#         };
#         let indirect = if std-c-can-take(c"*", tokens) then {
#            tokens = std-c-take-expect("*");
#            true;
#         } else false;
#         let assignment-expression = None :: Maybe<CAssignmentExpression>;
#         if let Tuple{first:Some{ae=content},tokens6=second} = std-c-parse-assignment-expression(tokens) {
#            tokens = tokens6;
#            assignment-expression = ae;
#         };
#         tokens = std-c-take-expect("]");
#         base-declarator = CDeclaratorBracket{ base-declarator, type-qualifiers, indirect, assignment-expression };
#      };
#   };
#   Tuple{ Some{base-declarator}, tokens };
#);

let std-c-parse-identifier-list(tokens: List<Token>): Tuple<Maybe<List<String>>,List<Token>> = (
   let no = None :: Maybe<List<String>>;
   if std-c-can-take(tokens, "identifier") then {
      let ids = [head(tokens).skey];
      tokens = std-c-take-expect(tokens, "identifier");
      while std-c-can-take(tokens, ",") {
         tokens = std-c-take-expect(tokens, ",");
         if non-zero(tokens) {
            ids = cons( head(tokens).skey, ids );
         };
         tokens = std-c-take-expect(tokens, "identifier");
      };
      Tuple{ Some{ids.reverse}, tokens }
   } else Tuple{no, tokens};
);

#initializer-list = designative-initializer, {',', designative-initializer};

#designative-initializer = [designation], initializer;

#initializer = '{', initializer-list, [','], '}'
#            | assignment-expression;

#constant-expression = conditional-expression;  (* with constraints *)

#atomic-type-specifier = '_Atomic', '(', type-name, ')';

#struct-or-union-specifier = struct-or-union, '{', struct-declaration-list, '}'
#                          | struct-or-union, identifier, ['{', struct-declaration-list, '}'];

#struct-declaration-list = struct-declaration, {struct-declaration};

#struct-declaration = specifier-qualifier-list, ';'     (* for anonymous struct/union *)
#                   | specifier-qualifier-list, struct-declarator-list, ';'
#                   | static-assert-declaration;

#enum-specifier = 'enum', '{', enumerator-list, [','], '}'
#               | 'enum', identifier, ['{', enumerator-list, [','], '}'];

#enumerator-list = enumerator, {',', enumerator};

#(* NOTE: Please define enumeration-constant for identifier inside enum { ... }. *)
#enumerator = enumeration-constant, ['=', constant-expression];

#type-name = specifier-qualifier-list, [abstract-declarator];

#specifier-qualifier-list = specifier-qualifier, {specifier-qualifier};

#specifier-qualifier = type-specifier | type-qualifier;

#abstract-declarator = pointer, [direct-abstract-declarator]
#                    | direct-abstract-declarator;

#direct-abstract-declarator = '(', abstract-declarator, ')'
#                           | '(', parameter-type-list, ')'
#                           | '(', ')'
#                           | '[', ['*'], ']'
#                           | '[', 'static', [type-qualifier-list], assignment-expression, ']'
#                           | '[', type-qualifier-list, [['static'], assignment-expression], ']'
#                           | '[', assignment-expression, ']'
#                           | direct-abstract-declarator, '[', ['*'], ']'
#                           | direct-abstract-declarator, '[', 'static', [type-qualifier-list], assignment-expression, ']'
#                           | direct-abstract-declarator, '[', type-qualifier-list, [['static'], assignment-expression], ']'
#                           | direct-abstract-declarator, '[', assignment-expression, ']'
#                           | direct-abstract-declarator, '(', parameter-type-list, ')'
#                           | direct-abstract-declarator, '(', ')';

#struct-declarator-list = struct-declarator, {',', struct-declarator};

#type-qualifier-list = type-qualifier, {type-qualifier};

#parameter-type-list = parameter-list, [',', '...'];

#struct-declarator = ':', constant-expression
#                  | declarator, [':', constant-expression];

let std-c-parse-assignment-operator(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = None :: Maybe<String>;
   if not(non-zero(tokens)) then Tuple{ no, tokens }
   else if head(tokens).skey == "=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "*=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "/=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "%=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "+=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "-=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "<<=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == ">>=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "&=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "^=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "|=" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-unary-operator(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = None :: Maybe<String>;
   if not(non-zero(tokens)) then Tuple{ no, tokens }
   else if head(tokens).skey == "&" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "*" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "+" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "-" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "~" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "!" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-struct-or-union(tokens: List<Token>): Tuple<Maybe<String>,List<Token>> = (
   let no = None :: Maybe<String>;
   if not(non-zero(tokens)) then Tuple{ no, tokens }
   else if head(tokens).skey == "struct" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else if head(tokens).skey == "union" then Tuple{ Some{head(tokens).skey}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-identifier(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "identifier") then Tuple{ Some{CIdentifier{head(tokens).skey}}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-enumeration-constant-index = {} :: HashtableEq<String,Bool>;

let std-c-parse-constant(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "integer") then Tuple{ Some{CInteger{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "character") then Tuple{ Some{CCharacter{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "floating") then Tuple{ Some{CFloating{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "enumeration") then Tuple{ Some{CEnumeration{head(tokens).skey}}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-string(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let no = None :: Maybe<CTerm>;
   if std-c-can-take(tokens, "string") then Tuple{ Some{CString{head(tokens).skey}}, tail(tokens) }
   else if std-c-can-take(tokens, "__func__") then Tuple{ Some{CString{head(tokens).skey}}, tail(tokens) }
   else Tuple{ no, tokens }
);

let std-c-parse-primary-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let ts = std-c-parse-constant(tokens);
   if ts.first.is-none then (ts = std-c-parse-identifier(tokens));
   if ts.first.is-none then (ts = std-c-parse-string(tokens));
   # TODO '(', expression, ')'
   # TODO generic-selection
   ts
);

#parameter-list = parameter-declaration, {',', parameter-declaration};

#parameter-declaration = declaration-specifiers, [declarator | abstract-declarator];

#expression = assignment-expression, {',', assignment-expression};

#assignment-expression = conditional-expression
#                      | unary-expression, assignment-operator, assignment-expression;

#conditional-expression = logical-or-expression, ['?', expression, ':', conditional-expression];

#logical-or-expression = logical-and-expression, {'||', logical-and-expression};

#logical-and-expression = inclusive-or-expression, {'&&', inclusive-or-expression};

#inclusive-or-expression = exclusive-or-expression, {'|', exclusive-or-expression};

#exclusive-or-expression = and-expression, {'^', and-expression};

#and-expression = equality-expression, {'&', equality-expression};

#equality-expression = relational-expression, {('==' | '!='), relational-expression};

#relational-expression = shift-expression, {('<' | '>' | '<=' | '>='), shift-expression};

#shift-expression = additive-expression, {('<<' | '>>'), additive-expression};

#additive-expression = multiplicative-expression, {('+' | '-'), multiplicative-expression};

#multiplicative-expression = cast-expression, {('*' | '/' | '%'), cast-expression};

#cast-expression = unary-expression
#                | '(', type-name, ')', cast-expression;


let std-c-parse-unary-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
#unary-expression = postfix-expression
#                 | unary-operator, cast-expression
#                 | 'sizeof', '(', type-name, ')'
#                 | '_Alignof', '(', type-name, ')';
   if std-c-can-take(tokens, "++") || std-c-can-take(tokens, "--") {
      let op = head(tokens).skey; tokens = tail(tokens);
      let inner = std-c-parse-unary-expression(tokens);
      if inner.first.is-some then Tuple{ Some{CUnaryPrefix{op, close(inner.first.get-or-panic)}}, inner.second }
      else inner;
   } else if std-c-can-take(tokens, "sizeof") {
      let op = head(tokens).skey; tokens = tail(tokens);
      if std-c-can-take(tokens, "(") {
         print("TODO: C parse unary expression sizeof(type)"); exit(1); std-c-parse-postfix-expression(tokens);
      } else {
         let inner = std-c-parse-unary-expression(tokens);
         if inner.first.is-some then Tuple{ Some{CUnaryPrefix{op, close(inner.first.get-or-panic)}}, inner.second }
         else inner;
      };
   } else std-c-parse-postfix-expression(tokens)
);


let std-c-parse-postfix-expression(tokens: List<Token>): Tuple<Maybe<CTerm>,List<Token>> = (
   let expression = std-c-parse-primary-expression(tokens); tokens = expression.second;
   while expression.first.is-some && (
      std-c-can-take(tokens, "[") || std-c-can-take(tokens, "(") ||
      std-c-can-take(tokens, ".") || std-c-can-take(tokens, "->") ||
      std-c-can-take(tokens, "++") || std-c-can-take(tokens, "--")
   ) {
      if std-c-can-take(tokens, "++") || std-c-can-take(tokens, "--") {
         let e = CUnaryPostfix{ head(tokens).skey, close(expression.first.get-or-panic) };
         tokens = tail(tokens);
         expression = Tuple{ Some{e}, tokens };
      } else if std-c-can-take(tokens, ".") || std-c-can-take(tokens, "->") {
         let accessor = head(tokens).skey; tokens = tail(tokens);
         if non-zero(tokens) {
            let e = CAccessor{ accessor, head(tokens).skey, close(expression.first.get-or-panic) };
            tokens = std-c-take-expect(tokens, "identifier");
            expression = Tuple{ Some{e}, tokens };
         } else std-c-take-expect(tokens, "identifier");
      } else {
         print("TODO: parse-postfix \{head(tokens).skey}"); exit(1);
#                   | postfix-expression, '[', expression, ']'
#                   | postfix-expression, '(', [argument-expression-list], ')'         
      };
   };
#postfix-expression = primary-expression
#                   | '(', type-name, ')', '{', initializer-list, [','], '}';
   expression
);


#argument-expression-list = assignment-expression, {',', assignment-expression};



#generic-selection = '_Generic', '(', assignment-expression, ',', generic-assoc-list, ')';

#generic-assoc-list = generic-association, {',', generic-association};

#generic-association = type-name, ':', assignment-expression
#                    | 'default', ':', assignment-expression;

#designation = designator-list, '=';

#designator-list = designator, {designator};

#designator = '[', constant-expression, ']'
#           | '.', identifier;

#statement = labeled-statement
#          | compound-statement
#          | expression-statement
#          | selection-statement
#          | iteration-statement
#          | jump-statement;

#labeled-statement = identifier, ':', statement
#                  | 'case', constant-expression, ':', statement
#                  | 'default', ':', statement;

#expression-statement = [expression], ';';

#selection-statement = 'if', '(', expression, ')', statement, 'else', statement
#                    | 'if', '(', expression, ')', statement
#                    | 'switch', '(', expression, ')', statement;

# iteration-statement = 'while', '(', expression, ')', statement
#                     | 'do', statement, 'while', '(', expression, ')', ';'
#                     | 'for', '(', [expression], ';', [expression], ';', [expression], ')', statement
#                     | 'for', '(', declaration, [expression], ';', [expression], ')', statement;

#jump-statement = 'goto', identifier, ';'
#               | 'continue', ';'
#               | 'break', ';'
#               | 'return', [expression], ';';
