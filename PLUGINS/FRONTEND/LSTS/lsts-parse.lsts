
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").remove-suffix(c"\"")
   } else ident
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }
);

let lsts-parse-expect(expect: CString, b: U64, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }
);

let lsts-has-assign(tokens: List<Token>): U64 = (
   let depth = 0_i64;
   let has-assign = 0;
   while non-zero(tokens) { match tokens {
      [Token{key:c"["} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"{"} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"("} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"]"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c"}"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c")"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c";"} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c","} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c"="} .. rest] => (if depth == 0_i64 {has-assign = 1; tokens = [] :: List<Token>;} else {tokens = rest;});
      [_ .. rest] => tokens = rest;
   }; if depth < 0_i64 { tokens = [] :: List<Token>; }; };
   has-assign
);

let lsts-substitute-type-aliases(s: CString): CString = (
   if s == c"String" then c"SmartString" else
   if s == c"CString" then c"String" else
   s
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => tokens = lsts-parse-let(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil {};
            while non-zero(tokens) && lsts-parse-head(tokens) != c";" {
               path = path + SAtom { lsts-unwrap-identifier(lsts-parse-head(tokens)) };
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = Seq { close(ast-parsed-program), close(term) };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
   }
);

let lsts-parse-type(tokens: List<Token>): Tuple<Type,List<Token>> = (
   let tt = if lsts-parse-head(tokens) == c"(" {
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let args-rest = lsts-parse-type(tokens);
      let args = [ args-rest.first ];
      tokens = args-rest.second;
      while lsts-parse-head(tokens) == "," {
         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         let tnext-rest = lsts-parse-type(tokens);
         args = cons( tnext-rest.first, args );
         tokens = tnext-rest.second;
      };
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      TGround { c"Tuple", close(args) };
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let varname = lsts-parse-head(tokens); tokens = tail(tokens);
      TVar { varname }
   } else {
      let base = lsts-substitute-type-aliases(lsts-parse-head(tokens));
      lsts-parse-expect(c"Type", lsts-is-lit-head(lsts-parse-head(tokens)), tokens); tokens = tail(tokens);
      let args = [] :: List<Type>;
      if lsts-parse-head(tokens) == c"<" {
         lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
         let targs-rest = lsts-parse-type(tokens);
         args = cons( targs-rest.first, args );
         tokens = targs-rest.second;
         while lsts-parse-head(tokens) == "," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            let tnext-rest = lsts-parse-type(tokens);
            args = cons( tnext-rest.first, args );
            tokens = tnext-rest.second;
         };
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      };
      TGround { base, close(args) };
   };
   while lsts-parse-head(tokens) == c"[" {
      lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
      let index = if lsts-parse-head(tokens) == c"]" {
         let tindex-rest = lsts-parse-type(tokens);
         tokens = tindex-rest.second;
         tindex-rest.first;
      } else { TAny {} };
      lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
      tt = TGround { c"Array", close([ index, tt ]) };
   };
   Tuple { tt, tokens };
);

let lsts-parse-expression-possibly-tuple(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if not(non-zero(tokens)) { lsts-parse-expect(c"ExpressionPossiblyTuple", tokens); };
   let loc = head(tokens).location;
   let base-rest = lsts-parse-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   let is-tuple = 0;
   while lsts-parse-head(tokens) == c"," {
      is-tuple = 1;
      tokens = tail(tokens);
      base-rest = lsts-parse-expression(tokens);
      base = App { close(base), close(base-rest.first) };
      tokens = base-rest.second;
   };
   if is-tuple {
      base = App {
         close(Lit{ c"Tuple", with-location(mk-token("Tuple"),loc) }),
         close(base)
      };
   };
   Tuple { base, tokens }
);

let lsts-parse-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-small-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   while lsts-parse-head(tokens) == c";" {
      tokens = tail(tokens);
      if lsts-parse-head(tokens)!=c")" && lsts-parse-head(tokens)!=c"}" {
         base-rest = lsts-parse-small-expression(tokens);
         base = App { close(base), close(base-rest.first) };
         tokens = base-rest.second;
      }
   };
   Tuple { base, tokens }
);
