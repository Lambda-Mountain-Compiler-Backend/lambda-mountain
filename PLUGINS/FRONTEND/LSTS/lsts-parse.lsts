
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").remove-suffix(c"\"")
   } else ident
);

let lsts-unwrap-identifier(ident: Token): Token = (
   match ident {
      Token { skey=skey, key=key, nonce=nonce, location=location } => Token { skey, lsts-unwrap-identifier(key), iuid(), location };
   };
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }; ();
);

let lsts-parse-expect(expect: CString, b: U64, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }; ();
);

let lsts-has-assign(tokens: List<Token>): U64 = (
   let depth = 0_i64;
   let has-assign = 0;
   while non-zero(tokens) { match tokens {
      [Token{key:c"["} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"{"} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"("} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"]"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c"}"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c")"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c";"} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c","} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c"="} .. rest] => (if depth == 0_i64 {has-assign = 1; tokens = [] :: List<Token>;} else {tokens = rest;});
      [Token{key:c"if"} .. rest] => (if depth == 0_i64 {tokens = [] :: List<Token>;} else {tokens = rest;});
      [_ .. rest] => tokens = rest;
   }; if depth < 0_i64 { tokens = [] :: List<Token>; }; };
   has-assign
);

let lsts-substitute-type-aliases(s: CString): CString = (
   if s.has-prefix(c"$") then untern(intern(s)[2_i64:-1_i64]) else
   if s == c"String" then c"SmartString" else
   if s == c"CString" then c"String" else
   s.remove-suffix(c"_u64")
    .remove-suffix(c"_u32")
    .remove-suffix(c"_u16")
    .remove-suffix(c"_u8")
    .remove-suffix(c"_i64")
    .remove-suffix(c"_i32")
    .remove-suffix(c"_i16")
    .remove-suffix(c"_i8")
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => tokens = lsts-parse-let(tokens);
         [ Token{key:c"type"}.. _] => tokens = lsts-parse-typedef(tokens);
         [ Token{key:c"interface"}.. _] => tokens = lsts-parse-interface(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil {};
            while non-zero(tokens) && lsts-parse-head(tokens) != c";" {
               path = path + SAtom { lsts-unwrap-identifier(lsts-parse-head(tokens)) };
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         [ Token{key:c"zero"}.. rest] => (
            let loc = head(tokens).location;
            tokens = rest;
            let base-type-rest = lsts-parse-type(tokens); tokens = base-type-rest.second;
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            if not(non-zero(tokens)) || not(lsts-is-lit-head(lsts-parse-head(tokens))) { 
               lsts-parse-expect(c"[Type Constructor]", tokens);
            };
            let constructor = head(tokens); tokens = tail(tokens);
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            ast-parsed-program = Seq { close(ast-parsed-program), close(App{
               close(Var{ c"macro::define-zero", with-key(constructor, c"macro::define-zero") }),
               close(App{
                  close(AType{ base-type-rest.first }),
                  close(Lit{ constructor.key, constructor })
               })
            }) };
         );
         [ Token{key:c"atom"}.. Token{key:c"suffix"}.. rest] => (
            tokens = rest;
            let base-rest = lsts-parse-type(tokens); tokens = base-rest.second;
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            if not(non-zero(tokens)) || not(lsts-is-ident-head(lsts-parse-head(tokens))) { 
               lsts-parse-expect(c"[Suffix]", tokens);
            };
            let suffix = head(tokens).key; tokens = tail(tokens);
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            parse-suffixes = cons(
               Tuple{ suffix, base-rest.first && t1(c"Constant") && t1(c"Literal") },
               parse-suffixes
            );
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = Seq { close(ast-parsed-program), close(term) };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
   }
);

let lsts-parse-type(tokens: List<Token>): Tuple<Type,List<Token>> = (
   let tt = if lsts-parse-head(tokens) == c"(" {
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let args-rest = lsts-parse-type(tokens);
      let args = [ args-rest.first ];
      tokens = args-rest.second;
      while lsts-parse-head(tokens) == c"," {
         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         let tnext-rest = lsts-parse-type(tokens);
         args = cons( tnext-rest.first, args );
         tokens = tnext-rest.second;
      };
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      TGround { c"Tuple", close(args) };
   } else if lsts-parse-head(tokens)==c"?" {
      tokens = tail(tokens);
      TAny {}
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) && not(lsts-parse-head(tokens).has-suffix(c"_u64"))
          && not(lsts-parse-head(tokens).has-prefix(c"$")) {
      let varname = lsts-parse-head(tokens); tokens = tail(tokens);
      TVar { varname }
   } else {
      let base = lsts-substitute-type-aliases(lsts-parse-head(tokens));
      tokens = tail(tokens);
      while non-zero(tokens) && lsts-parse-head(tokens)==c":" {
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         lsts-parse-expect(c"Type", non-zero(tokens), tokens);
         base = base + c"::" + lsts-substitute-type-aliases(lsts-parse-head(tokens));
         tokens = tail(tokens);
      };
      let args = [] :: List<Type>;
      if lsts-parse-head(tokens) == c"<" {
         lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
         let targs-rest = lsts-parse-type(tokens);
         args = cons( targs-rest.first, args );
         tokens = targs-rest.second;
         while lsts-parse-head(tokens) == c"," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            let tnext-rest = lsts-parse-type(tokens);
            args = cons( tnext-rest.first, args );
            tokens = tnext-rest.second;
         };
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      };
      TGround { base, close(args) };
   };
   while lsts-parse-head(tokens) == c"[" {
      lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
      let index = if lsts-parse-head(tokens) != c"]" {
         let tindex-rest = lsts-parse-type(tokens);
         tokens = tindex-rest.second;
         tindex-rest.first;
      } else { TAny {} };
      lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
      tt = TGround { c"Array", close([ index, tt ]) };
   };
   if lsts-parse-head(tokens)==c"+" {
      tokens = tail(tokens);
      let ntt-rest = lsts-parse-type(tokens);
      tt = TAnd{ close(ntt-rest.first), close(tt) };
      tokens = ntt-rest.second;
   };
   Tuple { tt, tokens };
);

let lsts-parse-expression-possibly-tuple(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if not(non-zero(tokens)) { lsts-parse-expect(c"ExpressionPossiblyTuple", tokens); };
   let loc = head(tokens).location;
   let base-rest = lsts-parse-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   let is-tuple = 0;
   while lsts-parse-head(tokens) == c"," {
      is-tuple = 1;
      tokens = tail(tokens);
      base-rest = lsts-parse-expression(tokens);
      base = App { close(base), close(base-rest.first) };
      tokens = base-rest.second;
   };
   if is-tuple {
      base = App {
         close(Lit{ c"Tuple", with-location(mk-token("Tuple"),loc) }),
         close(base)
      };
   };
   Tuple { base, tokens }
);

let lsts-parse-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-small-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   while lsts-parse-head(tokens) == c";" {
      tokens = tail(tokens);
      if lsts-parse-head(tokens)!=c")" && lsts-parse-head(tokens)!=c"}" {
         base-rest = lsts-parse-small-expression(tokens);
         base = App { true, close(base), close(base-rest.first) };
         tokens = base-rest.second;
      }
   };
   Tuple { base, tokens }
);

let lsts-parse-lhs-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF {};
   lsts-parse-expect(c"[", tokens);
   let loc = head(tokens).location;
   tokens = tail(tokens);
   if lsts-parse-head(tokens) == c"]" {
      base = Lit { c"LEOF", with-location(mk-token("LEOF"),loc) };
   } else {
      let base-rest = lsts-parse-lhs-one(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
      let bases = [base];
      while non-zero(tokens) && lsts-parse-head(tokens)==c"." {
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c"]" {
            bases = cons( Lit{ c"LEOF", with-location(mk-token("LEOF"),loc) }, bases );
         } else {
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            bases = cons( next, bases );
         }
      };
      base = head(bases); bases = tail(bases);
      for b in bases {
         base = App {
            close(Var{ c"macro::lhs-head", with-location(mk-token("macro::lhs-head"),loc) }),
            close(App{ close(b), close(base) })
         };
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple { base, tokens }
);

let lsts-parse-lhs(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = match tokens {
      [ Token{key:c"["}.. _ ] => (
         let base-rest = lsts-parse-lhs-list(tokens);
         tokens = base-rest.second;
         base-rest.first;
      );
      [ Token{key:c"("}.. _] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         let base-rest = lsts-parse-lhs-big(tokens);
         tokens = base-rest.second;
         lsts-parse-expect(c")", tokens); tokens = tail(tokens);
         base-rest.first;
      );
      _ => (
         let base-rest = lsts-parse-lhs-one(tokens);
         tokens = base-rest.second;
         base-rest.first;         
      );
   };
   while non-zero(tokens) && (lsts-parse-head(tokens)==c"." || lsts-parse-head(tokens)=="[") {
      match tokens {
         [Token{key:c"."}.. Token{key:c"."}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            base = App {
               close(Var{ c"macro::lhs-prefix-or-suffix", with-location(mk-token("macro::lhs-prefix-or-suffix"),loc) }),
               close(App{ close(base), close(next) })
            };
         );
         [Token{key:c"."}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c".", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            base = App {
               close(Var{ c"macro::lhs-field", with-location(mk-token("macro::lhs-field"),loc) }),
               close(App{ close(base), close(next) })
            };
         );
         [Token{key:c"["}.. rest] => (
            let loc = head(tokens).location;
            lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
            let next-rest = lsts-parse-expression(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
            base = App {
               close(Var{ c"macro::lhs-index", with-location(mk-token("macro::lhs-index"),loc) }),
               close(App{ close(base), close(next) })
            };
         );
      }
   };
   Tuple { base, tokens }
);

let lsts-make-maybe-var(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      lsts-parse-lit(tokens)
   } else {
      if not(non-zero(tokens)) { lsts-parse-expect(c"Identifier", tokens); };
      let t = head(tokens);
      let base = Var { lsts-unwrap-identifier(t.key), lsts-unwrap-identifier(t) };
      if lsts-is-lit(t.key) { base = lsts-make-lit(t); };
      tokens = tail(tokens);
      Tuple { base, tokens }
   }
);

let lsts-is-lit(s: CString): U64 = (
   let r = 0_u64;
   for Tuple { sfxs=first } in parse-suffixes {
      r = r || s.has-suffix(sfxs);
   }; r;
);

let lsts-parse-add(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-mul(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"+" || lsts-parse-head(tokens)==c"-" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-mul(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   Tuple { term, tokens }
);

let lsts-parse-cmp(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-add(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"==" || lsts-parse-head(tokens)==c"!=" ||
         lsts-parse-head(tokens)==c"<" || lsts-parse-head(tokens)==c"<=" ||
         lsts-parse-head(tokens)==c">" || lsts-parse-head(tokens)==c">=" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      if (op==c"<" && lsts-parse-head(tokens)==c"<") ||
         (op==c">" && lsts-parse-head(tokens)==c">") {
         op = op + op; op-t = with-key(op-t, op); tokens = tail(tokens);
      };
      let term2-rest = lsts-parse-add(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   Tuple { term, tokens }
);

let lsts-parse-andor(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-cmp(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"&&" || lsts-parse-head(tokens)==c"||" || lsts-parse-head(tokens)==c"^" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-cmp(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   Tuple { term, tokens }
);

let lsts-parse-mul(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-atom(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"*" || lsts-parse-head(tokens)==c"/" || lsts-parse-head(tokens)==c"%" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-atom(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   lsts-parse-atom-tail( term, tokens )
);

let lsts-parse-map(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"{", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit{ c"HashtableEqEOF", with-location(mk-token("HashtableEqEOF"),loc) };
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO map comprehension at \{loc}\n")
   } else {
      if lsts-parse-head(tokens) != c"}" {
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            let item-rest = lsts-parse-expression(tokens);
            let item = item-rest.first;
            tokens = item-rest.second;
            let mapped = if non-zero(tokens) && lsts-parse-head(tokens)==c":" {
               lsts-parse-expect(c":", tokens); tokens = tail(tokens);
               let mapped-rest = lsts-parse-expression(tokens);
               tokens = mapped-rest.second;
               mapped-rest.first;
            } else {
               Lit{ c"1_u64", with-location(mk-token("1_u64"),loc) }
            };
            term = App {
               close(Var{ c"map::cons", with-location(mk-token("map::cons"),loc) }),
               close(App{ close(App{ close(item), close(mapped) }), close(term) })
            };
            if non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
      };
   };
   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   Tuple { term, tokens }
);

let lsts-parse-lhs-big(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-lhs-one(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   if lsts-parse-head(tokens) == c"=" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      let val-rest = lsts-parse-lhs(tokens);
      tokens = val-rest.second;
      base = App {
         close(Var{ c"macro::lhs-bind", with-location(mk-token("macro::lhs-bind"),loc) }),
         close(App{ close(base), close(val-rest.first) })
      };
   };
   Tuple { base, tokens }
);

let lsts-parse-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"[", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit{ c"LEOF", with-location(mk-token("LEOF"),loc) };
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO List Comprehension at \{loc}")
   } else {
      if lsts-parse-head(tokens)!=c"]" {
         let add-items = [] :: List<AST>;
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"]" {
            let item-rest = lsts-parse-expression(tokens);
            tokens = item-rest.second;
            add-items = cons( item-rest.first, add-items );
            if non-zero(tokens) && lsts-parse-head(tokens)!=c"]" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
         for add-item in add-items {
            term = App {
               close(Var{ c"list::cons", with-location(mk-token("list::cons"),loc) }),
               close(App{ close(add-item), close(term) })
            };
         };
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple { term, tokens }
);

let lsts-parse-interface(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"interface", tokens); tokens = tail(tokens);

   let interface-type-t = lsts-parse-type(tokens);
   tokens = interface-type-t.second;
   let interface-type = interface-type-t.first;

   lsts-parse-expect(c"{", tokens); tokens = tail(tokens);

   while lsts-parse-head(tokens) == c"let" {
      lsts-parse-expect(c"let", tokens); let loc = head(tokens).location; tokens = tail(tokens);

      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)) || lsts-parse-head(tokens)==c".", tokens);
      let name = lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
      if name == c"." {
         lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
         name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
      };

      let sig = lsts-parse-function-signature(tokens, loc);
      tokens = sig.second;
      let args-list = sig.first.args-list;
      let return-type = sig.first.return-type;

      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   };

   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);

   if lsts-parse-head(tokens) == c";" {
      lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   };

   # ignored for now

   tokens
);

let lsts-parse-typedef(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"type", tokens); tokens = tail(tokens);
   let mode = c"=";
   if lsts-parse-head(tokens)==c"opaque" {
      lsts-parse-expect(c"opaque", tokens); tokens = tail(tokens);
      lsts-parse-expect(c"alias", tokens); tokens = tail(tokens);
      mode = c"opaque";
   } else if lsts-parse-head(tokens)==c"alias" {
      lsts-parse-expect(c"alias", tokens); tokens = tail(tokens);
      mode = c"alias";
   };
   let base-rest = lsts-parse-type(tokens);
   tokens = base-rest.second;
   match tokens {
      [Token{key:c"="}.. Token{key:c">"}.. rest] => (
         tokens = rest;
         let rt-rest = lsts-parse-type(tokens);
         tokens = rt-rest.second;
         lsts-parse-expect(c";", tokens); tokens = tail(tokens);
         add-quick-prop(base-rest.first, base-rest.first, rt-rest.first);
         add-weaken-quick-prop(base-rest.first, rt-rest.first, rt-rest.first);
      );
      _ => (
         if mode==c"=" {
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            let case-rest = lsts-parse-typedef-case(tokens);
            let cases = case-rest.first;
            tokens = case-rest.second;
            while non-zero(tokens) && lsts-parse-head(tokens)!=c";" {
               lsts-parse-expect(c"|", tokens); let bar = head(tokens); tokens = tail(tokens);
               case-rest = lsts-parse-typedef-case(tokens);
               tokens = case-rest.second;
               cases = App{ close(App{ close(cases), close(Var{ bar.key, bar }) }), close(case-rest.first) };
            };
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            ast-parsed-program = Seq {
               close(ast-parsed-program),
               close(Typedef{ close(AType{ base-rest.first }), close(cases) })
            };
         } else if mode==c"alias" {
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            let case-rest = lsts-parse-type(tokens);
            tokens = case-rest.second;
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            add-type-alias(base-rest.first, case-rest.first);
         } else if mode==c"opaque" {
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            let case-rest = lsts-parse-type(tokens);
            tokens = case-rest.second;
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            add-opaque-type-alias(base-rest.first, case-rest.first);
         };
      );
   };
   tokens
);

let lsts-parse-typedef-case(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"[Type Case Tag]", lsts-is-lit-head(lsts-parse-head(tokens)), tokens);
   let tag = head(tokens); tokens = tail(tokens);
   let fields = ASTEOF {};
   if lsts-parse-head(tokens) == c"{" {
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
         lsts-parse-expect(c"[Field Name]", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
         let field-name = head(tokens); tokens = tail(tokens);
         lsts-parse-expect(c":", tokens); tokens = tail(tokens);
         let type-rest = lsts-parse-type(tokens);
         let field-type = type-rest.first;
         tokens = type-rest.second;
         if non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         };
         let fkv = App{ close(Var{ field-name.key, field-name }), close(AType{ field-type }) };
         if non-zero(fields) {
            fields = App{ close(fields), close(fkv) };
         } else {
            fields = fkv;
         };
      };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   };
   let case = if non-zero(fields) {
      App{ close(Lit{ tag.key, tag }), close(fields) }
   } else {
      Lit{ tag.key, tag }
   };
   Tuple{ case, tokens }
);

type LstsFnSignature = LstsFnSignature { args-list: AST, return-type: Type };

# parses:    (a: I32, b: I32): U64
let lsts-parse-function-signature(tokens: List<Token>, loc: SourceLocation): Tuple<LstsFnSignature, List<Token>> = (
   let out = LstsFnSignature { ASTNil, TAny };

   lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
   while non-zero(tokens) && lsts-parse-head(tokens)!=c")" {
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      let arg-name = head(tokens); tokens = tail(tokens);
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      let type-rest = lsts-parse-type(tokens);
      tokens = type-rest.second;
      if lsts-parse-head(tokens)==c"," { tokens = tail(tokens); } else { lsts-parse-expect(c")", tokens); };
      let arg-binding = App {
         close(Lit{ c":", with-location(mk-token(":"),loc) }),
         close(App{ close(Var{ arg-name.key, arg-name }), close(AType{ type-rest.first }) })
      };
      if is( out.args-list, ASTNil{} ) {
         out.args-list = arg-binding;
      } else {
         out.args-list = App{ close(out.args-list), close(arg-binding) };
      };
   };
   lsts-parse-expect(c")", tokens); tokens = tail(tokens);

   if lsts-parse-head(tokens) == c":" {
       lsts-parse-expect(c":", tokens); tokens = tail(tokens);
       let rtype-rest = lsts-parse-type(tokens);
       out.return-type = rtype-rest.first;
       tokens = rtype-rest.second;
   };

   Tuple { out, tokens }
);

let lsts-parse-let(tokens: List<Token>): List<Token> = (
   lsts-parse-expect(c"let", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let prop = 0;
   if lsts-parse-head(tokens)==c"prop" {
      prop = 1;
      lsts-parse-expect(c"prop", tokens); tokens = tail(tokens);
   };
   let misc-tt = TAny;
   if lsts-parse-head(tokens)==c":" {
      lsts-parse-expect(c":", tokens); tokens = tail(tokens);
      (misc-tt, tokens) = lsts-parse-type(tokens);
   };
   lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)) || lsts-parse-head(tokens)==c".", tokens);
   let name = lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   if name == c"." {
      lsts-parse-expect(c"Identifier", lsts-is-ident-head(lsts-parse-head(tokens)), tokens);
      name = name + lsts-unwrap-identifier(lsts-parse-head(tokens)); tokens = tail(tokens);
   };
   let args-list = ASTEOF {};
   let return-type = TAny {};
   if lsts-parse-head(tokens) == c"(" {
      let sig = lsts-parse-function-signature(tokens, loc);
      tokens = sig.second;
      args-list = sig.first.args-list;
      return-type = sig.first.return-type;
   };
   lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
   let rhs-rest = lsts-parse-small-expression(tokens);
   let return-term = rhs-rest.first;
   tokens = rhs-rest.second;
   if non-zero(args-list) {
      return-term = App {
         close(Lit{ c":", with-location(mk-token(":"),loc) }),
         close(App{ close(return-term), close(AType{ return-type }) })
      };
   };
   lsts-parse-expect(c";", tokens); tokens = tail(tokens);
   if non-zero(args-list) {
      let attach-tt = if prop { t1(c"Prop") } else { TAny{} };
      if name==c"quick-prop" {
         match args-list {
            App{ left:Lit{key:c":"}, right:App{right:AType{ pre=tt }} } => (
               add-quick-prop(pre, TAny{}, return-type);
            );
            _ => (
               print("Malformed quick-prop Argument List at \{loc}\n");
               exit(1);
            );
         };
      } else {
         ast-parsed-program = Seq {
            close(ast-parsed-program),
            close(Glb{ with-location(mk-token(name),loc), close(Abs{
               close(args-list), close(return-term), misc-tt && attach-tt
            }) })
         };
      };
   } else {
      ast-parsed-program = Seq {
         close(ast-parsed-program),
         close(Glb{ with-location(mk-token(name),loc), close(return-term) })
      };
   };
   tokens
);

type ASTOrIdent = ASTOrIdentAST { ast: AST }
                | ASTOrIdentId  { id: AST }
                | ASTOrIdentIgnore
                ;

let lsts-parse-small-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF {};
   match tokens {
      [Token{key:c"if"}.. Token{key:c"let"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens); tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let expr-rest = lsts-parse-small-expression(tokens); tokens = expr-rest.second;
         lsts-parse-expect(c"then", tokens); tokens = tail(tokens);
         let matched-rest = lsts-parse-small-expression(tokens); tokens = matched-rest.second;
         let default-rest = if lsts-parse-head(tokens)==c"else" {
            lsts-parse-expect(c"else", tokens); tokens = tail(tokens);
            let default-rest = lsts-parse-small-expression(tokens); tokens = default-rest.second;
            default-rest.first;
         } else ASTEOF;
         let cases = App{ close(ASTNil), close(App{ close(lhs-rest.first), close(matched-rest.first) }) };
         if non-zero(default-rest) {
            cases = App{ close(cases), close(App{
               close(Var{ c"_", with-location(mk-token(c"_"),loc) }),
               close(default-rest)
            }) };
         };
         base = App {
            close(App{
               close(Var{ c"match", with-location(mk-token("match"),loc) }),
               close(expr-rest.first)
            }),
            close(cases)
         };
      );
      [Token{key:c"if"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let c-rest = lsts-parse-andor(tokens);
         let c = c-rest.first;
         tokens = c-rest.second;
         if lsts-parse-head(tokens) != c"{" {
            lsts-parse-expect(c"then", tokens); tokens = tail(tokens);
         };
         let t = if lsts-parse-head(tokens) == c"{" {
            lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
            let t-rest = lsts-parse-expression(tokens);
            tokens = t-rest.second;
            lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            t-rest.first;
         } else {
            let t-rest = lsts-parse-assign(tokens);
            tokens = t-rest.second;
            t-rest.first;
         };
         let f = ASTNil {};
         if lsts-parse-head(tokens) == "else" {
            lsts-parse-expect(c"else", tokens); tokens = tail(tokens);
            f = if lsts-parse-head(tokens) == c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               let f-rest = lsts-parse-expression(tokens);
               tokens = f-rest.second;
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
               f-rest.first;
            } else {
               let f-rest = lsts-parse-small-expression(tokens);
               tokens = f-rest.second;
               f-rest.first;
            };
         };
         base = App {
            close(App{
               close(App{
                  close(Var{ c"if", with-location(mk-token("if"),loc) }),
                  close(c)
               }),
               close(App{
                  close(Var{ c"scope", with-location(mk-token("scope"),loc) }),
                  close(t)
               })
            }),
            close(App{
               close(Var{ c"scope", with-location(mk-token("scope"),loc) }),
               close(f)
            })
         };
      );
      [Token{key:c"let"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         base = App {
            close(App{
               close(Var{ c"let", with-location(mk-token("let"),loc) }),
               close(lhs-rest.first)
            }),
            close(rhs-rest.first)
         };
      );
      [Token{key:c"while"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let c-rest = lsts-parse-small-expression(tokens);
         tokens = c-rest.second;
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-expression(tokens);
         tokens = rhs-rest.second;
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
         base = App {
            close(App{
               close(Var{ c"while", with-location(mk-token("while"),loc) }),
               close(c-rest.first)
            }),
            close(App{
               close(Var{ c"scope", with-location(mk-token("scope"),loc) }),
               close(rhs-rest.first)
            })
         };         
      );
      [Token{key:c"for"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"in", tokens); tokens = tail(tokens);
         let iter-rest = lsts-parse-small-expression(tokens);
         tokens = iter-rest.second;
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         let rhs = ASTNil {};
         if lsts-parse-head(tokens) != c"}" {
            let rhs-rest = lsts-parse-expression(tokens);
            rhs = rhs-rest.first;
            tokens = rhs-rest.second;
         };
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
         base = App {
            close(App{
               close(Var{ c"for-each", with-location(mk-token("for-each"),loc) }),
               close(App{
                  close(App{
                     close(lhs-rest.first),
                     close(Var{ c"in", with-location(mk-token("in"),loc) }),
                  }),
                  close(iter-rest.first)
               })
            }),
            close(App{
               close(Var{ c"scope", with-location(mk-token("scope"),loc) }),
               close(rhs)
            })
         };         
      );
      [Token{key:c"match"}.. rest] => (
         let loc = head(tokens).location; tokens = rest;
         
         let raw = if lsts-parse-head(tokens)==c"raw" {
            tokens = tail(tokens); true;
         } else false;
         let e-rest = lsts-parse-small-expression(tokens);
         tokens = e-rest.second;
         if raw {
            e-rest.first = App {
               close(Var{ c"macro::bind-raw", with-location(mk-token("macro::bind-raw"),loc) }),
               close(e-rest.first)
            };
         };
         let pats = ASTNil {};
         lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            let lhs-rest = lsts-parse-lhs(tokens);
            tokens = lhs-rest.second;
            lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
            lsts-parse-expect(c">", tokens); tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"{" {
               fail("Please wrap map literals in match cases in parenthesis. At \{tokens.formatted-location}\n");
            };
            let rhs-rest = lsts-parse-small-expression(tokens);
            tokens = rhs-rest.second;
            lsts-parse-expect(c";", tokens); tokens = tail(tokens);
            pats = App { close(pats), close(App{ close(lhs-rest.first), close(rhs-rest.first) }) };
         };
         lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
         base = App {
            close(App{
               close(Var{ c"match", with-location(mk-token("match"),loc) }),
               close(e-rest.first)
            }),
            close(pats)
         };
      );
      _ => (
         let assign-rest = lsts-parse-assign(tokens);
         base = assign-rest.first;
         tokens = assign-rest.second;
      );
   };
   Tuple { base, tokens }
);

let lsts-parse-assign(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF;
   if lsts-has-assign(tokens) {
      let loc = head(tokens).location;

      if lsts-parse-head(tokens) == c"(" {
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);

         let lefts = [] :: List<ASTOrIdent>;

         let loop = true;
         while loop {
            match lsts-parse-head(tokens) {
               c"_" => (
                  tokens = tail(tokens);
                  lefts = cons(ASTOrIdentIgnore {}, lefts);
               );

               c"let" => (
                  tokens = tail(tokens);
                  let lhs = lsts-parse-lhs(tokens);
                  tokens = lhs.second;
                  lefts = cons(ASTOrIdentId { lhs.first }, lefts);
               );

               hd => (
                  let lhs = lsts-parse-lhs(tokens);
                  tokens = lhs.second;
                  lefts = cons(ASTOrIdentAST { lhs.first }, lefts);
               );
            };

            if lsts-parse-head(tokens) == c"," {
               tokens = tail(tokens);
            } else {
               loop = false;
            };
         };

         lsts-parse-expect(c")", tokens); tokens = tail(tokens);

         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         let rhs-tmp-name = uuid();
         let rhs-tmp = Var{ rhs-tmp-name, with-location(mk-token(rhs-tmp-name),loc) };
         base = App{
            close(App{
               close(Var{ c"let", with-location(mk-token(c"let"),loc) }),
               close(rhs-tmp)
            }),
            close(rhs-rest.first)
         };

         let i = 0_u64;
         for lhs in lefts {
            let fieldstr = c"." + to-string(i+1);
            let rexpr = close(App {
               close(Var{ fieldstr, with-location(mk-token(fieldstr),loc) }),
               close(rhs-tmp)
            });

            match lhs {
               ASTOrIdentIgnore {} => ();

               ASTOrIdentAST { ast=ast } => (
                  let x = App {
                     close(App{
                        close(Var{ c"set", with-location(mk-token("set"),loc) }),
                        close(ast)
                     }),
                     rexpr
                  };
                  base = App { close(base), close(x) };
               );

               ASTOrIdentId { id=id } => (
                  let x = App {
                     close(App{
                        close(Var{ c"let", with-location(mk-token("let"),loc) }),
                        close(id)
                     }),
                     rexpr
                  };
                  base = App { close(base), close(x) };
               );
            };
            i = i + 1;
         };
      } else {
         let lhs-rest = lsts-parse-lhs(tokens);
         tokens = lhs-rest.second;
         lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
         let rhs-rest = lsts-parse-small-expression(tokens);
         tokens = rhs-rest.second;
         base = App {
            close(App{
               close(Var{ c"set", with-location(mk-token("set"),loc) }),
               close(lhs-rest.first)
            }),
            close(rhs-rest.first)
         };
      };
   } else {
      let base-rest = lsts-parse-andor(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
   };
   Tuple { base, tokens }
);

let lsts-make-lit(t: Token): AST = (
   let loc = t.location;
   let base = Lit { t.key, t };
   if t.key.has-suffix(c"_ss") && t.key.contains(c"\\{") {
      let s = t.key;
      base = ASTEOF {};
      let buffer = SNil{};
      while non-zero(s) && s != c"_ss" {
         if s.has-prefix(c"\\{") {
            if non-zero(buffer) {
               buffer = buffer + SAtom{c"_ss"};
               let bs = clone-rope(buffer);
               let be = Lit { bs, with-location(mk-token(bs),loc) };
               if non-zero(base) {
                  base = App {
                     close(Var{ c"+", with-location(mk-token("+"),loc) }),
                     close(App{ close(base), close(be) })
                  };
               } else { base = be; };
               buffer = SNil {};
            };

            s = s.remove-prefix(c"\\{");
            let t-buffer = SNil {};
            while non-zero(s) && not(s.has-prefix(c"}")) {
               t-buffer = t-buffer + SAtom{clone-rope(head-string(s))};
               s = tail-string(s);
            };
            if non-zero(s) && s.has-prefix(c"}") {
               s = tail-string(s);
            };
            let sub-tokens = lsts-tokenize-string(c"[Format String]", clone-rope(t-buffer));
            let se-rest = lsts-parse-expression(sub-tokens);
            let se = App{
               close(Var{ c"to-smart-string", with-location(mk-token("to-smart-string"),loc) }),
               close(se-rest.first)
            };
            if non-zero(base) {
               base = App{
                  close(Var{ c"+", with-location(mk-token("+"),loc) }),
                  close(App{ close(base), close(se) })
               };
            } else {
               base = se;
            };
            if non-zero(se-rest.second) {
               lsts-parse-expect(c"[EOF]", se-rest.second);
            }
         } else {
            buffer = buffer + SAtom {clone-rope(head-string(s))};
            s = tail-string(s);
         }
      };
      if non-zero(buffer) {
         buffer = buffer + SAtom{ c"_ss" };
         let bs = clone-rope(buffer);
         let be = Lit{ bs, with-location(mk-token(bs),loc) };
         if non-zero(base) {
            base = App{
               close(Var{ c"+", with-location(mk-token("+"),loc) }),
               close(App{ close(base), close(be) })
            };
         } else {
            base = be;
         };
      };
   };
   base
);

let lsts-parse-lhs-one(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let base-rest = lsts-make-maybe-var(tokens);
      tokens = base-rest.second;
      base-rest.first;
   } else if lsts-parse-head(tokens)==c"&" {
      let amp = head(tokens); tokens = tail(tokens);
      let base-rest = lsts-parse-lhs-one(tokens);
      tokens = base-rest.second;
      App{
         close(Var{ amp.key, amp }),
         close(base-rest.first)
      };
   } else if lsts-is-lit(lsts-parse-head(tokens)) {
      let base-rest = lsts-parse-lit(tokens);
      tokens = base-rest.second;
      base-rest.first;
   } else if non-zero(tokens) && lsts-parse-head(tokens)==c"[" {
      let base-rest = lsts-parse-lhs-list(tokens);
      tokens = base-rest.second;
      base-rest.first; 
   } else if non-zero(tokens) && lsts-parse-head(tail(tokens))==c"{" {
      let loc = head(tokens).location;
      let tag = lsts-parse-head(tokens); tokens = tail(tokens);
      lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
      let des-args = ASTEOF {};
      while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
         let attr-loc = head(tokens).location;
         let binding = c"";
         let attr-key = c"";
         let raw = false;
         if lsts-parse-head(tokens) == c"raw" {
            raw = true; tokens = tail(tokens);
         };
         if lsts-is-ident-head(lsts-parse-head(tokens)) {
            attr-key = lsts-parse-head(tokens); tokens = tail(tokens);
         };
         if lsts-parse-head(tokens)==c"=" {
            binding = attr-key; tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"raw" {
               raw = true; tokens = tail(tokens);
            };
            if lsts-is-ident-head(lsts-parse-head(tokens)) {
               attr-key = lsts-parse-head(tokens); tokens = tail(tokens);
            } else { lsts-parse-expect(c"[Identifier]", tokens); };
         };
         let val = if lsts-parse-head(tokens)==c":" {
            tokens = tail(tokens);
            let val-rest = lsts-parse-lhs-one(tokens);
            tokens = val-rest.second;
            val-rest.first;
         } else { ASTEOF{} };
         if not(non-zero(val)) && not(non-zero(binding)) && not(non-zero(attr-key)) {
            lsts-parse-expect(c"[Struct LHS]", tokens); tokens = tail(tokens);
         };
         if not(non-zero(val)) {
            val = Var{ c"_", with-location(mk-token("_"),attr-loc) };
         };
         if non-zero(binding) {
            val = App{
               close(Var{ c"@", with-location(mk-token("@"),attr-loc) }),
               close(App{
                  close(Var{ binding, with-location(mk-token(binding),attr-loc) }),
                  close(val)
               })
            };
            if raw {
               val = App{
                  close(Var{ c"macro::bind-raw", with-location(mk-token("macro::bind-raw"),attr-loc) }),
                  close(val)
               };
            };
         };
         if non-zero(attr-key) {
            attr-key = c"." + attr-key;
            val = App{
               close(Var{ c"macro::bind-field-by-key", with-location(mk-token("macro::bind-field-by-key"),attr-loc) }),
               close(App{
                  close(Var{ attr-key, with-location(mk-token(attr-key),attr-loc) }),
                  close(val)
               })
            };
         };
         if non-zero(des-args) {
            des-args = App { close(des-args), close(val) };
         } else { des-args = val; };
         if lsts-parse-head(tokens) != c"}" {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         };
      };
      if not(non-zero(des-args)) { des-args = ASTNil {}; };
      lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
      App{
         close(Lit{ tag, with-location(mk-token(tag),loc) }),
         close(des-args)
      };
   } else {
      lsts-parse-expect(c"[Left Hand Side]", tokens);
      ASTEOF {}
   };
   Tuple { base, tokens }
);

let lsts-parse-lit(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let loc = head(tokens).location;
   let term = ASTEOF {};
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      while lsts-parse-head(tokens).has-suffix(c"_ss") {
         let cat = lsts-make-lit(head(tokens));
         tokens = tail(tokens);
         if non-zero(term) {
            term = App {
               close(Var{ c"+", with-location(mk-token("+"),loc) }),
               close(App{ close(term), close(cat) })
            };
         } else { term = cat; };
      }
   } else {
      term = lsts-make-lit(head(tokens));
      tokens = tail(tokens);
   };
   Tuple { term, tokens }
);

let lsts-parse-atom-without-tail(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term = ASTEOF {};
   if lsts-parse-head(tokens)==c"type" {
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = AType{ t2(c"Type", term-rest.first) };
   } else if lsts-parse-head(tokens)==c"raw-type" {
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = AType{ term-rest.first };
   } else if lsts-parse-head(tokens)==c"sizeof" {
      let loc = head(tokens).location;
      tokens = tail(tokens);
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let term-rest = lsts-parse-type(tokens);
      tokens = term-rest.second;
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      term = App {
         close(Var{ c"sizeof", with-location(mk-token(c"sizeof"),loc) }),
         close(AType{ term-rest.first })
      };
   } else if lsts-parse-head(tokens)==c"&" {
      let amp = head(tokens);
      tokens = tail(tokens);
      let term-rest = lsts-parse-atom-without-tail(tokens);
      tokens = term-rest.second;
      term = App {
         close(Var{ amp.key, amp }),
         close(term-rest.first)
      };
      term-rest = lsts-parse-atom-tail(term, tokens);
      term = term-rest.first;
      tokens = term-rest.second;
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let term-rest = lsts-make-maybe-var(tokens);
      tokens = term-rest.second;
      term = term-rest.first;
   } else if lsts-is-lit(lsts-parse-head(tokens)) {
      let term-rest = lsts-parse-lit(tokens);
      tokens = term-rest.second;
      term = term-rest.first;
   } else match tokens {
      [Token{key:c"("}.. rest] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c")" {
            lsts-parse-expect(c")", tokens); tokens = tail(tokens);
            term = ASTNil {};
         } else {
            let term-rest = lsts-parse-expression-possibly-tuple(tokens);
            tokens = term-rest.second;
            lsts-parse-expect(c")", tokens); tokens = tail(tokens);
            term = term-rest.first;
         }
      );
      [Token{key:c"["}.. rest] => (
         let term-rest = lsts-parse-list(tokens);
         tokens = term-rest.second;
         term = term-rest.first;
      );
      [Token{key:c"{"}.. rest] => (
         let term-rest = lsts-parse-map(tokens);
         tokens = term-rest.second;
         term = term-rest.first;
      );
      _ => (
         if lsts-is-enum-head(lsts-parse-head(tokens)) {
            let tag = head(tokens); tokens = tail(tokens);
            term = Lit { tag.key, tag };
            let fields = ASTEOF {};
            if lsts-parse-head(tokens) == c"{" {
               lsts-parse-expect(c"{", tokens); tokens = tail(tokens);
               while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
                  let field-rest = lsts-parse-small-expression(tokens);
                  tokens = field-rest.second;
                  if non-zero(fields) {
                     fields = App{ close(fields), close(field-rest.first) };
                  } else { fields = field-rest.first; };
                  if lsts-parse-head(tokens)==c"," {
                     tokens = tail(tokens);
                  } else {
                     lsts-parse-expect(c"}", tokens);
                  };
               };
               lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
            };
            if non-zero(fields) {
               term = App{ close(term), close(fields) };
            };
         } else {
            lsts-parse-expect(c"[Atom]", tokens);
         }
      );
   };
   Tuple { term, tokens };
);

let lsts-parse-atom(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let atom-rest = lsts-parse-atom-without-tail(tokens);
   lsts-parse-atom-tail(atom-rest.first,atom-rest.second);
);

let lsts-parse-atom-tail(base: AST, tokens: List<Token>): Tuple<AST,List<Token>> = (
   while lsts-parse-head(tokens) == c"[" ||
         lsts-parse-head(tokens) == c"(" ||
         lsts-parse-head(tokens) == c"." ||
         lsts-parse-head(tokens) == c"as" ||
         (lsts-parse-head(tokens) == c":" && non-zero(tokens) && lsts-parse-head(tail(tokens)) == c":") {
      let loc = head(tokens).location;
      match tokens {
         [Token{key:c":"}.. Token{key:c":"}.. rest] => (
            tokens = rest;
            let type-rest = lsts-parse-type(tokens);
            tokens = type-rest.second;
            base = App {
               close(Lit{ c":", with-location(mk-token(":"),loc) }),
               close(App{ close(base), close(AType{ type-rest.first }) })
            };
         );
         [Token{key:"."}.. rest] => (
            tokens = rest;
            lsts-parse-expect( c"[Identifier]", lsts-is-ident-head(lsts-parse-head(tokens)), tokens );
            let method = c"." + head(tokens).key; tokens = tail(tokens);
            if lsts-parse-head(tokens) == c"(" {
               lsts-parse-expect( c"(", tokens ); tokens = tail(tokens);
               while non-zero(tokens) && lsts-parse-head(tokens)!=c")" {
                  let next-rest = lsts-parse-expression(tokens);
                  tokens = next-rest.second;
                  if non-zero(tokens) && lsts-parse-head(tokens)==c"," {
                     tokens = tail(tokens);
                  } else {
                     lsts-parse-expect( c")", tokens );
                  };
                  base = App{ true, close(base), close(next-rest.first) };
               };
               lsts-parse-expect( c")", tokens ); tokens = tail(tokens);
            };
            base = App {
               close(Var{ method, with-location(mk-token(method),loc) }),
               close(base)
            };
         );
         [Token{key:"as"}.. rest] => (
            tokens = rest;
            let type-rest = lsts-parse-type(tokens); 
            tokens = type-rest.second;
            base = App {
               close(Var{ c"as", with-location(mk-token("as"),loc) }),
               close(App{ close(base), close(AType{ type-rest.first }) })
            };
         );
         [Token{key:"["}.. rest] => (
            tokens = rest;
            let term1 = if lsts-parse-head(tokens)==c":" {
               Lit{ c"0_i64", with-location(mk-token("0_i64"),loc) }
            } else {
               let term1-rest = lsts-parse-small-expression(tokens);
               tokens = term1-rest.second;
               term1-rest.first;
            };
            let term2 = ASTEOF {};
            if lsts-parse-head(tokens)==c":" {
               lsts-parse-expect( c":", tokens ); tokens = tail(tokens);
               term2 = if lsts-parse-head(tokens)==c"]" {
                  Lit{ c"minimum-I64", with-location(mk-token("minimum-I64"),loc) }
               } else {
                  let term2-rest = lsts-parse-small-expression(tokens);
                  tokens = term2-rest.second;
                  term2-rest.first;
               };
            };
            if non-zero(term2) {
               base = App {
                  close(Var{ c"[:]", with-location(mk-token("[:]"),loc) }),
                  close(App{ close(App{ close(base), close(term1) }), close(term2) })
               };
            } else {
               base = App {
                  close(Var{ c"[]", with-location(mk-token("[:]"),loc) }),
                  close(App{ close(base), close(term1) })
               };
            };
            lsts-parse-expect( c"]", tokens ); tokens = tail(tokens);
         );
         [Token{key:"("}.. rest] => (
            tokens = rest;
            if lsts-parse-head(tokens) == c")" {
               base = App{ close(base), close(ASTNil {}) };
            } else {
               let term2-rest = lsts-parse-expression(tokens);
               let term2 = term2-rest.first;
               tokens = term2-rest.second;
               while lsts-parse-head(tokens)==c"," {
                  tokens = tail(tokens);
                  let term3-rest = lsts-parse-expression(tokens);
                  tokens = term3-rest.second;
                  term2 = App{ true, close(term2), close(term3-rest.first) };
               };
               base = App{ close(base), close(term2) };
            };
            lsts-parse-expect( c")", tokens ); tokens = tail(tokens);
         );
      }
   };
   Tuple { base, tokens }
);
