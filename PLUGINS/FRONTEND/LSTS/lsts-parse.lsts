
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").remove-suffix(c"\"")
   } else ident
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }
);

let lsts-parse-expect(expect: CString, b: U64, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }
);

let lsts-has-assign(tokens: List<Token>): U64 = (
   let depth = 0_i64;
   let has-assign = 0;
   while non-zero(tokens) { match tokens {
      [Token{key:c"["} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"{"} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"("} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"]"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c"}"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c")"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c";"} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c","} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c"="} .. rest] => (if depth == 0_i64 {has-assign = 1; tokens = [] :: List<Token>;} else {tokens = rest;});
      [_ .. rest] => tokens = rest;
   }; if depth < 0_i64 { tokens = [] :: List<Token>; }; };
   has-assign
);

let lsts-substitute-type-aliases(s: CString): CString = (
   if s == c"String" then c"SmartString" else
   if s == c"CString" then c"String" else
   s
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => tokens = lsts-parse-let(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil {};
            while non-zero(tokens) && lsts-parse-head(tokens) != c";" {
               path = path + SAtom { lsts-unwrap-identifier(lsts-parse-head(tokens)) };
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = Seq { close(ast-parsed-program), close(term) };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
   }
);

#let lsts-parse-type(: tokens List<Token>): Tuple<Type,List<Token>> = (
#   let tt = if lsts-parse-head(tokens) == c"(" {
#      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
#      let targs-rest = lsts-parse-type(tokens);
#      let targs = [ targs-rest.first ];
#      tokens = targs.second;
#      while lsts-parse-head(tokens) == "," {
#         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
#         let tnext-rest = lsts-parse-type(tokens);
#         targs = cons( tnext-rest.first, targs );
#         tokens = tnext-rest.second;
#      };
#      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
#      TGround { tag:c"Tuple", parameters:close(args) };
#   } else {
#      let base = lsts-substitute-type-aliases(lsts-parse-head(tokens));
#      lsts-parse-expect(c"Type", lsts-is-lit-head(lsts-parse-head(tokens)), tokens); tokens = tail(tokens);
#      let args = [] :: List<Type>;
#      if lsts-parse-head(tokens) == c"<" {
#         lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
#         let targs-rest = lsts-parse-type(tokens);
#         args = cons( targs-rest.first, args );
#         tokens = targs.second;
#         while lsts-parse-head(tokens) == "," {
#            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
#            let tnext-rest = lsts-parse-type(tokens);
#            args = cons( tnext-rest.first, args );
#            tokens = tnext-rest.second;
#         };
#         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
#      };
#      TGround { tag:base, parameters:close(args) };
#   };
#   (let base SNil)
#   (let depth 0_u64)
#   (if (==( (lsts-parse-head tokens) '\[_s )) (
#      (set base (SAtom 'Tuple<_s))(set tokens (tail tokens))
#      (set depth 1_u64)
#   ) (
#      (set base (SAtom(lsts-substitute-type-aliases(lsts-parse-head tokens))))(set tokens (tail tokens))
#   ))
#   (if (||( (==( (lsts-parse-head tokens) '<_s )) (==( (lsts-parse-head tokens) '[_s )) )) (
#      (set base (+( base (SAtom(lsts-substitute-type-aliases(lsts-parse-head tokens))) )))
#      (set tokens (tail tokens))
#      (set depth 1_u64)
#   ) ())
#   (while (>( depth 0_u64 )) (
#      (while (&&( (non-zero tokens) (>( depth 0_u64 )) )) (
#         (if (||( (||( (==( (lsts-parse-head tokens) '\[_s )) (==( (lsts-parse-head tokens) '[_s )) )) (==( (lsts-parse-head tokens) '<_s )) )) (
#            (if (==( (lsts-parse-head tokens) '\[_s )) (
#               (set base (+( base (SAtom 'Tuple<_s) )))
#            ) (
#               (set base (+( base (SAtom(lsts-parse-head tokens)) )))
#            ))
#            (set depth (+( depth 1_u64 )))
#         ) (
#            (if (||( (||( (==( (lsts-parse-head tokens) '\]_s )) (==( (lsts-parse-head tokens) ']_s )) )) (==( (lsts-parse-head tokens) '>_s )) )) (
#               (if (==( (lsts-parse-head tokens) '\]_s )) (
#                  (set base (+( base (SAtom '>_s) )))
#               ) (
#                  (set base (+( base (SAtom(lsts-parse-head tokens)) )))
#               ))
#               (set depth (-( depth 1_u64 )))
#            ) (
#               (set base (+( base (SAtom(lsts-substitute-type-aliases(lsts-parse-head tokens))) )))
#            ))
#         ))
#         (set tokens (tail tokens))
#      ))
#   ) ())
#   (Tuple( (parse-type(clone-rope base)) tokens ))
#);
