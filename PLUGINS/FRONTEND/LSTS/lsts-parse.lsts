
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").remove-suffix(c"\"")
   } else ident
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }
);

let lsts-parse-expect(expect: CString, b: U64, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }
);

let lsts-has-assign(tokens: List<Token>): U64 = (
   let depth = 0_i64;
   let has-assign = 0;
   while non-zero(tokens) { match tokens {
      [Token{key:c"["} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"{"} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"("} .. rest] => (depth = depth + 1_i64; tokens = rest;);
      [Token{key:c"]"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c"}"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c")"} .. rest] => (depth = depth - 1_i64; tokens = rest;);
      [Token{key:c";"} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c","} .. rest] => (if depth <= 0_i64 {tokens = [] :: List<Token>} else {tokens = rest;});
      [Token{key:c"="} .. rest] => (if depth == 0_i64 {has-assign = 1; tokens = [] :: List<Token>;} else {tokens = rest;});
      [_ .. rest] => tokens = rest;
   }; if depth < 0_i64 { tokens = [] :: List<Token>; }; };
   has-assign
);

let lsts-substitute-type-aliases(s: CString): CString = (
   if s == c"String" then c"SmartString" else
   if s == c"CString" then c"String" else
   s
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => tokens = lsts-parse-let(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil {};
            while non-zero(tokens) && lsts-parse-head(tokens) != c";" {
               path = path + SAtom { lsts-unwrap-identifier(lsts-parse-head(tokens)) };
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = Seq { close(ast-parsed-program), close(term) };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
   }
);

let lsts-parse-type(tokens: List<Token>): Tuple<Type,List<Token>> = (
   let tt = if lsts-parse-head(tokens) == c"(" {
      lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
      let args-rest = lsts-parse-type(tokens);
      let args = [ args-rest.first ];
      tokens = args-rest.second;
      while lsts-parse-head(tokens) == "," {
         lsts-parse-expect(c",", tokens); tokens = tail(tokens);
         let tnext-rest = lsts-parse-type(tokens);
         args = cons( tnext-rest.first, args );
         tokens = tnext-rest.second;
      };
      lsts-parse-expect(c")", tokens); tokens = tail(tokens);
      TGround { c"Tuple", close(args) };
   } else if lsts-is-ident-head(lsts-parse-head(tokens)) {
      let varname = lsts-parse-head(tokens); tokens = tail(tokens);
      TVar { varname }
   } else {
      let base = lsts-substitute-type-aliases(lsts-parse-head(tokens));
      lsts-parse-expect(c"Type", lsts-is-lit-head(lsts-parse-head(tokens)), tokens); tokens = tail(tokens);
      let args = [] :: List<Type>;
      if lsts-parse-head(tokens) == c"<" {
         lsts-parse-expect(c"<", tokens); tokens = tail(tokens);
         let targs-rest = lsts-parse-type(tokens);
         args = cons( targs-rest.first, args );
         tokens = targs-rest.second;
         while lsts-parse-head(tokens) == "," {
            lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            let tnext-rest = lsts-parse-type(tokens);
            args = cons( tnext-rest.first, args );
            tokens = tnext-rest.second;
         };
         lsts-parse-expect(c">", tokens); tokens = tail(tokens);
      };
      TGround { base, close(args) };
   };
   while lsts-parse-head(tokens) == c"[" {
      lsts-parse-expect(c"[", tokens); tokens = tail(tokens);
      let index = if lsts-parse-head(tokens) == c"]" {
         let tindex-rest = lsts-parse-type(tokens);
         tokens = tindex-rest.second;
         tindex-rest.first;
      } else { TAny {} };
      lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
      tt = TGround { c"Array", close([ index, tt ]) };
   };
   Tuple { tt, tokens };
);

let lsts-parse-expression-possibly-tuple(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if not(non-zero(tokens)) { lsts-parse-expect(c"ExpressionPossiblyTuple", tokens); };
   let loc = head(tokens).location;
   let base-rest = lsts-parse-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   let is-tuple = 0;
   while lsts-parse-head(tokens) == c"," {
      is-tuple = 1;
      tokens = tail(tokens);
      base-rest = lsts-parse-expression(tokens);
      base = App { close(base), close(base-rest.first) };
      tokens = base-rest.second;
   };
   if is-tuple {
      base = App {
         close(Lit{ c"Tuple", with-location(mk-token("Tuple"),loc) }),
         close(base)
      };
   };
   Tuple { base, tokens }
);

let lsts-parse-expression(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-small-expression(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   while lsts-parse-head(tokens) == c";" {
      tokens = tail(tokens);
      if lsts-parse-head(tokens)!=c")" && lsts-parse-head(tokens)!=c"}" {
         base-rest = lsts-parse-small-expression(tokens);
         base = App { close(base), close(base-rest.first) };
         tokens = base-rest.second;
      }
   };
   Tuple { base, tokens }
);

let lsts-parse-lhs-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = ASTEOF {};
   lsts-parse-expect(c"[", tokens);
   let loc = head(tokens).location;
   tokens = tail(tokens);
   if lsts-parse-head(tokens) == c"]" {
      base = Lit { c"LEOF", with-location(mk-token("LEOF"),loc) };
   } else {
      let base-rest = lsts-parse-lhs-one(tokens);
      base = base-rest.first;
      tokens = base-rest.second;
      let bases = [base];
      while non-zero(tokens) && lsts-parse-head(tokens)==c"." {
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         lsts-parse-expect(c".", tokens); tokens = tail(tokens);
         if lsts-parse-head(tokens)==c"]" {
            bases = cons( Lit{ c"LEOF", with-location(mk-token("LEOF"),loc) }, bases );
         } else {
            let next-rest = lsts-parse-lhs-one(tokens);
            let next = next-rest.first;
            tokens = next-rest.second;
            bases = cons( next, bases );
         }
      };
      base = head(bases); bases = tail(bases);
      for b in bases {
         base = App {
            close(Var{ c"macro::lhs-head", with-location(mk-token("macro::lhs-head"),loc) }),
            close(App{ close(b), close(base) })
         };
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple { base, tokens }
);

let lsts-parse-lhs(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base = match tokens {
      [ Token{key:c"["}.. _ ] => (
         let base-rest = lsts-parse-lhs-list(tokens);
         tokens = base-rest.second;
         base-rest.first;
      );
      [ Token{key:c"("}.. _] => (
         lsts-parse-expect(c"(", tokens); tokens = tail(tokens);
         let base-rest = lsts-parse-lhs-big(tokens);
         tokens = base-rest.second;
         lsts-parse-expect(c")", tokens); tokens = tail(tokens);
         base-rest.first;
      );
      _ => (
         let base-rest = lsts-parse-lhs-one(tokens);
         tokens = base-rest.second;
         base-rest.first;         
      );
   };
   while non-zero(tokens) && lsts-parse-head(tokens)==c"." {
      let loc = head(tokens).location;
      lsts-parse-expect(c".", tokens); tokens = tail(tokens);
      lsts-parse-expect(c".", tokens); tokens = tail(tokens);
      let next-rest = lsts-parse-lhs-one(tokens);
      let next = next-rest.first;
      tokens = next-rest.second;
      base = App {
         close(Var{ c"macro::lhs-prefix-or-suffix", with-location(mk-token("macro::lhs-prefix-or-suffix"),loc) }),
         close(App{ close(base), close(next) })
      };
   };
   Tuple { base, tokens }
);

let lsts-make-maybe-var(tokens: List<Token>): Tuple<AST,List<Token>> = (
   if lsts-parse-head(tokens).has-suffix(c"_ss") {
      lsts-parse-lit(tokens)
   } else {
      if not(non-zero(tokens)) { lsts-parse-expect(c"Identifier", tokens); };
      let t = head(tokens);
      let base = Var { lsts-unwrap-identifier(t.key), t };
      if lsts-is-lit(t.key) { base = lsts-make-lit(t); };
      tokens = tail(tokens);
      Tuple { base, tokens }
   }
);

let lsts-is-lit(s: CString): U64 = (
   let r = 0;
   for Tuple { sfxs=first } in parse-suffixes {
      r = r || s.has-suffix(sfxs);
   }; r;
);

let lsts-parse-add(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-mul(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"+" || lsts-parse-head(tokens)==c"-" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-mul(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   Tuple { term, tokens }
);

let lsts-parse-cmp(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-add(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"==" || lsts-parse-head(tokens)==c"!=" ||
         lsts-parse-head(tokens)==c"<" || lsts-parse-head(tokens)==c"<=" ||
         lsts-parse-head(tokens)==c">" || lsts-parse-head(tokens)==c">=" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-add(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   Tuple { term, tokens }
);

let lsts-parse-andor(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-cmp(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"&&" || lsts-parse-head(tokens)==c"||" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-cmp(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   Tuple { term, tokens }
);

let lsts-parse-mul(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let term-rest = lsts-parse-atom(tokens);
   let term = term-rest.first;
   tokens = term-rest.second;
   while lsts-parse-head(tokens)==c"*" || lsts-parse-head(tokens)==c"/" || lsts-parse-head(tokens)==c"%" {
      let op-t = head(tokens); let op = op-t.key; tokens = tail(tokens);
      let term2-rest = lsts-parse-atom(tokens);
      tokens = term2-rest.second;
      term = App { 
         close(Var{ op, op-t }),
         close(App{ close(term), close(term2-rest.first) })
      };
   };
   lsts-parse-atom-tail( term, tokens )
);

let lsts-parse-map(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"{", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit{ c"HashtableEqEOF", with-location(mk-token("HashtableEqEOF"),loc) };
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO map comprehension at \{loc}\n")
   } else {
      if lsts-parse-head(tokens) != c"}" {
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
            let item-rest = lsts-parse-expression(tokens);
            let item = item-rest.first;
            tokens = item-rest.second;
            let mapped = if non-zero(tokens) && lsts-parse-head(tokens)==c":" {
               lsts-parse-expect(c":", tokens); tokens = tail(tokens);
               let mapped-rest = lsts-parse-expression(tokens);
               tokens = mapped-rest.second;
               mapped-rest.first;
            } else {
               Lit{ c"1_u64", with-location(mk-token("1_u64"),loc) }
            };
            term = App {
               close(Var{ c"map::cons", with-location(mk-token("map::cons"),loc) }),
               close(App{ close(App{ close(item), close(mapped) }), close(term) })
            };
            if non-zero(tokens) && lsts-parse-head(tokens)!=c"}" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
      };
   };
   lsts-parse-expect(c"}", tokens); tokens = tail(tokens);
   Tuple { term, tokens }
);

let lsts-parse-lhs-big(tokens: List<Token>): Tuple<AST,List<Token>> = (
   let base-rest = lsts-parse-lhs-one(tokens);
   let base = base-rest.first;
   tokens = base-rest.second;
   if lsts-parse-head(tokens) == c"=" {
      let loc = head(tokens).location;
      lsts-parse-expect(c"=", tokens); tokens = tail(tokens);
      let val-rest = lsts-parse-lhs(tokens);
      tokens = val-rest.second;
      base = App {
         close(Var{ c"macro::lhs-bind", with-location(mk-token("macro::lhs-bind"),loc) }),
         close(App{ close(base), close(val-rest.first) })
      };
   };
   Tuple { base, tokens }
);

let lsts-parse-list(tokens: List<Token>): Tuple<AST,List<Token>> = (
   lsts-parse-expect(c"[", tokens); let loc = head(tokens).location; tokens = tail(tokens);
   let term = Lit{ c"LEOF", with-location(mk-token("LEOF"),loc) };
   if lsts-parse-head(tokens)==c"for" {
      fail("TODO List Comprehension at \{loc}")
   } else {
      if lsts-parse-head(tokens)!=c"]" {
         let add-items = [] :: List<AST>;
         while non-zero(tokens) && lsts-parse-head(tokens)!=c"]" {
            let item-rest = lsts-parse-expression(tokens);
            tokens = item-rest.second;
            add-items = cons( item-rest.first, add-items );
            if non-zero(tokens) && lsts-parse-head(tokens)!=c"]" {
               lsts-parse-expect(c",", tokens); tokens = tail(tokens);
            }
         };
         for add-item in add-items {
            term = App {
               close(Var{ c"list::cons", with-location(mk-token("list::cons"),loc) }),
               close(App{ close(add-item), close(term) })
            };
         };
      }
   };
   lsts-parse-expect(c"]", tokens); tokens = tail(tokens);
   Tuple { term, tokens }
);
