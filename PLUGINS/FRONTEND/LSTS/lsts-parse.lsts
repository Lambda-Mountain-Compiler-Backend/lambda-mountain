
let lsts-parse-head(tokens: List<Token>): CString = (
   match tokens {
      [ Token { key=key }.. _ ] => key;
      _ => c"";
   }
);

let lsts-unwrap-identifier(ident: CString): CString = (
   if ident.has-prefix(c"$") {
      ident.remove-prefix(c"$\"").remove-suffix(c"\"")
   } else ident
);

let lsts-parse-expect(expect: CString, tokens: List<Token>): Nil = (
   if lsts-parse-head(tokens) != expect {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n");
   }
);

let lsts-parse-expect(expect: CString, b: U64, tokens: List<Token>): Nil = (
   if not(b) {
      fail("Parse Error: Expected \{expect} at \{tokens.formatted-location}\n")
   }
);

let lsts-parse(tokens: List<Token>): Nil = (
   while non-zero(tokens) {
      let prev-tokens = tokens;
      match tokens {
         [ Token{key:c"let"}.. _] => tokens = lsts-parse-let(tokens);
         [ Token{key:c"import"}.. rest] => (
            tokens = rest;
            let path = SNil {};
            while non-zero(tokens) && lsts-parse-head(tokens) != c";" {
               path = path + SAtom { lsts-unwrap-identifier(lsts-parse-head(tokens)) };
               tokens = tail(tokens);
            };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
            frontend(clone-rope(path));
         );
         _ => (
            let term-rest = lsts-parse-small-expression(tokens);
            let term = term-rest.first;
            tokens = term-rest.second;
            ast-parsed-program = Seq { close(ast-parsed-program), close(term) };
            lsts-parse-expect(c";",tokens); tokens = tail(tokens);
         );
      };
      if is(prev-tokens, tokens) { fail("Unrecognized Token During Parsing: \{lsts-parse-head(tokens)}\n") };
   }
);

