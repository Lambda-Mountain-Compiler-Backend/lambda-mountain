
lsts-parse-lhs-one := 位(: tokens List<Token>). (: (
   (let base ASTEOF)
      (if (lsts-is-ident-head(lsts-parse-head tokens)) (scope(
         (let base-rest (lsts-make-maybe-var tokens))
         (set base (.first base-rest))
         (set tokens (.second base-rest))
      )) (
         (if (lsts-is-lit(lsts-parse-head tokens)) (
            (let base-rest (lsts-parse-lit tokens))
            (set base (.first base-rest))
            (set tokens (.second base-rest))
         ) (
            (if (&&( (non-zero tokens) (==( (lsts-parse-head(tail tokens)) '{_s )) )) (
               (let loc (.location(head tokens)))
               (let tag (lsts-parse-head tokens))(set tokens (tail tokens))
               (lsts-parse-expect( '{_s tokens ))(set tokens (tail tokens))
               (let des-args ASTEOF)
               (while (&&( (non-zero tokens) (!=( (lsts-parse-head tokens) '}_s )) )) (
                  (let attr-loc (.location(head tokens)))
                  (let binding '_s)
                  (let attr-key '_s)
                  (if (lsts-is-ident-head(lsts-parse-head tokens)) (
                     (set attr-key (lsts-parse-head tokens))
                     (set tokens (tail tokens))
                  ) ())
                  (if (==( (lsts-parse-head tokens) '=_s )) (
                     (set binding attr-key)(set tokens (tail tokens))
                     (lsts-parse-expect( 'Identifier_s (lsts-is-ident-head(lsts-parse-head tokens)) tokens ))
                     (if (lsts-is-ident-head(lsts-parse-head tokens)) (
                        (set attr-key (lsts-parse-head tokens))
                        (set tokens (tail tokens))
                     ) ())
                  ) ())
                  (let val ASTEOF)
                  (if (==( (lsts-parse-head tokens) ':_s )) (
                     (set tokens (tail tokens))
                     (let val-rest (lsts-parse-lhs-one tokens))
                     (set val (.first val-rest))
                     (set tokens (.second val-rest))
                  ) ())
                  (if (&&( (&&( (not(non-zero val)) (not(non-zero binding)) )) (not(non-zero attr-key)) )) (
                     (lsts-parse-expect( 'Struct\sLHS_s 0_u64 tokens ))
                  ) ())
                  (if (non-zero val) () (
                     (set val (Var( '__s (with-location( (token::new '__s) attr-loc )) )))
                  ))
                  (if (non-zero binding) (
                     (set val (App(
                        (close(Var( '@_s (with-location( (token::new '@_s) attr-loc )) )))
                        (close(App(
                           (close(Var( binding (with-location( (token::new binding) attr-loc )) )))
                           (close val)
                        )))
                     )))
                  ) ())
                  (if (non-zero attr-key) (
                     (set attr-key (+( '._s attr-key )))
                     (set val (App(
                        (close(Var( 'macro::bind-field-by-key_s (with-location( (token::new 'macro::bind-field-by-key_s) attr-loc )) )))
                        (close(App(
                           (close(Var( attr-key (with-location( (token::new attr-key) attr-loc )) )))
                           (close val)
                        )))
                     )))
                  ) ())
                  (if (non-zero des-args) (
                     (set des-args (App(
                        (close des-args)
                        (close val)
                     )))
                  ) (set des-args val))
                  (if (==( (lsts-parse-head tokens) ',_s )) (set tokens (tail tokens)) ())
               ))
               (if (non-zero des-args) (
                  (set base (App(
                     (close(Lit( tag (with-location( (token::new tag) loc )) )))
                     (close des-args)
                  )))
               ) (
                  (set base (App(
                     (close(Lit( tag (with-location( (token::new tag) loc )) )))
                     (close ASTNil)
                  )))
               ))
               (lsts-parse-expect( '}_s tokens ))(set tokens (tail tokens))
            ) (
               (lsts-parse-expect( 'LHS_s 0_u64 tokens ))
            ))
         ))
   ))
   (Tuple( base tokens ))
) Tuple<AST,List<Token>>);

lsts-parse-atom := 位(: tokens List<Token>). (: (
   (let term ASTEOF)
   (if (lsts-is-ident-head(lsts-parse-head tokens)) (scope(
      (let term-rest (lsts-make-maybe-var tokens))
      (set term (.first term-rest))
      (set tokens (.second term-rest))
   )) (
      (if (==( (lsts-parse-head tokens) '\[_s )) (
         (set tokens (tail tokens))
         (if (==( (lsts-parse-head tokens) '\]_s )) (
            (set term ASTNil)
            (set tokens (tail tokens))
         ) (
            (let term-rest (lsts-parse-expression-possibly-tuple tokens))
            (set term (.first term-rest))
            (set tokens (.second term-rest))
            (lsts-parse-expect( '\]_s tokens ))(set tokens (tail tokens))
         ))
      ) (
         (if (==( (lsts-parse-head tokens) '[_s )) (
            (let l-term-rest (lsts-parse-list tokens))
            (set term (.first l-term-rest))
            (set tokens (.second l-term-rest))
         ) (
            (if (==( (lsts-parse-head tokens) '{_s )) (
               (let m-term-rest (lsts-parse-map tokens))
               (set term (.first m-term-rest))
               (set tokens (.second m-term-rest))
            ) (
               (if (lsts-is-lit(lsts-parse-head tokens)) (
                  (let term-rest (lsts-parse-lit tokens))
                  (set term (.first term-rest))
                  (set tokens (.second term-rest))
               ) (
                  (if (&&( (non-zero tokens) (==( (lsts-parse-head(tail tokens)) '{_s )) )) (
                     (let tag (head tokens))(set tokens (tail tokens))
                     (set term (Lit( (.key tag) tag )))
                     (lsts-parse-expect( '{_s tokens ))(set tokens (tail tokens))
                     (let fields ASTEOF)
                     (while (&&( (non-zero tokens) (!=( (lsts-parse-head tokens) '}_s )) )) (
                        (let field-rest (lsts-parse-small-expression tokens))
                        (let field (.first field-rest))
                        (set tokens (.second field-rest))
                        (if (non-zero fields) (
                           (set fields (App( (close fields) (close field) )))
                        ) (set fields field))
                        (if (==( (lsts-parse-head tokens) ',_s )) (
                           (set tokens (tail tokens))
                        ) (
                           (lsts-parse-expect( '}_s tokens ))
                        ))
                     ))
                     (lsts-parse-expect( '}_s tokens ))(set tokens (tail tokens))
                     (if (non-zero fields) (
                        (set term (App( (close term) (close fields) )))
                     ) ())
                  ) (
                     (lsts-parse-expect( 'Atom_s 0_u64 tokens ))
                  ))
               ))
            ))
         ))
      ))
   ))
   (lsts-parse-atom-tail( term tokens ))
) Tuple<AST,List<Token>>);

lsts-parse-lit :=  位(: tokens List<Token>). (: (
   (let loc (.location(head tokens)))
   (let term ASTEOF)
   (if (.has-suffix( (lsts-parse-head tokens) '_ss_s )) (
      (while (.has-suffix( (lsts-parse-head tokens) '_ss_s )) (
         (let cat (lsts-make-lit(head tokens)))
         (set tokens (tail tokens))
         (if (non-zero term) (
            (set term (App(
               (close(Var( '+_s (with-location( (token::new '+_s) loc )) )))
               (close(App(
                  (close term)
                  (close cat)
               )))
            )))
         ) (set term cat))
      ))
   ) (
      (set term (lsts-make-lit(head tokens)))
      (set tokens (tail tokens))
   ))
   (Tuple( term tokens ))
) Tuple<AST,List<Token>>);

lsts-parse-atom-tail := 位(: base AST)(: tokens List<Token>). (: (
   (while (||(
      (||(
         (||( (==( (lsts-parse-head tokens) '[_s )) (||( (==( (lsts-parse-head tokens) '\[_s )) (==( (lsts-parse-head tokens) '._s )) )) ))
         (==( (lsts-parse-head tokens) 'as_s ))
      ))
      (&&( (&&( (==( (lsts-parse-head tokens) ':_s )) (non-zero(tail tokens)) )) (==( (lsts-parse-head(tail tokens)) ':_s )) ))
   )) (
      (if (&&( (&&( (==( (lsts-parse-head tokens) ':_s )) (non-zero(tail tokens)) )) (==( (lsts-parse-head(tail tokens)) ':_s )) )) (scope(
         (set tokens (tail tokens))
         (set tokens (tail tokens))
         (let type-rest (lsts-parse-type tokens))
         (let a-type (.first type-rest))
         (set tokens (.second type-rest))
         (set base (App(
            (close(Lit( ':_s (token::new ':_s) )))
            (close(App(
               (close base)
               (close(AType a-type))
            )))
         )))
      )) (
         (if (==( (lsts-parse-head tokens) '._s )) (scope(
            (let loc (.location(head tokens)))
            (set tokens (tail tokens))
            (lsts-parse-expect( 'Identifier_s (lsts-is-ident-head(lsts-parse-head tokens)) tokens ))
            (let method (+( '._s (.key(head tokens)) )))(set tokens (tail tokens))
            (if (==( (lsts-parse-head tokens) '\[_s )) (
               (lsts-parse-expect( '\[_s tokens ))(set tokens (tail tokens))
               (while (&&( (non-zero tokens) (!=( (lsts-parse-head tokens) '\]_s )) )) (
                  (let next-rest (lsts-parse-expression tokens))
                  (let next (.first next-rest))
                  (set tokens (.second next-rest))
                  (if (&&( (non-zero tokens) (==( (lsts-parse-head tokens) ',_s )) )) (
                     (set tokens (tail tokens))
                  ) (
                     (lsts-parse-expect( '\]_s tokens ))
                  ))
                  (set base (App(
                     (close base)
                     (close next)
                  )))
               ))
               (lsts-parse-expect( '\]_s tokens ))(set tokens (tail tokens))
            ) ())
            (set base (App(
               (close(Var( method (with-location( (token::new method) loc )) )))
               (close base)
            )))
         )) (
            (if (==( (lsts-parse-head tokens) 'as_s )) (scope(
               (let loc (.location(head tokens)))
               (lsts-parse-expect( 'as_s tokens ))(set tokens (tail tokens))
               (let type-rest (lsts-parse-type tokens))
               (let a-type (.first type-rest))
               (set tokens (.second type-rest))
               (set base (App(
                  (close(Var( 'as_s (with-location( (token::new 'as_s) loc )) )))
                  (close(App(
                     (close base)
                     (close(AType a-type))
                  )))
               )))
            )) (
               (if (==( (lsts-parse-head tokens) '[_s )) (scope(
                  (let loc (.location(head tokens)))
                  (lsts-parse-expect( '[_s tokens ))(set tokens (tail tokens))
                  (let term1 ASTEOF)
                  (if (==( (lsts-parse-head tokens) ':_s )) (
                     (set term1 (Lit( '0_i64_s (with-location( (token::new '0_i64_s) loc )) )))
                  ) (
                     (let term1-rest (lsts-parse-small-expression tokens))
                     (set term1 (.first term1-rest))
                     (set tokens (.second term1-rest))
                  ))
                  (let term2 ASTEOF)
                  (if (==( (lsts-parse-head tokens) ':_s )) (
                     (lsts-parse-expect( ':_s tokens ))(set tokens (tail tokens))                  
                     (if (==( (lsts-parse-head tokens) ']_s )) (
                        (set term2 (Var( 'minimum-I64_s (with-location( (token::new 'minimum-I64_s) loc )) )))
                     ) (
                        (let term2-rest (lsts-parse-small-expression tokens))
                        (set term2 (.first term2-rest))
                        (set tokens (.second term2-rest))
                     ))
                  ) ())
                  (if (non-zero term2) (
                     (set base (App(
                        (close(Var( '[:]_s (with-location( (token::new '[:]_s) loc )) )))
                        (close(App(
                           (close(App(
                              (close base)
                              (close term1)
                           )))
                           (close term2)
                        )))
                     )))
                  ) (
                     (set base (App(
                        (close(Var( '[]_s (with-location( (token::new '[]_s) loc )) )))
                        (close(App(
                           (close base)
                           (close term1)
                        )))
                     )))
                  ))
                  (lsts-parse-expect( ']_s tokens ))(set tokens (tail tokens))
               )) (
                  (lsts-parse-expect( '\[_s tokens ))(set tokens (tail tokens))
                  (if (==( (lsts-parse-head tokens) '\]_s )) (
                     (set base (App(
                        (close base)
                        (close ASTNil)
                     )))
                     (set tokens (tail tokens))
                  ) (
                     (let term2-rest (lsts-parse-expression tokens))
                     (let term2 (.first term2-rest))
                     (set tokens (.second term2-rest))
                     (while (==( (lsts-parse-head tokens) ',_s )) (
                        (set tokens (tail tokens))
                        (let term3-rest (lsts-parse-expression tokens))
                        (let term3 (.first term3-rest))
                        (set tokens (.second term3-rest))
                        (set term2 (App(
                           (close term2)
                           (close term3)
                        )))
                     ))
                     (set base (App(
                        (close base)
                        (close term2)
                     )))
                     (lsts-parse-expect( '\]_s tokens ))(set tokens (tail tokens))
                  ))
               ))
            ))
         ))
      ))
   ))
   (Tuple( base tokens ))
) Tuple<AST,List<Token>>);


