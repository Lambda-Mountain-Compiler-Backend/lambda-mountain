
let std-c-compile-expr(ctx: FContext, t: AST): Fragment = (
   match t {
      App{ left:Lit{key:c":"}, right:App{ inner-term=left, right:AType{tt=tt} } } => (
         std-c-compile-expr(ctx, inner-term);
      );
      App{ left:Var{key:c"c::compound"}, terms=right } => (
         let e = mk-fragment();
         let terms-list = [] :: List<AST>;
         while non-zero(terms) {match terms {
            App{left=left, right=right} => (
               terms-list = cons( right, terms-list );
               terms = left;
            );
            _ => terms = ASTEOF;
         }};
         for ct in terms-list.reverse {
            let f = std-c-compile-expr(ctx, ct);
            ctx = open(f.context);
            e = std-c-chain( e, f );
         };
         e = e.set(c"expression", SAtom{c"{"} + e.get(c"expression") + SAtom{c"}"} );
         e
      );
      _ => (
         print("TODO: std-c-compile-expr\n");
         std-c-print(t); exit(1); mk-fragment();
      );
   }
);

