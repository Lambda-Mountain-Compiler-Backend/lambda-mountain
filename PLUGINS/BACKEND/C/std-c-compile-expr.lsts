
let std-c-compile-expr(ctx: FContext, t: AST): Fragment = (
   print("Compile "); std-c-print(t); print("\n");
   let f = match t {
      App{ left:Abs{lhs=lhs:Var{name=key}, rhs:ASTNil{}}, rhs=right } => (
         let lt = typeof(lhs);
         let v = mk-fragment().set(c"expression",SAtom{uuid()});
         let f = mk-fragment();
         f.context = close(ctx.bind( name, lt, f ));
         (let pre, let post) = std-c-mangle-declaration(lt);
         f = f.set(c"frame", f.get(c"frame") + pre + SAtom{c" "}
                 + (if lt.is-t(c"C") then SAtom{name} else v.get(c"expression"))
                 + SAtom{c" "} + post + SAtom{c";"}
         );
         match rhs {
            App{ left:Lit{key:c":"}, right:App{ left:Var{key:c"__uninitialized"}, right:AType{tt=tt} } } => ();
            _ => (
               let rf = std-c-compile-expr(ctx, rhs);
               f = f.set(c"frame", f.get(c"frame") + rf.get(c"frame"));
               f = f.set(c"expression", SAtom(c"(")
                 + (if lt.is-t(c"C") then SAtom{name} else v.get(c"expression"))
                 + SAtom{c"="} + rf.get(c"expression") + SAtom{c")"};
            );
         };
         f
      );
      App{ left:Lit{key:c":"}, right:App{ left:Lit{val=key}, right:AType{tt=tt} } } => (
         if tt.is-t(c"C") && tt.r1.is-t(c"uint8_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"uint16_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"uint32_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"uint64_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"int8_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"int16_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"int32_t") then mk-expression(val)
         else if tt.is-t(c"C") && tt.r1.is-t(c"int64_t") then mk-expression(val)
         else (fail("Unknown C Literal Type: \{tt}"); mk-fragment());
      );
      App{ left:Lit{key:c":"}, right:App{ inner-term=left, right:AType{tt=tt} } } => (
         std-c-compile-expr(ctx, inner-term);
      );
      App{ left:Var{key:c"c::compound"}, terms=right } => (
         let e = mk-fragment();
         let terms-list = [] :: List<AST>;
         while non-zero(terms) {match terms {
            App{left=left, right=right} => (
               terms-list = cons( right, terms-list );
               terms = left;
            );
            _ => terms = ASTEOF;
         }};
         for ct in terms-list.reverse {
            let f = std-c-compile-expr(ctx, ct);
            ctx = open(f.context);
            e = std-c-chain( e, f );
         };
         e = e.set(c"expression", SAtom{c"{"} + e.get(c"expression") + SAtom{c"}"} );
         e
      );
      App{ is-cons=is-cons, left=left, right=right } => (
          if not(is-cons) && typeof(left).is-arrow {
             match left {
                Var{fname=key} => std-c-compile-call(ctx, fname, left, right);
                App{ left:Var{fname=key}, right:App{ inner-term=left, right:AType{tt=tt} } } => std-c-compile-call(ctx, fname, left, inner-term);
                Lit{fname=key} => std-c-compile-constructor(ctx, fname, left, right);
                App{ left:Lit{fname=key}, right:App{ inner-term=left, right:AType{tt=tt} } } => std-c-compile-constructor(ctx, fname, left, inner-term);
                _ => (
                   print("TODO: std-c-misc-call "); std-c-print(right); print("\n"); exit(1); mk-fragment();
                );
             }
          } else {
             let f1 = std-c-compile-expr(ctx, left);
             ctx = open(f1.context);
             let f2 = std-c-compile-expr(ctx, right);
             std-c-chain(f1, f2);
          }
      );
      _ => (
         print("TODO: std-c-compile-expr\n");
         std-c-print(t); exit(1); mk-fragment();
      );
   };
   f.type = typeof(t); f
);

