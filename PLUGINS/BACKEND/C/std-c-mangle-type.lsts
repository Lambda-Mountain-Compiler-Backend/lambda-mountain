
let std-c-mangle-type(tt: Type, blame: AST): S = (
   tt = normalize(tt).rewrite-opaque-type-alias;
   let r = std-c-mangle-type-internal(tt, blame);
   if not(non-zero(r)) then fail("Unable To Mangle \{tt}\nAt \{blame.location}\n\{blame}\n");
   r
);

let std-c-mangle-type-internal(tt: Type, blame: AST): S = (
   match tt {
      TAnd{ conjugate=conjugate } => (
         let result = SNil;
         for vector c in conjugate {
            let rt = std-c-mangle-type-internal(c, blame);
            result = if non-zero(result) && non-zero(rt) then result + SAtom{c" "} + rt
            else if non-zero(result) then result
            else rt;
         };
         result;
      );
      TAny{} => SNil;
      TGround{tag:c"Type", parameters:[inner-tt..]} => std-c-mangle-type-internal(inner-tt, blame);
      TGround{tag:c"Array", parameters:[_.. array-base..]} => (
         if array-base.is-arrow
         then std-c-mangle-type-internal(array-base, blame)
         else ( std-c-mangle-type-internal(array-base, blame) + SAtom{c"*"} );
      );
      TGround{tag:c"Arrow"} => (
         (let pre, let post) = std-c-mangle-declaration-internal(tt, blame);
         let td-id = uuid();
         assemble-header-section = assemble-header-section
                                 + SAtom{c"typedef "}
                                 + pre
                                 + SAtom{c" "}
                                 + SAtom{td-id}
                                 + SAtom{c" "}
                                 + post
                                 + SAtom{c";\n"};
         SAtom{td-id}
      );
      TGround{tag:c"C", parameters:[TGround{tag1=tag}..]} => (
         SAtom{tag1}
      );
      TGround{tag=tag, parameters=parameters} => (
         let r = mangle-identifier(tag);
         if parameters.length > 0 {
            r = r + mangle-identifier(c"<");
            for p in parameters {
               r = r + std-c-mangle-type-internal(p, blame);
            };
            r = r + mangle-identifier(c">");
         };
         r;
      );
      _ => SNil;
   }
);
