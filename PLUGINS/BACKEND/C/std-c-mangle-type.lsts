
let std-c-mangle-type(tt: Type, blame: AST): S = (
   tt = normalize(tt).rewrite-opaque-type-alias;
   let r = std-c-mangle-type-internal(tt);
   if not(non-zero(r)) then fail("Unable To Mangle \{tt}\nAt \{blame.formatted-location}");
   r
);

let std-c-mangle-type-internal(tt: Type): S = (
   match tt {
      TAnd{ conjugate=conjugate } => (
         let result = SNil;
         for vector c in conjugate {
            let rt = std-c-mangle-type-internal(c);
            result = if non-zero(result) && non-zero(rt) then result + SAtom{c" "} + rt
            else if non-zero(result) then result
            else rt;
         };
         result;
      );
      TAny{} => SNil;
      TGround{tag:c"Type", parameters:[inner-tt..]} => std-c-mangle-type-internal(inner-tt);
      TGround{tag:c"Array", parameters:[_.. array-base..]} => (
         if array-base.is-arrow
         then std-c-mangle-type-internal(array-base)
         else ( std-c-mangle-type-internal(array-base) + SAtom{c"*"} );
      );
      TGround{tag:c"Arrow"} => (
         (let pre, let post) = std-c-mangle-declaration-internal(tt);
         let td-id = uuid();
         assemble-header-section = assemble-header-section
                                 + SAtom{c"typedef "}
                                 + pre
                                 + SAtom{c" "}
                                 + SAtom{td-id}
                                 + SAtom{c" "}
                                 + post
                                 + SAtom{c";\n"};
         SAtom{td-id}
      );
      TGround{tag:c"C", parameters:[TGround{tag1=tag}..]} => (
         SAtom{tag1}
      );
      _ => SNil;
   }
);
