
continue-compile-c-typedefs-concrete := (: LEOF List<Tuple<Maybe<TypeContext>,Type,AST>>);
continue-compile-c-typedefs-count := 0_u64;
try-continue-compile-c-typedefs := Î». (: (
   (let continue continue-compile-c-typedefs-concrete)
   (set continue-compile-c-typedefs-concrete (: LEOF List<Tuple<Maybe<TypeContext>,Type,AST>>))
   (while (non-zero continue) (
      (set continue-compile-c-typedefs-count (+( continue-compile-c-typedefs-count 1_u64 )))
      (if (>( continue-compile-c-typedefs-count 100_u64 )) (
         (print 'Unable\sTo\sResolve\sCircular\sType\sDependency\sDuring\sCompilation\n_s)
         (for-each ((Tuple( _ base-type td )) in continue) (
            (print 'Typedef:\s_s)(print base-type)(print '\n_s)
         ))
         (exit 1_u64)
      ) ())
      (for-each ( (Tuple( tctx base-type body )) in continue ) (
         (if (.is-open base-type) () (
            (std-c-compile-type-typedef-concrete( tctx base-type body ))
         ))
      ))
      (set continue continue-compile-c-typedefs-concrete)
      (set continue-compile-c-typedefs-concrete (: LEOF List<Tuple<Maybe<TypeContext>,Type,AST>>))
   ))
) Nil);

is-cstruct-hard-compiled-index := (: (HashtableEq( 0_u64 0_u64 (as 0_u64 Tuple<Type,U64>[]) )) HashtableEq<Type,U64>);

