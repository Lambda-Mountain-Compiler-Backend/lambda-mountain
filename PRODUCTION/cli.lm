
config := ();

main := (
   (set type-subtypes 
     (
        (
           (() (Atom S))
           (Nil S)
        )
        ((Cons(S S)) S)
     )
   )
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config ( (global config) (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--compile (set mode Compile))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (--typecheck (set mode Typecheck))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Compile (
         (foreach-atom inputs (
            if $_ (assemble (typecheck (parse-program (tokenize (load-file $_))))) ()
         ))
      ))
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (Typecheck (foreach-atom inputs (
         if $_ (print-s (show-ascript (typecheck (parse-program (tokenize (load-file $_)))))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
);

#this is necessary to circumvent a bug with the bootstrap compiler trying to call globals as functions syntactically
global := λvalue. value;
fail := λmsg. (print-s msg) (exit 1);

type-context := ();
type-subtypes := ();
type-constructors := ();
types-have-changed := ();

tokenize-file := λpath. (
   tokenize (load-file path)
);

typecheck := λprogram. (tail(
   (local p)
   (set p program)
   (while p (
      (infer-type-expr( (tail p) ))
      (set p (head p))
   ))
   (set types-have-changed True)
   (while types-have-changed (
      (set types-have-changed ())
      (infer-prog program)
   ))
   program
));

lookup-type := λterm. (tail(
   (local tctx)
   (set tctx type-context)
   (local found)
   (local ttt)
   (while tctx (
      (set ttt (head tctx))
      (if (is( (head ttt) term )) (
         (set found (tail ttt))
         (set tctx ())
      ) (
         (set tctx (tail tctx))
      ))
   ))
   found
));

ascript := λt tt. (
   if tt (
      (set type-context ((t tt) type-context))
      (set types-have-changed True)
   ) ()
);

show-ascript := λp. (tail(
   (local term)
   (set term (match p (
      ()
      ( () () )
      ( Nil p )
      ( (Variable _) p )
      ( (Literal _) p )
      ( (App( f x )) (
         (App( (show-ascript f) (show-ascript x) ))
      ))
      ( (Lambda( lhs rhs )) (
         (App( (show-ascript lhs) (show-ascript rhs) ))
      ))
      ( (prog (GExpr( g ))) (
         ( (show-ascript prog) (GExpr( show-ascript g )) )
      ))
      ( (prog (Global( n v ))) (
         ( (show-ascript prog) (Global( n (show-ascript v) )) )
      ))
      ( (prog (Type( tn td ))) (
         ( (show-ascript prog) (Type( tn td )) )
      ))
      ( unknown (
         fail (UnknownTerm unknown)
      ))
   )))
   (local type)
   (set type (lookup-type p))
   (if type (
      (if (eq( type ? )) (
         term
      ) ( 
         (:( term type ))
      ))
   ) (
      term
   ))
));

global-context := ();

infer-prog := λp. (
   (while p (
      (infer-expr( (global global-context) (tail p) ))
      (set p (head p))
   ))
);

infer-ctx := λctx e. (match e (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (ctx (v (typeof-ascript tt)))
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      ( (infer-ctx( ctx ps )) (v (typeof-ascript tt)))
   ))
   ( (Variable v) (
      (ctx (v S))
   ))
   ( (App( ps (Variable v) )) (
      ( (infer-ctx( ctx ps )) (v S))
   ))
   ( Nil (
      ctx
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typeof-gvar := λv. (tail(
   (local gctx)
   (set gctx global-context)
   (local tt)
   (while gctx (
      (match (tail gctx) (
         ()
         ( (Global( gn gt )) (
            (if (eq( v gn )) (
               (if tt (
                  (set tt (And(tt gt)) )
               ) (
                  (set tt gt)
               ))
            ) ())
            (set gctx (head gctx))
         ))
      ))
   ))
   tt
));

typeof-var := λctx v. (match ctx (
   ()
   ( () (typeof-gvar v) )
   ( (cs (cv ct)) (
      if (eq( v cv )) (
         ct
      ) (
         (typeof-var( cs v ))
      )
   ))
));

typeof-ascript := λtt. (match tt (
   ()
   ( (Literal tname) (
      tname
   ))
   ( (Variable tname) (
      tname
   ))
));

typeof-lhs := λlhs. (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (typeof-ascript tt)
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      (Cons( (typeof-lhs ps) (typeof-ascript tt) ))
   ))
   ( (Variable v) (
      S
   ))
   ( (App( ps (Variable v) )) (
      (Cons( (typeof-lhs ps) S ))
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

unify-sub := λctx v. (match ctx (
   ()
   ( Accept v )
   ( (Bind( s1 s2 )) (
      if (eq( v s1 )) s2 v
   ))
   ( (ctxl ctxr) (tail(
      (local lv)
      (set lv (unify-sub( ctxl v )))
      (local rv)
      (set rv (unify-sub( ctxr v )))
      (if (is( lv v )) (
         (if (is( rv v )) () (set v rv))
      ) (set v lv))
      v
   )))
));

unify-ctx := λctx v. (match v (
   ()
   ( (vl vr) (
      ( (unify-ctx( ctx vl )) (unify-ctx( ctx vr )) )
   ))
   ( _ (
      (unify-sub( ctx v ))
   ))
));

unify-implies := λlt rt. (if (eq(lt rt)) True (tail(
   (local accept)
   (local subtypes)
   (local st)
   (set subtypes type-subtypes)
   (while subtypes (
      (set st (tail subtypes))
      (if (eq( (head st) lt )) (
         (if (eq( (tail st) rt )) (
            (set accept True)
         ) ())
      ) ())
      (set subtypes (head subtypes))
   ))
   accept
)));

unify-args := λlt rt. (match (lt rt) (
   ()
   ( ((lt1 rt1) (lt2 rt2)) (
      (match ( (unify-args(lt1 lt2)) (unify-args(rt1 rt2)) ) (
         ()
         ( (() _) () )
         ( (_ ()) () )
         ( (lctx rctx) (lctx rctx) )
      ))
   ))
   ( (a1 a2) (
      (if (unify-implies( a2 a1 )) ( # argument type must imply parameter type
         Accept
      ) (
         (if (is-variable a1) (
            (if (is-variable a2) (
               Accept
            ) (
               (Bind( a1 a2 ))
            ))
         ) (
            (if (is-variable a2) (
               (Bind( a2 a1 ))
            ) (
               ()
            ))
         ))
      ))
   ))
   (_ (tail(
      (fail (UnknownUnify lt rt))
      ?
   )))
));

apply-plural := λmany pt. (match many(
   ()
   ( (And( t1 t2 )) (tail(
      (local r)
      (set r (apply-plural( t1 pt )))
      (if r r (apply-plural( t2 pt )))
   )))
   ( (->(lt rt)) (
      (unify-ctx( (unify-args(lt pt)) rt ))
   ))
));

safe-apply-plural := λterm many pt. (tail(
   (local r)
   (set r (apply-plural( many pt )))
   (if r r (
      fail (TypeError( InvalidArgument many pt ))
   ))
));

infer-type-compound := λcompound. (match compound (
   ()
   ((Literal tt) tt)
   ((App( lt rt )) (Cons( (infer-type-compound lt) (infer-type-compound rt) )))
   (u (fail (UnknownTypeCompound u)))
));

infer-type-constructor := λname body. (match body (
   ()
   ( (Literal tag) (
      (set type-constructors ( (global type-constructors) (tag tag) ))
      (set type-subtypes ( (global type-subtypes) (tag (infer-type-compound name)) ))
   ))
   ( (App( (Literal tag) args )) (
      (local ctype)
      (set ctype (infer-type-compound args))
      (set type-constructors ( (global type-constructors) (tag (->(ctype (tag ctype)))) ))
      (set type-subtypes ( (global type-subtypes) ((tag ctype) (infer-type-compound name)) ))
   ))
));

infer-type-definition := λname def. (match def (
   ()
   ( (App( (App( tds (Literal |) )) body )) (
      (infer-type-definition( name tds ))
      (infer-type-constructor( name body ))
   ))
   ( body (
      (infer-type-constructor( name body ))
   ))
));

infer-constructor-type := λtag. (tail(
   (local ctype)
   (local constructors)
   (set constructors type-constructors)
   (while constructors (
      (if (eq( tag (head(tail(constructors))) )) (
         (if ctype (
            (set ctype (And( ctype (tail(tail(constructors))) )))
         ) (
            (set ctype (tail(tail(constructors))))
         ))
      ) ())
      (set constructors (head constructors))
   ))
   ctype
));

infer-type-expr := λe. (match e (
   ()
   ( (Type( l ds )) (
      (infer-type-definition( l ds ))
      (ascript( e ? ))
   ))
   (_ ())
));

infer-expr := λctx e. (
   (if (lookup-type e) () (
      match e (
         ()
         ( () () )
         ( (GExpr ge) (
            (infer-expr( ctx ge ))
         ))
         ( (Global( gln gle )) (
            (infer-expr( ctx gle ))
            (match (lookup-type gle) (
               ()
               ( () () )
               ( glt (
                  (set global-context ( (global global-context) (Global( gln glt )) ))
                  (ascript( e ? ))
               ))
            ))
         ))
         ( (Type( l ds )) ())
         ( Nil (
            (ascript( e Nil ))
         ))
         ( (Literal lit) (
            (local ctype)
            (set ctype (infer-constructor-type lit))
            (if ctype (
               (ascript( e (And( ctype Atom )) ))
            ) (
               (ascript( e Atom ))
            ))
         ))
         ( (App( l r )) (
            (infer-expr( ctx l ))
            (infer-expr( ctx r ))
            (match ( (lookup-type l) (lookup-type r) ) (
               ()
               ( (() _) () )
               ( (_ ()) () )
               ( ( (->(lt rt)) pt ) (
                  (ascript( e (safe-apply-plural( e (->(lt rt)) pt )) ))
               ))
               ( ( (And(t1 t2)) pt ) (
                  (ascript( e (safe-apply-plural( e (And(t1 t2)) pt )) ))
               ))
               ( (lt rt) (
                  (ascript( e (Cons(lt rt)) ))
               ))
            ))
         ))
         ( (Lambda( lhs rhs )) (
            (set ctx (infer-ctx( ctx lhs )))
            (infer-expr( ctx rhs ))
            (match (lookup-type rhs) (
               ()
               ( () () )
               ( rt (
                  (ascript( e (->( (typeof-lhs lhs) rt)) ))
               ))
            ))
         ))
         ( (Variable v) (
            (match (typeof-var( ctx v )) (
               ()
               ( () () )
               ( tt (ascript( e tt )) )
            ))
         ))
         ( u (fail (UnknownTerm u)) )
      )
   ))
);

parse-lambda := λtoks. (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal \,) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal \,) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (expect( \, toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

unexpect := λt. fail (UnexpectedToken t);
expect := λt ts. ();
#expect := λt ts. if (eq( t (head ts) )) () (fail (ExpectedToken t));

parse-one-expression := λtoks. (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Lit \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks. (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set program ( program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set program ( program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set program (program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
   program
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

reverse-list := λl. (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv. (tail(
   (local is_v)
   (local passed_char)
   (local c)
   (foreach-char v (
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_v True) (set passed_char True) ))
         ('_ ( (set is_v True) (set passed_char True) ))
         ('a ( (set is_v True) (set passed_char True) ))
         ('b ( (set is_v True) (set passed_char True) ))
         ('c ( (set is_v True) (set passed_char True) ))
         ('d ( (set is_v True) (set passed_char True) ))
         ('e ( (set is_v True) (set passed_char True) ))
         ('f ( (set is_v True) (set passed_char True) ))
         ('g ( (set is_v True) (set passed_char True) ))
         ('h ( (set is_v True) (set passed_char True) ))
         ('i ( (set is_v True) (set passed_char True) ))
         ('j ( (set is_v True) (set passed_char True) ))
         ('k ( (set is_v True) (set passed_char True) ))
         ('l ( (set is_v True) (set passed_char True) ))
         ('m ( (set is_v True) (set passed_char True) ))
         ('n ( (set is_v True) (set passed_char True) ))
         ('o ( (set is_v True) (set passed_char True) ))
         ('p ( (set is_v True) (set passed_char True) ))
         ('q ( (set is_v True) (set passed_char True) ))
         ('r ( (set is_v True) (set passed_char True) ))
         ('s ( (set is_v True) (set passed_char True) ))
         ('t ( (set is_v True) (set passed_char True) ))
         ('u ( (set is_v True) (set passed_char True) ))
         ('v ( (set is_v True) (set passed_char True) ))
         ('w ( (set is_v True) (set passed_char True) ))
         ('x ( (set is_v True) (set passed_char True) ))
         ('y ( (set is_v True) (set passed_char True) ))
         ('z ( (set is_v True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_v
));

assemble := λprogram. (
   (local target)
   (set target 'tmp\,s)
   (while config (
      (match (tail config) (
         ()
         ((Target t) (set target t))
      ))
      (set config (head config))
   ))

   (local main_e)
   (local main_pd)
   (set main_pd ( (before-main()) () ))

   (local output_pd)
   (set output_pd ( (program-header()) (data-header()) ))

   (local global_ctx)
   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set main_e body)
         (set program pc)
      ))
      ( (pc (GExpr e)) (
         (set main_pd (compile-append( main_pd global_ctx e )))
         (set program pc)
      ))
      ( (pc (Global (fname body))) (
         (fail (TODO CompileGlobal fname))
         (set program pc)
      ))
   )))

   (if main_e (
      (set main_pd (compile-append( main_pd global_ctx main_e )))
   ) ())
   (set main_pd ( ((head main_pd) (exit-cleanup())) (tail main_pd)) )
   (set output_pd ( ((head output_pd) (head main_pd) (stdlib-functions())) ((tail output_pd) (tail main_pd)) ))

   (write-file (target (clone-rope output_pd)))
);

get-frame := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe. (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

get-maybe-function := λctx n. (
   (fail (TODO GetMaybeFunction n))
);

compile-expr := λctx e offset used. (tail(
   (local x)
   (local prog)
   (local tail_safe)
   (local return)
   (set return (match e (
      ()
      ( (Variable '$_) (tail(
         ()
         (Expr( () () () () () ctx offset ))
      )))
      ( (Variable 'argv) (tail(
         (set prog (prog ( \t 'mov \s '$argv, \s '%r8 \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%r8 \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%r8 \] , '%r13 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App ((Variable fname) arg)) (tail(
         ()
         (if (is-builtin fname) (tail(
            ()
            (if (eq(fname 'tail)) (tail(
               (set x (compile-expr(ctx arg offset Tail)))
               (set prog (get-prog x))
               (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
            )) (tail(
               (set x (compile-expr(ctx arg offset Used)))
               (set prog (get-prog x))
               (set prog (prog (\t 'call \s (label-case fname) \n)))
               (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
            )))
         )) (tail(
            ()
            (match (get-maybe-function(ctx fname)) (
               ()
#               ( (Global (f body)) (tail(
#                  ()
#                  (set x (compile-expr(ctx arg offset Used)))
#                  (set prog (get-prog x))
#                  (set prog (prog (\t 'call \s (label-case fname) \n)))
#                  (Expr( (get-frame x) prog (get-unframe x) (get-text x) (get-data x) (get-pc x) (get-offset x) ))
#               )))
#               ( _ (tail(
#                  ()
#                  (yield-cons(ctx (Variable fname) arg offset Used))
#               )))
            ))
         )))
      )))
      ( (Literal l) (tail(
         ()
         (yield-atom (ctx l offset))
      )))
      ( Nil (tail(
         (set prog (prog ( \t 'mov \s '$0 , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r13 \n )))
         (set tail_safe True)
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App (l r)) (tail(
         (set tail_safe True)
         (yield-cons(ctx l r offset used))
      )))
      ( u (fail (UnrecognizedExpression u)) )
   )))
   (if tail_safe return (tail(
      ()
      (if (eq(used Tail)) (tail(
         (set prog (get-prog return))
         (set prog (prog (\t 'call \s 'tail \n)))
         (Expr( (get-frame return) prog (get-unframe return) (get-text return) (get-data return) (get-pc return) (get-offset return) ))
      )) (
         return
      ))
   )))
));

compile-append := λoutput_pd gctx e. (tail(
   (set e (compile-expr( gctx e () Unused )))
   ( ((head output_pd) (get-frame e) (get-prog e) (get-unframe e) (get-text e))
     ((tail output_pd) (get-data e)) )
));

data-header := λ.(
  '\,data                                 \n
  'load_file_bsz:                         \n
  \t '\,quad \s '1024                     \n
  'load_file_buf:                         \n
  \t '\,zero \s '1024                     \n
  'argv:                                  \n
  \t '\,zero \s '16                       \n
  's_counter:                             \n
  \t '\,zero \s '8                        \n
  's_section:                             \n
  \t '\,zero \s '536870912                \n
  'a_counter:                             \n
  \t '\,zero \s '8                        \n
  'a_section:                             \n
  \t '\,zero \s '536870912                \n
  'nil_literal:                           \n
  \t '\,ascii \s " \[ \] "                \n
  \t '\,zero \s 1                         \n
  'newline:                               \n
  \t '\,ascii \s " \\n "                  \n
  'left_paren:                            \n
  \t '\,ascii \s " \[ "                   \n
  'right_paren:                           \n
  \t '\,ascii \s " \] "                   \n
  'space:                                 \n
  \t '\,ascii \s " \s "                   \n
  'true:                                  \n
  \t '\,ascii \s "True"                   \n
  \t '\,zero \s '1                        \n
  'digit:                                 \n
  \t '\,zero \s '2                        \n
  'dump_i:                                \n
  \t '\,ascii \s '"0000000000000000"      \n
  \t '\,zero \s '1                        \n
  'err_fopen:                             \n
  \t '\,ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t '\,zero \s '1                        \n
);

program-header := λ.(
   '\,global \s '_start                   \n
   '\,text                                \n
   '_start:                               \n
   \t 'jmp \s 'main                       \n
);

exit-cleanup := λ. (system-call( '$60 '$0 '$0 '$0 ));

system-call := λrax rdi rsi rdx. (
   \t 'mov \s rax , \s '%rax           \n
   \t 'mov \s rdi , \s '%rdi           \n
   \t 'mov \s rsi , \s '%rsi           \n
   \t 'mov \s rdx , \s '%rdx           \n
   \t 'syscall                         \n
);

before-main := λ.(
   # before_main_argv:
   #    argv = ()
   #    let t = argv
   #    for a in argv:
   #       t.tail = (a ())
   #       t = t.tail

   'main:                              \n
   \t 'pop \s '%rax                    \n # put argc in %rax
   \t 'mov \s '$argv, \s '%r9          \n
   \t 'movq \s '$0, \s '0 \[ '%r9 \]   \n
   \t 'movq \s '$0, \s '8 \[ '%r9 \]   \n

   'before_main_argv:                  \n
   \t 'cmp \s '$0, \s '%rax            \n
   \t 'je \s 'before_main_end          \n

   \t 'pop \s '%r12                    \n #this = argv[i]
   \t 'mov \s '$0, \s '%r13            \n
   (close())                              #r8 is argv[i]

   \t 'mov \s '%r8, \s '0 \[ '%r9 \]   \n #set t.head = argv[i]
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   (close())
   \t 'mov \s '%r8, \s '8 \[ '%r9 \]   \n #set t.tail = ()
   \t 'mov \s '%r8, \s '%r9            \n #set t = t.tail

   \t 'dec \s '%rax                    \n #dec argc
   \t 'jmp \s 'before_main_argv        \n

   'before_main_end:                   \n
);

allocate-heap-16 := λ. (
   \t 'mov \s '$s_section, \s '%r8           \n # %r8 now points to root s
   \t 'mov \s '$s_counter, \s '%r11          \n # %r11 now points to s counter
   \t 'mov \s '0 \[ '%r11 \] , \s '%r10      \n # %r10 now hold value of cons counter
   \t 'add \s '%r10, \s '%r8                 \n # %r8 now points to top free cons
   \t 'add \s '$16, \s '%r10                 \n # increment s counter
   \t 'mov \s '%r10, \s '0 \[ %r11 \]        \n # overwrite new s counter
);

close := λe. (
   e
   (allocate-heap-16 ())
   (\t 'mov \s '%r12, \s '0 \[ '%r8 \] \n)
   (\t 'mov \s '%r13, \s '8 \[ '%r8 \] \n)
);

is-builtin := λf. (match f (
   ()
   ('eq True)
   ('not True)
   ('head True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('add True)
   ('mul True)
   ('div True)
   ('mod True)
   ('inv True)
   ('is-neg True)
   ('digit True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

label-case := λk. (tail(
   (local nk)
   (foreach-char k (match $_ (
      ()
      ('- (set nk (nk '_)))
      ('$ (set nk (nk '_I_)))
      (c (set nk (nk (clone-rope c))))
   )))
   (clone-rope nk)
));

stdlib-functions := λ. (
   'print_s:                           \n
   # if .head is zero, then this is Nil
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s 'print_s_nil              \n

   # if only .tail is zero, then this is an Atom
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'print_s_atom             \n

   # if .head and .tail are non-zero, then this is a Cons
   (system-call( '$1 '$1 '$left_paren '$1 ))
   (push-this())
   \t 'call \s 'head                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$space '$1 ))
   (push-this())
   \t 'call \s 'tail                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$right_paren '$1 ))
   \t 'ret                             \n

   'print_s_nil:                       \n
   # nil is two bytes "()" located in the data section at $nil_literal
   (system-call( '$1 '$1 '$nil_literal '$2 ))
   \t 'ret                             \n

   'print_s_atom:                      \n
   \t 'call \s 'strlen                 \n # %r8 is string length of this atom
   (system-call( '$1 '$1 '%r12 '%r8 )) \n
   \t 'ret                             \n

   'head:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'head_is_nil                 \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
   \t 'ret                                \n
   'head_is_nil:                          \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'ret                                \n

   'tail:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'head_is_nil                 \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
   \t 'ret                                \n
   'tail_is_nil:                          \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'ret                                \n

   'strlen:                               \n
   \t 'xor \s '%r8, \s '%r8               \n
   \t 'mov \s '%r12, \s '%rax             \n
   'strlen_loop:                          \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]     \n
   \t 'jz \s 'strlen_exit                 \n
   \t 'inc \s '%r8                        \n
   \t 'inc \s '%rax                       \n
   \t 'jmp \s 'strlen_loop                \n
   'strlen_exit:                          \n
   \t 'ret                                \n
);

push-this := λ.(
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
);

pop-this := λ.(
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
);

yield-cons := λctx l r offset used. (tail(
   (local e1)
   (local e2)
   (local prog)
   (local rused)
   (match used (
      ()
      ( Used (tail(
         (set e1 (compile-expr( ctx l offset Used )))
         (set offset (get-offset e1))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
         (set offset (get-offset e2))
         (set prog (prog (get-prog e1)))
         (set prog (prog (push-this())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r8, \s '%r9 \n)))
         (set prog (prog (pop-this())))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r9, \s '%r12 \n)))
         (set prog (prog (\t 'mov \s '%r8, \s '%r13 \n)))
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( _ (tail(
         (set rused ( if (eq(used Tail)) Used Unused ))
         (set e1 (compile-expr( ctx l offset Unused )))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) rused )))
         (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
   ))
));

yield-atom := λctx a offset. (tail(
   (local id)
   (set id (uuid()))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
      )
      ()
      ()
      (id ': \n \t '\,ascii \s " (escape-sequences a) " \n \t '\,zero \s 1 \n)
      ctx
      offset
   ))
));

$uuid := ();
uuid := λ. (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

escape-sequences := λt. match t (
   ()
   ( () () )
   ( \\ \\\\ )
   ( \\: \: )
   ( \\o \o )
   ( \\n (\\ 'n))
   ( \\t \t )
   ( \\s \s )
   ( \\l \l )
   ( \\[ \[ )
   ( \\] \] )
   ( (l r) ( (escape-sequences l) (escape-sequences r) ) )
   ( s (tail(
      (local c)
      (local cs)
      (local is_escape)
      (foreach-char s (
         (set c $_)
         (match c (
            ()
            ( " (
               (set cs (cs \\ "))
               (set is_escape ())
            ))
            (\\ (
               (if is_escape (
                 (set cs ( cs \\\\ ))
                 (set is_escape ())
               ) (set is_escape True))
            ))
            (_ (
               (if is_escape (
                  (match c (
                     ()
                     ( , (set cs (cs \,)))
                     ( _ (print-s( InvalidEscapeCharacter (c s) )))
                  ))
               ) (set cs (cs (clone-rope c))))
               (set is_escape ())
            ))
         ))
      ))
      (clone-rope cs)
   )))
);
