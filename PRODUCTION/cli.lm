
# Dependencies

import STDLIB/default-cons-allocator.lm;
import STDLIB/default-atom-allocator.lm;

# Static Globals

config-nostd                             := ();
config-strict                            := ();
cli-config                               := ();
parse-parsed-program                     := ();
parse-macros                             := ();
parse-suffix                             := ();
typecheck-subtypes                       := ();
typecheck-accept-as                      := ();
typecheck-context                        := ();
typecheck-constructors                   := ();
typecheck-types-have-changed             := ();
typecheck-global-context                 := ();
assemble-text-section                    := ();
assemble-data-section                    := ();
compile-argv-hook                        := ();

# Static Global Initializers

typecheck-init := λ. (
   (set typecheck-subtypes 
     (
        (
           (() (Atom S))
           (Nil S)
        )
        ((Cons(S S)) S)
     )
   )
   (local mode)
);

# Cli Entry Point

main := (
   (local inputs)
   (local args)

   (typecheck-init())

   (local mode)
   (set mode Compile)

   (set args (tail argv))

   (while args (match args (
      ()
      ( ('-o (tgt remainder)) (
         (set cli-config ( cli-config (Target tgt)))
         (set args remainder)
      ))
      ( ('--compile remainder) (
         (set mode Compile)
         (set args remainder)
      ))
      ( ('--strict remainder) (
         (set config-strict True)
         (set args remainder)
      ))
      ( ('--parse remainder) (
         (set mode Parse)
         (set args remainder)
      ))
      ( ('--nostd remainder) (
         (set config-strict True)
         (set config-nostd True)
         (set args remainder)
      ))
      ( ('--parse-expression remainder) (
         (set mode ParseExpression)
         (set args remainder)
      ))
      ( ('--tokenize remainder) (
         (set mode Tokenize)
         (set args remainder)
      ))
      ( ('--typecheck remainder) (
         (set mode Typecheck)
         (set args remainder)
      ))
      ( (fp remainder) (
         (set inputs (fp inputs))
         (set args remainder)
      ))
      ( u (
         fail (UnexpectionCommand u)
      ))
   )))

   (while inputs (match mode (
      ()
      (Compile (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Parse (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Typecheck (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (ParseExpression (
         (print-s (parse-expression (tokenize-file (head inputs))))
         (set inputs (tail inputs))
      ))
      (Tokenize (
         (print-s (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (u (
         (fail (UnknownMode u))
      ))
   )))

   (set parse-parsed-program (parse-apply-macros parse-parsed-program))
   (if config-strict (typecheck parse-parsed-program) ())

   (match mode (
      ()
      (Compile (assemble parse-parsed-program))
      (Parse (print-s parse-parsed-program))
      (Typecheck (print-s (typecheck-show-ascript (typecheck parse-parsed-program))))
   ))
);

# Tokenizer 

tokenize-file := λpath . (match path (
   ()
   (() ())
   ((_ _) ())
   (fp (tokenize (load-file fp)))
));


tokenize := λtext . (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)

   (while text (
      (set char (head-string text))
      (set text (tail-string text))
   (match char (      
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

# Parser

parse-program := λtoks . (tail(
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('macro remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-one-expression remainder))
            (set parse-macros (parse-macros (Macro( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('fragment remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (parse-expect( := remainder ))
            (set remainder (tail remainder))
            (set pme2 (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Fragment( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('accept ('as remainder)) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set typecheck-accept-as ( typecheck-accept-as (
               (typecheck-infer-type-compound (head pme))
               (typecheck-infer-type-compound (head pme2))
            )))
            (set toks (tail pme2))
         ))
         (('atom ('suffix (atype (suffix remainder)))) (
            (set parse-suffix (parse-suffix (atype suffix)))
            (set toks remainder)
         ))
         (('size remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-one-expression remainder))
            (set parse-parsed-program ( parse-parsed-program (Size( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('import (relative-path remainder)) (
            (parse-program (tokenize-file relative-path))
            (set toks remainder)
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program (parse-parsed-program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
));

merge-list := λl r . (tail( if l (
   (while r (
      (set l (l (tail r)))      
      (set r (head r))
   ))
   l
) r ));

substitute-macro-body := λkvs e . (match e (
   ()
   ((Variable n) (tail(
      (while kvs (match kvs (
         ()
         ( Accept (set kvs ()) )
         ( (ks Accept) (set kvs ks) )
         ( (ks ()) (set kvs ks) )
         ( (ks (KV(k v))) (
            (if (eq(n k)) (
               (set e v)
               (set kvs ())
            ) (
               (set kvs ks)
            ))
         ))
         ( u (fail (UnrecognizedKVMacro kvs)))
      )))
      e
   )))
   ( () () )
   ( (vl vr) (
      (substitute-macro-body( kvs vl ))
      (substitute-macro-body( kvs vr ))
   ))
   ( v v )
));

try-destructure-macro := λlhs e . (match (lhs e) (
   ()
   ( ( Nil Nil ) Accept )
   ( ( (App(pl pr)) (App(el er)) ) (tail(
      (local ll)
      (set ll (try-destructure-macro(pl el)))
      (local rl)
      (set rl (try-destructure-macro(pr er)))
      (if ll (
         (if rl (
            (merge-list( ll rl ))
         ) ())
      ) ())
   )))
   ( ((Literal pl) (Variable el)) (
      (if (eq( pl el )) Accept ())
   ))
   ( ((Literal pl) (Literal el)) (
      (if (eq( pl el )) Accept ())
   ))
   ( ( (App( (Literal :Literal:) (Variable pv) )) (Literal el)) (
      (Accept (KV( pv e )))
   ))
   ( ( (App( (Literal :Variable:) (Variable pv) )) (Variable el)) (
      (Accept (KV( pv e )))
   ))
   ( ((Variable pv) e) (
      (Accept (KV( pv e )))
   ))
));

parse-macro-yield-uuids := λids program . (match program (
   ()
   ( (App( (Variable 'uuid) (Variable x) )) (
      (ids ( x (Variable (uuid())) ))
   ))
   ( (l r) (
      (parse-macro-yield-uuids( (parse-macro-yield-uuids( ids l )) r ))
   ))
   ( u ids )
));

parse-macro-substitute-uuids := λids program . (match program (
   ()
   ( (App( (Variable 'uuid) (Variable x) )) (tail(
      (local id)
      (set id program)
      (while ids (tail(
         (local bind)
         (set bind (tail ids))
         (set ids (head ids))
         (if (eq( (head bind) x )) (
            (set id (tail bind))
         ) ())
      )))
      id
   )))
   ( (l r) (
      (parse-macro-substitute-uuids( ids l ))
      (parse-macro-substitute-uuids( ids r ))
   ))
   ( a a )
));

is-suffix := λs suff . (tail(
   (local match)
   (while s (
      (if (eq( s suff )) (set match True) ())
      (set s (tail-string s))
   ))
   match
));

remove-suffix := λs suff . (tail(
   (local prefix)
   (while s (
      (if (eq( s suff )) (
         (set s ())
      ) (
         (set prefix (prefix (clone-rope (head-string s))))
         (set s (tail-string s))
      ))
   ))
   (clone-rope prefix)
));

parse-apply-macros := λprogram . (match program (
   ()
   ( (Literal l) (tail(
      (local suffixes)
      (set suffixes parse-suffix)
      (while suffixes (tail(
         (local sfx)
         (set sfx (tail (tail suffixes)) )
         (if (is-suffix( l sfx )) (
            (set program (
               (App(
                  (App(
                     (Literal ':) 
                     (Literal (remove-suffix( l sfx )))
                  ))
                  (App(
                     (Literal Constant)
                     (Literal (head (tail suffixes)))
                  ))
               ))
            ))
         ) ())
         (set suffixes (head suffixes))
      )))
      program
   )))
   ( _ (tail(
      (local macros)
      (set macros parse-macros)
      (while macros (match macros (
         ()
         ( (ms (Macro( lhs rhs ))) (tail(
            (local new)
            (set new (try-destructure-macro( lhs program )))
            (if new (tail(
               (set program (substitute-macro-body( new rhs )))
               (set program (parse-macro-substitute-uuids (
                  (parse-macro-yield-uuids( () program ))
                  program
               )))
               (set program (parse-apply-macros program))
            )) ())
            (set macros ms)
         )))
         ( u (fail (UnrecognizedMacro u)))
      )))
      (match program (
         ()
         ( (l r) (
            (parse-apply-macros l)
            (parse-apply-macros r)
         ))
         ( () () )
         (u u)
      ))
   )))
));

parse-lambda := λtoks . (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal .) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal .) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (parse-expect( . toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

parse-unexpect := λt . fail (UnexpectedToken t);
parse-expect := λt ts . (if (eq( t (head ts) )) () (fail (ExpectedToken t)));

parse-one-expression := λtoks . (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (parse-unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks . (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks . (parse-many-expressions toks);

# Typechecker

typecheck := λprogram . (tail(
   (local p)
   (set p program)
   (while p (
      (typecheck-infer-type-expr( (tail p) ))
      (set p (head p))
   ))
   (set typecheck-types-have-changed True)
   (while typecheck-types-have-changed (
      (set typecheck-types-have-changed ())
      (typecheck-infer-prog program)
   ))
   (typecheck-assert-complete program)
   program
));

typecheck-assert-complete := λp . (if p (
   (typecheck-assert-complete( head p ))
   (typecheck-assert-expr( tail p ))
) ());

typecheck-assert-one := λe . (
   (if (typecheck-lookup-type e) () (
      (print-s (typecheck-show-ascript parse-parsed-program))(print-s \n)
      (fail (UnableToInferTypeOfExpression (typecheck-show-ascript e)))
   ))
);

typecheck-assert-expr := λe . (tail(
   (match e (
      ()
      ( () () )
      ( (GExpr ge) (
         (typecheck-assert-expr( ge ))
      ))
      ( (Global( gln gle )) (
         (typecheck-assert-expr( gle ))
      ))
      ( (Type( l ds )) ())
      ( (Fragment( fln fle )) ())
      ( Nil (
         (typecheck-assert-one( e ))
      ))
      ( (App( (Variable 'gensym-label) _ )) (
      ))
      ( (App( (Variable 'label) (Variable l) )) (
      ))
      ( (App( (App( (Literal :) (Literal _) )) tt )) (
         (typecheck-assert-one( e ))
      ))
      ( (App( (App( (Variable 'as) te )) tt )) (
         (typecheck-assert-expr( te ))
         (typecheck-assert-one( e ))
      ))
      ( (App( (App( (Literal :) te )) tt )) (
         (typecheck-assert-expr( te ))
         (typecheck-assert-one( e ))
      ))
      ( (Literal lit) (
         (typecheck-assert-one( e ))
      ))
      ( (App( l r )) (
         (typecheck-assert-expr( r ))
         (typecheck-assert-expr( l ))
         (typecheck-assert-one( e ))
      ))
      ( (Lambda( lhs rhs )) (
         (typecheck-assert-expr( rhs ))
         (typecheck-assert-one( e ))
      ))
      ( (Variable v) (
         (typecheck-assert-one( e ))
      ))
      ( (Size( typf sizf )) (
      ))
      ( u (fail (UnknownAssertTyped u)) )
   ))
));

typecheck-lookup-type := λterm . (tail(
   (local tctx)
   (set tctx typecheck-context)
   (local found)
   (local ttt)
   (while tctx (
      (set ttt (head tctx))
      (if (is( (head ttt) term )) (
         (set found (tail ttt))
         (set tctx ())
      ) (
         (set tctx (tail tctx))
      ))
   ))
   found
));

typecheck-deep-eq := λt1 t2 . if (is( t1 t2 )) True (match (t1 t2) (
   ()
   ( (() ()) True )
   ( (Fragment _) True )
   ( (_ Fragment) True )
   ( ( (And(l1 l2)) (And(r1 r2)) ) True )
   ( ( (And(l1 l2)) r ) (
      if (typecheck-deep-eq(l1 r)) True
         (typecheck-deep-eq(l2 r))
   ))
   ( ( l (And(r1 r2)) ) (
      if (typecheck-deep-eq(l r1)) True
         (typecheck-deep-eq(l r2))
   ))
   ( ((l1 l2) (r1 r2)) (
      if (typecheck-deep-eq(l1 r1))
         (typecheck-deep-eq(l2 r2))
         ()
   ))
   ( (l r) (eq( l r )) )
));

typecheck-ascript := λt tt . (
   if tt (tail(
      (local lt)
      (set lt (typecheck-lookup-type t))
      (if lt (
         (if (typecheck-deep-eq( lt tt )) () (
            fail (TypeAscriptionInequality lt tt)
         ))
      ) (
         (set typecheck-context ((t tt) typecheck-context))
         (set typecheck-types-have-changed True)
      ))
   )) ()
);

typecheck-show-ascript := λp . (tail(
   (local term)
   (set term (match p (
      ()
      ( () () )
      ( Nil p )
      ( (Variable _) p )
      ( (Literal _) p )
      ( (App( f x )) (
         (App( (typecheck-show-ascript f) (typecheck-show-ascript x) ))
      ))
      ( (Lambda( lhs rhs )) (
         (Lambda( (typecheck-show-ascript lhs) (typecheck-show-ascript rhs) ))
      ))
      ( (prog (GExpr( g ))) (
         ( (typecheck-show-ascript prog) (GExpr( typecheck-show-ascript g )) )
      ))
      ( (prog (Global( n v ))) (
         ( (typecheck-show-ascript prog) (Global( n (typecheck-show-ascript v) )) )
      ))
      ( (prog (Type( tn td ))) (
         ((typecheck-show-ascript prog) (Type( tn td )))
      ))
      ( (prog (Fragment( (Variable fragf) body ))) (
         (typecheck-show-ascript prog)
      ))
      ( (prog (Fragment( typf body ))) (
         (typecheck-show-ascript prog)
      ))
      ( (prog (Size( typf sizf ))) (
         (typecheck-show-ascript prog)
      ))
      ( unknown (
         fail (UnknownTerm unknown)
      ))
   )))

   (local type)
   (set type (typecheck-lookup-type p))
   (if type (
      (if (eq( type '? )) (
         term
      ) ( 
         (:( term type ))
      ))
   ) (
      term
   ))
));

typecheck-infer-prog := λp . (
   (while p (
      (typecheck-infer-expr( () (tail p) ))
      (set p (head p))
   ))
);

typecheck-infer-ctx := λctx e . (match e (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (ctx (v (typecheck-infer-type-compound tt)))
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      ( (typecheck-infer-ctx( ctx ps )) (v (typecheck-infer-type-compound tt)))
   ))
   ( (Variable v) (
      (ctx (v S))
   ))
   ( (App( ps (Variable v) )) (
      ( (typecheck-infer-ctx( ctx ps )) (v S))
   ))
   ( Nil (
      ctx
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typecheck-typeof-gvar := λv . (tail(
   (local gctx)
   (set gctx typecheck-global-context)
   (local tt)
   (while gctx (
      (match (tail gctx) (
         ()
         ( (Global( gn gt )) (
            (if (eq( v gn )) (
               (if tt (
                  (set tt (And(tt gt)) )
               ) (
                  (set tt gt)
               ))
            ) ())
            (set gctx (head gctx))
         ))
      ))
   ))
   tt
));

typecheck-typeof-var := λctx v . if (eq( 'asm! v )) ('->(Fragment Fragment)) (match ctx (
   ()
   ( () (typecheck-typeof-gvar v) )
   ( (cs (cv ct)) (
      if (eq( v cv )) (
         (LocalVariable ct)
      ) (
         (typecheck-typeof-var( cs v ))
      )
   ))
));

typecheck-typeof-lhs := λlhs . (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (typecheck-infer-type-compound tt)
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      (Cons( (typecheck-typeof-lhs ps) (typecheck-infer-type-compound tt) ))
   ))
   ( (Variable v) (
      S
   ))
   ( (App( ps (Variable v) )) (
      (Cons( (typecheck-typeof-lhs ps) S ))
   ))
   ( Nil (
      Nil
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typecheck-unify-sub := λctx v . (match ctx (
   ()
   ( Accept v )
   ( (Bind( s1 s2 )) (
      if (eq( v s1 )) s2 v
   ))
   ( (ctxl ctxr) (tail(
      (local lv)
      (set lv (typecheck-unify-sub( ctxl v )))
      (local rv)
      (set rv (typecheck-unify-sub( ctxr v )))
      (if (is( lv v )) (
         (if (is( rv v )) () (set v rv))
      ) (set v lv))
      v
   )))
));

typecheck-unify-ctx := λctx v . (match v (
   ()
   ( (vl vr) (
      ( (typecheck-unify-ctx( ctx vl )) (typecheck-unify-ctx( ctx vr )) )
   ))
   ( _ (
      (typecheck-unify-sub( ctx v ))
   ))
));

typecheck-unify-implies := λlt rt . (if (eq(lt rt)) True (match lt (
   ()
   ( (And( lt1 lt2 )) (
      (if (typecheck-unify-implies( lt1 rt )) True (
         (typecheck-unify-implies( lt2 rt ))
      ))
   ))
   ( lt1 (tail(
      (local accept)
      (local subtypes)
      (local st)
      (set subtypes typecheck-subtypes)
      (while subtypes (
         (set st (tail subtypes))
         (if (eq( (head st) lt1 )) (
            (if (eq( (tail st) rt )) (
               (set accept True)
            ) ())
         ) ())
         (set subtypes (head subtypes))
      ))
      accept
   )))
)));

typecheck-unify-args := λlt rt . (tail(
   (local match)
   (local accept-as)
   (set accept-as typecheck-accept-as)
   (while accept-as (
      (if match () (
         (if (deep-eq( (head (tail accept-as)) rt )) (
            (set match (typecheck-unify-args-inner( lt (tail (tail accept-as)) )))
         ) ())
      ))
      (set accept-as (head accept-as))
   ))
   (if match (
      match
   ) (
      (typecheck-unify-args-inner( lt rt ))
   ))
));

typecheck-unify-args-inner := λlt rt . (match (lt rt) (
   ()
   ( ((lt1 rt1) (lt2 rt2)) (
      (match ( (typecheck-unify-args(lt1 lt2)) (typecheck-unify-args(rt1 rt2)) ) (
         ()
         ( (() _) () )
         ( (_ ()) () )
         ( (lctx rctx) (lctx rctx) )
      ))
   ))
   ( (a1 a2) (
      (if (typecheck-unify-implies( a2 a1 )) ( # argument type must imply parameter type
         Accept
      ) (
         (if (is-variable a1) (
            (if (is-variable a2) (
               Accept
            ) (
               (Bind( a1 a2 ))
            ))
         ) (
            (if (is-variable a2) (
               (Bind( a2 a1 ))
            ) (
               ()
            ))
         ))
      ))
   ))
   (_ (tail(
      (fail (UnknownUnify lt rt))
      '?
   )))
));

typecheck-apply-plural := λmany pt . (match many(
   ()
   ( (And( t1 t2 )) (tail(
      (local r)
      (set r (typecheck-apply-plural( t1 pt )))
      (if r r (typecheck-apply-plural( t2 pt )))
   )))
   ( ('->(lt rt)) (tail(
      ()
      (typecheck-unify-ctx( (typecheck-unify-args(lt pt)) rt ))
   )))
   ( u (fail (ApplicationIsNotAFunction many pt)))
));

typecheck-safe-apply-plural := λterm many pt . (tail(
   (local r)
   (set r (typecheck-apply-plural( many pt )))
   (if r r (
      fail (TypeError( InvalidArgument many pt ))
   ))
));

typecheck-infer-type-compound := λcompound . (match compound (
   ()
   ((Literal tt) tt)
   ((Variable tt) tt)
   ((App( (Literal lt) rt )) ( lt (typecheck-infer-type-compound rt) ) )
   ((App( lt rt )) (Cons( (typecheck-infer-type-compound lt) (typecheck-infer-type-compound rt) )) )
   (u (fail (UnknownTypeCompound u)))
));

typecheck-infer-type-constructor := λname body . (match body (
   ()
   ( (Literal tag) (
      (set typecheck-constructors ( typecheck-constructors (tag tag) ))
      (set typecheck-subtypes ( typecheck-subtypes (tag (typecheck-infer-type-compound name)) ))
   ))
   ( (App( (Literal tag) args )) (
      (local ctype)
      (set ctype (typecheck-infer-type-compound args))
      (set typecheck-constructors ( typecheck-constructors (tag ('->(ctype (tag ctype)))) ))
      (set typecheck-subtypes ( typecheck-subtypes ((tag ctype) (typecheck-infer-type-compound name)) ))
   ))
));

typecheck-infer-type-definition := λname def . (match def (
   ()
   ( (App( (App( tds (Literal |) )) body )) (
      (typecheck-infer-type-definition( name tds ))
      (typecheck-infer-type-constructor( name body ))
   ))
   ( body (
      (typecheck-infer-type-constructor( name body ))
   ))
));

typecheck-infer-constructor-type := λtag . (tail(
   (local ctype)
   (local constructors)
   (set constructors typecheck-constructors)
   (while constructors (
      (if (eq( tag (head(tail(constructors))) )) (
         (if ctype (
            (set ctype (And( ctype (tail(tail(constructors))) )))
         ) (
            (set ctype (tail(tail(constructors))))
         ))
      ) ())
      (set constructors (head constructors))
   ))
   ctype
));

typecheck-infer-type-expr := λe . (match e (
   ()
   ( (Type( l ds )) (
      (typecheck-infer-type-definition( l ds ))
      (typecheck-ascript( e '? ))
   ))
   (_ ())
));

typecheck-infer-expr := λctx e . (tail(
   (match e (
      ()
      ( () () )
      ( (GExpr ge) (
         (typecheck-infer-expr( ctx ge ))
      ))
      ( (Global( gln gle )) (
         (typecheck-infer-expr( ctx gle ))
         (match (typecheck-lookup-type gle) (
            ()
            ( () () )
            ( glt (
               (set typecheck-global-context ( typecheck-global-context (Global( gln glt )) ))
               (typecheck-ascript( e '? ))
            ))
         ))
      ))
      ( (Type( l ds )) () )
      ( (Fragment( fln fle )) (
         (match fle (
            ()
            ( (Lambda( lhs rhs )) (
               (local flt)
               (set flt ('->( (typecheck-typeof-lhs lhs) Fragment )) )
               (typecheck-ascript( fle flt ))
               (match fln (
                  ()
                  ( (Variable flnv) (
                     (set typecheck-global-context ( typecheck-global-context (Global( flnv flt )) ))
                  ))
               ))
            ))
         ))
      ))
      ( Nil (
         (typecheck-ascript( e Nil ))
      ))
      ( (App( (Variable 'gensym-label) (Variable lname) )) (
         (set ctx ( ctx (lname (Constant Label)) ))
         (typecheck-ascript( e Fragment ))
      ))
      ( (App( (Variable 'label) (Variable lname) )) (
         (typecheck-ascript( e Fragment ))
      ))
      ( (App( (App( (Literal ':) (Literal _) )) tt )) (
         (typecheck-ascript( e (typecheck-infer-type-compound tt) ))
      ))
      ( (App( (App( (Literal ':) asc )) tt )) (
         (typecheck-infer-expr( ctx asc ))
         (typecheck-ascript( asc (typecheck-infer-type-compound tt) ))
         (typecheck-ascript( e (typecheck-infer-type-compound tt) ))
      ))
      ( (App( (App( (Variable 'as) ast )) ett )) (
         (typecheck-infer-expr( ctx ast ))
         (typecheck-ascript( e (typecheck-infer-type-compound ett) ))
      ))
      ( (Literal lit) (
         (local ctype)
         (set ctype (typecheck-infer-constructor-type lit))
         (if ctype (
            (typecheck-ascript( e (And( ctype Atom )) ))
         ) (
            (typecheck-ascript( e Atom ))
         ))
      ))
      ( (App( l r )) (tail(
         (set ctx (typecheck-infer-expr( ctx l )))
         (set ctx (typecheck-infer-expr( ctx r )))
         (match ( (typecheck-lookup-type l) (typecheck-lookup-type r) ) (
            ()
            ( (() _) () )
            ( (_ ()) () )
            ( ( ('->(lt rt)) pt ) (
               (typecheck-ascript( e (typecheck-safe-apply-plural( e ('->(lt rt)) pt )) ))
            ))
            ( ( (And(t1 t2)) pt ) (
               (typecheck-ascript( e (typecheck-safe-apply-plural( e (And(t1 t2)) pt )) ))
            ))
            ( (Fragment rt) (
               (typecheck-ascript( e rt ))
            ))
            ( (_ Fragment) (
               (typecheck-ascript( e Fragment ))
            ))
            ( (lt rt) (
               (typecheck-ascript( e (Cons(lt rt)) ))
            ))
         ))
      )))
      ( (Lambda( lhs rhs )) (tail(
         (set ctx (typecheck-infer-ctx( ctx lhs )))
         (typecheck-infer-expr( ctx rhs ))
         (match (typecheck-lookup-type rhs) (
            ()
            ( () () )
            ( rt (
               (typecheck-ascript( e ('->( (typecheck-typeof-lhs lhs) rt)) ))
            ))
         ))
      )))
      ( (Variable v) (
         (match (typecheck-typeof-var( ctx v )) (
            ()
            ( () () )
            ( tt (typecheck-ascript( e tt )) )
         ))
      ))
      ( (Size( typf sizf )) (
      ))
      ( u (fail (UnknownTerm u)) )
   ))
   ctx
));

# Assembler

compile-fragment := λctx e offset used . (match e (
   ()
   ( (App( (App( (Variable 'as) inner_e )) _ )) (
      (compile-fragment( ctx inner_e offset used ))
   ))
   ( (App( (Variable 'label) (Variable lname) )) (tail(
      (set e (get-fragment-local( ctx lname offset )))
      (Expr(
         () ( (get-prog e) ': \n ) () () () ctx offset
      ))
   )))
   ( (App( (Variable op) arg )) (tail(
      ()
      (match (get-maybe-function(ctx op (typecheck-lookup-type arg))) (
         ()
         ( (Fragment( (Variable _) body )) (tail(
            ()
            (assemble-apply-fragment( ctx body arg offset ))
         )))
         ( v (
            (fail (ReferenceToUndefinedOperator op (typecheck-lookup-type arg)))
         ))
      ))
   )))
   ( (App( (App( (Literal :) (Literal lval) )) ltype )) (tail(
      (set ltype (typecheck-infer-type-compound ltype))
      (Expr( () lval () () () ctx offset ))
   )))
   ( (Variable v) (tail(
      ()
      (get-fragment-local( ctx v offset ))
   )))
   ( u (fail (UnknownFragment e)))
);

assemble-destructure-fragment := λctx lmb args offset . (match lmb (
   ()
   # fragment annotations are required
   ( (Lambda( (App( (App( (Literal :) (Variable v) )) _ )) body )) (tail(
      (set args (compile-fragment( ctx args offset Used )))
      (() (v args))
   )))
   ( (Lambda( (App( rst (App( (App( (Literal :) (Variable v) )) _ )) )) body )) (tail(
      (local ds)
      (set ds (assemble-destructure-fragment(
         ctx (Lambda( rst body )) (head (tail args)) offset
      )))
      (set args (compile-fragment( ctx (tail (tail args)) offset Used )))
      (ds (v args))
   )))
   ( (Lambda( Nil _ )) (
      ()
   ))
   ( () () )
   ( (Lambda( u _ )) (fail (UnrecgonizedDestructureFragment u)))
   ( u (fail (UnrecgonizedDestructureFragment u)))
));

assemble-substitute-fragment := λsubs frag . (match frag (
   ()
   ( () () )
   ( (Variable v) (tail(
      (while subs (
         (if (eq( v (head (tail subs)) )) (
            (set v (tail (tail subs)))
         ) (
            (set subs (head subs))
         ))
      ))
      v
   )))
   ( (Literal v) (tail(
      (while subs (
         (if (eq( v (head (tail subs)) )) (
            (set v (tail (tail subs)))
         ) (
            (set subs (head subs))
         ))
      ))
      (match v (
         ()
         (\\[ \[)
         (\\] \])
         (\\s \s)
         (\\t \t)
         (\\n \n)
         (u u)
      ))
   )))
   ( (App( l r )) (
      (assemble-substitute-fragment( subs l ))
      (assemble-substitute-fragment( subs r ))
   ))
   ( u (fail (UnknownFragmentSubstitution u)))
));

assemble-apply-literal := λctx arrow args offset . (match arrow (
   ()
   ( (Lambda( (App( (App( (Literal :) (Variable bind) )) ltype )) rhs )) (
      (match args (
         ()
         ( (App( (App( (Literal :) (Literal val) )) vtype )) (
            (Expr(
               ()
               (assemble-substitute-fragment(
                  (() (bind val))
                  rhs
               ))
               () () () ctx offset
            ))
         ))
         ( u (fail (UnknownLiteral u)) )
      ))
   ))
   ( u (fail (UnknownApplyLiteral u)) )
));

assemble-apply-fragment := λctx arrow args offset . (tail(
   (local rc)
   (set rc (assemble-destructure-fragment( ctx arrow args offset )))
   (local frame)
   (local unframe)
   (local text)
   (local data)
   (local prog_subs)
   (while rc (
      (local rce)
      (local rck)
      (set rck (head (tail rc)))
      (set rce (tail (tail rc)))
      (set frame (frame (get-frame (tail rce))))
      (set unframe (unframe (get-unframe (tail rce))))
      (set text (text (get-text (tail rce))))
      (set data (data (get-data (tail rce))))
      (set prog_subs (prog_subs (
         (head (tail rc))
         (get-prog rce)
      )))
      (set rc (head rc))
   ))
   (set rc (match arrow (
      ()
      ( (Lambda( lhs rhs )) (Expr(
         frame
         (assemble-substitute-fragment( prog_subs rhs ))
         unframe
         text
         data
         ctx
         offset
      )))
   )))
   rc
));

assemble := λprogram . (
   (local target)
   (set target 'tmp.s)
   (while cli-config (
      (match (tail cli-config) (
         ()
         ((Target t) (set target t))
      ))
      (set cli-config (head cli-config))
   ))

   (local main_e)
   (local main_pd)

   (local e1)
   (local e2)

   (local output_pd)
   (set output_pd ( () () ))

   (local global_ctx)
   (local preview_program)
   (set preview_program program)

   (while preview_program (match preview_program (
      ()
      ( (pc1 (Global ('main body))) (
         (set preview_program pc1)
      ))
      ( (pc2 (GExpr e)) (
         (set preview_program pc2)
      ))
      ( (pc3 (Global (fname body))) (
         (match body (
            ()
            ( Nil (
               (set output_pd (
                  (head output_pd)
                  (
                     (tail output_pd)
                     (label-case fname)
                     ': \n \t '.zero \s '16 \n
                  )
               ))
               (set global_ctx (global_ctx (GlobalVariable fname)))
            ))
            ( (Lambda(lhs rhs)) (
               (set global_ctx (global_ctx (GlobalFunction( fname body ))))
            ))
         ))
         (set preview_program pc3)
      ))
      ( (prog (Fragment( fname fbody ))) (
         (set global_ctx (global_ctx (Fragment( fname fbody )) ))
         (set preview_program prog)
      ))
      ( (prog (Type( _ _ ))) (
         (set preview_program prog)
      ))
      ( (prog (Size( _ _ ))) (
         (set preview_program prog)
      ))
      ( u (
         (fail (UnexpectedProgram (tail u)))
      ))
   )))

   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set main_e body)
         (set program pc)
      ))
      ( (pc (GExpr e)) (
         (set main_pd (compile-append( main_pd global_ctx e )))
         (set program pc)
      ))
      ( (pc (Global (fname body))) (
         (match body (
            ()
            ( Nil (
            ))
            ( (Lambda(lhs rhs)) (
               (if config-strict (
                  (set e1 (define-calling-convention-stack( global_ctx fname body )))
               ) (
                  (set e1 (define-calling-convention-s( global_ctx fname body )))
               ))
               (set output_pd (
                  ( (head output_pd) (get-text e1) )
                  ( (tail output_pd) (get-data e1) )
               ))
            ))
         ))
         (set program pc)
      ))
      ( (pc (Fragment( _ _ ))) (
         (set program pc)
      ))
      ( (pc (Type( _ _ ))) (
         (set program pc)
      ))
      ( (pc (Size( _ _ ))) (
         (set program pc)
      ))
      ( u (
         (fail (UnexpectedProgram (tail u)))
      ))
   )))

   (if main_e (
      (set main_pd (compile-append( main_pd global_ctx main_e )))
   ) ())

   (set output_pd (
      (
         (assemble-program-header())
         (before-main())
         (enter-function())
         (get-frame main_pd)
         (get-prog main_pd)
         (exit-cleanup())
         (head output_pd)
         (get-text main_pd)
         (if config-nostd () (stdlib-functions()))
      )
      ((if config-nostd () (stdlib-data())) (tail output_pd) (get-data main_pd))
   ))
   (set output_pd (
      ((head output_pd) assemble-text-section)
      ((assemble-data-header()) (tail output_pd) assemble-data-section)
   ))

   (write-file (target (clone-rope output_pd)))
);

# Compile Codegen

compile-include-argv := λ. if compile-argv-hook () (set compile-argv-hook (compile-argv-hook (
   \t 'pop \s '%r10                    \n # put argc in '%r10
   \t 'mov \s '$argv, \s '%r9          \n
   \t 'movq \s '$0, \s '0 \[ '%r9 \]   \n
   \t 'movq \s '$0, \s '8 \[ '%r9 \]   \n

   'before_main_argv:                  \n
   \t 'cmp \s '$0, \s '%r10            \n
   \t 'je \s 'before_main_end          \n

   \t 'pop \s '%r12                    \n #this = argv[i]
   \t 'mov \s '$0, \s '%r13            \n
   (close())                              #r8 is argv[i]

   \t 'mov \s '%r8, \s '0 \[ '%r9 \]   \n #set t.head = argv[i]
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   (close())
   \t 'mov \s '%r8, \s '8 \[ '%r9 \]   \n #set t.tail = ()
   \t 'mov \s '%r8, \s '%r9            \n #set t = t.tail

   \t 'dec \s '%r10                    \n #dec argc
   \t 'jmp \s 'before_main_argv        \n

   'before_main_end:                   \n
)));

compile-append := λoutput_e gctx e . (tail(
   (set e (compile-expr( gctx e (get-offset output_e) Used )))
   (Expr(
      ((get-frame output_e) (get-frame e))
      ((get-prog output_e) (get-prog e))
      ((get-unframe output_e) (get-unframe e))
      ((get-text output_e) (get-text e))
      ((get-data output_e) (get-data e))
      (get-pc e)
      (get-offset e)
   ))
));

define-calling-convention-s := λ ctx fname lmb . (tail(
   ()
   (match lmb (
      ()
      ( (Lambda( lhs rhs )) (tail(
         (local e1)
         (local e2)
         (local text)
         (set e1 (destructure-args(ctx lhs ())))
         (set e2 (compile-expr((get-pc e1) rhs (get-offset e1) Used)))
         (set text ( text (mangle-global-function( fname lmb )) ': \n ))
         (set text ( text (enter-function()) ))
         (set text ( text (get-frame e1) (get-frame e2) ))
         (set text ( text (get-prog e1) (get-prog e2) ))
         (set text ( text (exit-function()) ))
         (set text ( text (get-text e1) (get-text e2) ))
         (Expr(
            () () () text ( (get-data e1) (get-data e2) ) () ()
         ))
      )))
   ))
));

define-sizeof-type := λ tt . (tail(
   (local eight)
   (set eight (inc(inc(inc(inc
              (inc(inc(inc(inc ()
              )))) )))) )
   (match tt (
      ()
      (I8 (inc()) )
      (U8 (inc()) )
      (I16 (inc(inc())) )
      (U16 (inc(inc())) )
      (I32 (inc(inc(inc(inc())))) )
      (U32 (inc(inc(inc(inc())))) )
      (I64 eight )
      (U64 eight )
      (u (fail (UnknownSizeof tt)))
   ))
));

define-calling-convention-stack-destructure-args := λ ctx lhs offset . (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable lname) )) ltype )) (tail(
      (set ltype (typecheck-infer-type-compound ltype))
      (local size)
      (set size (define-sizeof-type ltype))
      (local new_offset)
      (set new_offset (add( offset (define-sizeof-type ltype) )) )
      (Expr(
         () () () () ()
         ( ctx (StackVariable(
            lname (i2s (add( offset (mul( (dec()) size )) )) ) ltype
         )) )
         (i2s new_offset)
      ))
   )))
   ( (App( more (App( (App( (Literal :) (Variable lname) )) ltype )) )) (tail(
      (set ltype (typecheck-infer-type-compound ltype))
      (local size)
      (set size (define-sizeof-type ltype))
      (local new_offset)
      (set new_offset (add( offset (mul( (dec()) (define-sizeof-type ltype) )) )) )
      (set ctx (define-calling-convention-stack-destructure-args( ctx more new_offset )))
      (Expr(
         () () () () ()
         ( (get-pc ctx) (StackVariable(
            lname (i2s (add( offset (mul( (dec()) size )) )) ) ltype
         )) )
         (get-offset ctx)
      ))
   )))
   ( u (fail (UnknownStackArg lhs)))
));

define-calling-convention-stack := λ ctx fname lmb . (tail(
   ()
   (match lmb (
      ()
      ( (Lambda( lhs rhs )) (tail(
         (local e1)
         (local e2)
         (local text)
         (set e1 (define-calling-convention-stack-destructure-args( ctx lhs () )))
         (set e2 (compile-expr( (get-pc e1) rhs (get-offset e1) Used)))
         (set text ( text (mangle-global-function( fname lmb )) ': \n ))
         (set text ( text (get-frame e2) ))
         (set text ( text (get-prog e2) ))
         (set text ( text (\t 'ret \n) ))
         (set text ( text (get-text e2) ))
         (Expr(
            () () () text ( (get-data e2) ) () ()
         ))
      )))
   ))
));

apply-calling-convention-stack := λ ctx e fname arg offset used . (tail(
   (local e1)
   (match (get-maybe-function(ctx fname (typecheck-lookup-type arg))) (
      ()
      ( (GlobalFunction mangledname) (tail(
         (set e1 (destructure-calling-convention-stack( ctx e fname arg offset used )))
         (Expr(
            (get-frame e1)
            ( (enter-function()) (get-prog e1) (\t 'call \s mangledname \n)
              (\t 'mov \s '%rbp, \s '%rsp               \n
               \t 'pop \s '%rbp                        \n) )
            (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1)
         ))
      )))
      ( (Fragment( vname body )) (tail(
         ()
         (assemble-apply-fragment( ctx body arg offset ))
      )))
      ( (StackVariable _) (tail(
         (set e1 (compile-expr( ctx arg offset used )))
         (local l)
         (set l (get-local( ctx fname )))
         (if l () (fail (UnknownFunctionLocal fname)))
         (Expr( (get-frame e1) (l (get-prog e1)) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( l (fail (UnknownFunctionCall fname l)) )
   ))
));

destructure-push-stack := λ ctx arg offset . (match arg (
   ()
   ( (App( (App( (Variable 'as) inner_arg )) tt )) (
      (match (get-maybe-function(ctx 'push (typecheck-lookup-type inner_arg))) (
         ()
         ( (Fragment( (Variable _) body )) (
            (assemble-apply-fragment( ctx body inner_arg offset ))
         ))
         ( v (
            (fail (ReferenceToUndefinedVariable 'push (typecheck-lookup-type arg)))
         ))
      ))
   ))
   ( _ (
      (match (get-maybe-function(ctx 'push (typecheck-lookup-type arg))) (
         ()
         ( (Fragment( (Variable _) body )) (
            (assemble-apply-fragment( ctx body arg offset ))
         ))
         ( v (
            (fail (ReferenceToUndefinedVariable 'push (typecheck-lookup-type arg)))
         ))
      ))
   ))
));

destructure-calling-convention-stack := λ ctx e fname arg offset used . (tail(
   ()
   (match (typecheck-lookup-type arg) (
      ()
      ( (Cons( t1 t2 )) (
         (match arg (
            ()
            ( (App( e1 e2 )) (tail(
               (set e1 (destructure-calling-convention-stack( ctx e fname e1 offset used )))
               (set e2 (destructure-calling-convention-stack( (get-pc e1) e fname e1 (get-offset e2) used )))
               (Expr(
                  ((get-frame e1) (get-frame e1))
                  ((get-prog e1) (get-prog e1))
                  ((get-unframe e1) (get-unframe e1))
                  ((get-text e1) (get-text e1))
                  ((get-data e1) (get-data e1))
                  (get-pc e2)
                  (get-offset e2)
               ))
            )))
            ( v (
               (fail (InvalidParameter fname arg))
            ))
         ))
      ))
      ( t1 (destructure-push-stack( ctx arg offset )) )
   ))
));

apply-calling-convention-s := λ ctx e fname arg offset used . (tail(
   (local e1)
   (local prog)
   (if (is-builtin fname) (tail(
      ()
      (if (eq(fname 'tail)) (tail(
         (set e1 (compile-expr(ctx arg offset Tail)))
         (Expr( (get-frame e1) (get-prog e1) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )) (tail(
         (set e1 (compile-expr(ctx arg offset Used)))
         (set prog ((get-prog e1) (\t 'call \s (label-case fname) \n)))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
   )) (tail(
      ()
      (match (get-maybe-function(ctx fname (typecheck-lookup-type arg))) (
         ()
         ( (GlobalFunction mangledname) (tail(
            (set e1 (compile-expr(ctx arg offset Used)))
            (set prog ((get-prog e1) (\t 'call \s mangledname \n)))
            (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
         )))
         ( (Fragment( (Variable _) body )) (
            (assemble-apply-fragment( ctx body arg offset ))
         ))
         ( () (
            (fail (ReferenceToUndefinedVariable fname (typecheck-lookup-type arg)))
         ))
         ( v (tail(
            ()
            (yield-cons(ctx v arg e offset Used))
         )))
      ))
   )))
));


compile-expr := λctx e offset used . (tail(
   (local e1)
   (local e2)
   (local e3)
   (local prog)
   (local tail_safe)
   (local return)
   (set return (match e (
      ()
      ( (Variable '$_) (tail(
         ()
         (Expr( () () () () () ctx offset ))
      )))
      ( (Variable 'argv) (tail(
         (compile-include-argv())
         (set prog (prog ( \t 'mov \s '$argv, \s '%r8 \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%r8 \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%r8 \] , '%r13 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (Variable vname) (tail(
         ()
         (if config-strict (
            (Expr( () (get-local(ctx vname)) () () () ctx offset ))
         ) (
            (Expr( () (get-local(ctx vname)) () () () ctx offset ))
         ))
      )))
      ( (App( (App( (Literal :) (Literal lval) )) ltype )) (tail(
         ()
         (fail (TODO CompileExpressionLiteral e))
      )))
      ( (App( (App( (Literal :) inner_expr )) (Literal ltype) )) (tail(
         ()
         (compile-expr( ctx inner_expr offset used ))
      )))
      ( (App ((Variable 'local) (Variable fname))) (tail(
         (set e1 (declare-local(ctx fname offset)))
         (Expr( (get-frame e1) ((yield-nil()) (get-prog e1)) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( (App ((Variable 'label) (Variable lname))) (tail(
         ()
         (set e1 (compile-fragment( ctx e offset used )))
         e1
      )))
      ( (App ((Variable 'gensym-label) (Variable fname))) (tail(
         (set ctx (ctx (Label( fname (uuid()) )) ))
         (Expr( () () () () () ctx offset ))
      )))
      ( (App( (Lambda( (Variable lhs) rhs )) bind )) (tail(
         (if config-strict (
            fail (TODO CompileLambdaStrict)
         ) ())
         (set e1 (declare-local(ctx lhs offset)))
         (set e2 (compile-expr((get-pc e1) bind (get-offset e1) Used)))
         (set e3 (compile-expr((get-pc e2) rhs (get-offset e2) Used)))
         (set prog ( prog (yield-nil()) (get-prog e1) ))
         (set prog ( prog (get-prog e2) (set-local((get-pc e2) lhs)) ))
         (set prog ( prog (get-prog e3) ))
         (Expr(
            ((get-frame e1) (get-frame e2) (get-frame e3))
            prog
            ((get-unframe e1) (get-unframe e2) (get-unframe e3))
            ((get-text e1) (get-text e2) (get-text e3))
            ((get-data e1) (get-data e2) (get-data e3))
            (get-pc e3) (get-offset e3)
         ))
      )))
      ( (App( (App( (Variable 'set) (Variable vname) )) x )) (tail(
         (set e1 (compile-expr(ctx x offset Used)))
         (set prog ((get-prog e1) (set-local(ctx vname))))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( (App( (App( (Variable 'while) c )) d )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e2 (compile-expr((get-pc e1) d (get-offset e1) Unused)))
         (local label_while_start)
         (set label_while_start (uuid()))
         (local label_while_end)
         (set label_while_end (uuid()))
         (set prog (prog (label_while_start ': \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'je \s label_while_end \n)))
         (set prog (prog (get-prog e2)))
         (set prog (prog (\t 'jmp \s label_while_start \n)))
         (set prog (prog (label_while_end ': \n)))
         (set tail_safe True)
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( (App( (Variable 'exit) (Literal _) )) (tail(
         (set tail_safe True)
         (set prog (
            \t 'mov \s '$60, \s '%rax          \n
            \t 'mov \s '$1 , \s '%rdi          \n
            \t 'syscall                        \n
         ))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( (App( (App( (Variable 'if) c )) t )) f )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e2 (compile-expr( (get-pc e1) t (get-offset e1) Used )))
         (set e3 (compile-expr( (get-pc e2) f (get-offset e2) Used )))
         (local label_if_true)
         (set label_if_true (uuid()))
         (local label_if_end)
         (set label_if_end (uuid()))
         (set prog (prog (get-prog e1)))
         (set prog (prog ( \t 'cmp \s '$0, '%r12 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r13 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog (get-prog e3)))
         (set prog (prog ( \t 'jmp \s label_if_end \n )))
         (set prog (prog ( label_if_true ': \n )))
         (set prog (prog (get-prog e2)))
         (set prog (prog ( label_if_end ': \n )))
         (Expr(
            ((get-frame e1) (get-frame e2) (get-frame e3))
            prog
            ((get-unframe e1) (get-unframe e2) (get-unframe e3))
            ((get-text e1) (get-text e2) (get-text e3))
            ((get-data e1) (get-data e2) (get-data e3))
            (get-pc e3)
            (get-offset e3)
         ))
      )))
      ( (App( (App( (Variable 'match) t )) p )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e2 (yield-patterns((get-pc e1) p (get-offset e1))))
         (local label_skip)
         (set label_skip (uuid()))
         (set prog ((get-prog e1) (get-prog e2)))
         (set prog (prog ( \t 'cmp \s '$0, \s '%r14 \n )))
         (set prog (prog ( \t 'jne \s label_skip \n )))
         (set prog (prog (yield-nil())))
         (set prog (prog ( label_skip ': \n )))
         (Expr(
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      ( (App ((Variable fname) arg)) (tail(
         ()
         (if config-strict (
            (apply-calling-convention-stack( ctx e fname arg offset used ))
         ) (
            (apply-calling-convention-s( ctx e fname arg offset used ))
         ))
      )))
      ( (Literal l) (tail(
         ()
         (yield-atom (ctx l offset))
      )))
      ( Nil (tail(
         (set prog (prog ( \t 'mov \s '$0 , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r13 \n )))
         (set tail_safe True)
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App (l r)) (tail(
         (set tail_safe True)
         (yield-cons(ctx l r e offset used))
      )))
      ( (GlobalVariable mangled-name) (tail(
         (set prog (
            \t 'mov \s '$ mangled-name , \s '%r15   \n
            \t 'mov \s '0 \[ '%r15 \] , \s '%r12     \n
            \t 'mov \s '8 \[ '%r15 \] , \s '%r13     \n
         ))
         (Expr( () prog () () () ctx offset ))
      )))
      ( u (fail (UnrecognizedExpression u)) )
   )))
   (if tail_safe return (tail(
      ()
      (if (eq(used Tail)) (tail(
         (set prog (get-prog return))
         (set prog (prog (\t 'call \s 'tail \n)))
         (Expr( (get-frame return) prog (get-unframe return) (get-text return) (get-data return) (get-pc return) (get-offset return) ))
      )) (
         return
      ))
   )))
));

# Utility Functions

fail := λmsg . (print-s msg) (exit 1);

deep-eq := λl r . match (l r) (
   ()
   ( (() ()) True )
   ( ((ll lr) (rl rr)) (
      if (deep-eq( ll rl )) (
         (deep-eq( lr rr ))
      ) ()
   ))
   ( (la ra) (eq( la ra )) )
);

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

label-case := λk . (match k (
   ()
   (() ())
   ((l r) ('_ (label-case l) (label-case r) '_))
   (a (label-case-atom a))
));

label-case-atom := λk . (tail(
   (local nk)
   (while k (match (head-string k) (
      ()
      (() ())
      ('- (
         (set nk (nk '_))
         (set k (tail-string k))
      ))
      (': (
         (set nk (nk '_C_))
         (set k (tail-string k))
      ))
      ('< (
         (set nk (nk '_LB_))
         (set k (tail-string k))
      ))
      ('> (
         (set nk (nk '_RB_))
         (set k (tail-string k))
      ))
      (\[ (
         (set nk (nk '_LP_))
         (set k (tail-string k))
      ))
      (\] (
         (set nk (nk '_RP_))
         (set k (tail-string k))
      ))
      ('$ (
         (set nk (nk '_DS_))
         (set k (tail-string k))
      ))
      (c (
         (set nk (nk (clone-rope c)))
         (set k (tail-string k))
      ))
   )))
   (clone-rope nk)
));

is-variable := λv . (match (head-string v) (
   ()
   ('@ True )
   ('? True )
   ('! True )
   ('= True )
   ('> True )
   ('< True )
   ('/ True )
   ('* True )
   ('+ True )
   ('- True )
   ('$ True )
   ('_ True )
   ('a True )
   ('b True )
   ('c True )
   ('d True )
   ('e True )
   ('f True )
   ('g True )
   ('h True )
   ('i True )
   ('j True )
   ('k True )
   ('l True )
   ('m True )
   ('n True )
   ('o True )
   ('p True )
   ('q True )
   ('r True )
   ('s True )
   ('t True )
   ('u True )
   ('v True )
   ('w True )
   ('x True )
   ('y True )
   ('z True )
));

get-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s '%r15 \n
                     \t 'mov \s '0 \[ '%r15 \] , \s '%r12     \n
                     \t 'mov \s '8 \[ '%r15 \] , \s '%r13     \n
                  ))
               ) ()
            )
         ))
         ( (StackVariable( l offset ltype )) (
            if r () (
               if (eq(l v)) (
                  (local size)
                  (set size (i2s (define-sizeof-type ltype)))
                  # register allocation = '%r12, '%r13 only for now
                  (local dst)
                  (match size (
                     ()
                     (1 (set dst ( R12B (Constant Reg8) )))
                     (2 (set dst ( R12W (Constant Reg16) )))
                     (4 (set dst ( R12D (Constant Reg32) )))
                     (8 (set dst ( R12 (Constant Reg64) )))
                     (u (fail (InvalidStackVariableSize u)))
                  ))
                  (local arg_type)
                  (set arg_type (Cons( (Constant Offset) (tail dst) )))
                  (match (get-maybe-function( ctx 'get arg_type )) (
                     ()
                     ( (Fragment( fname body )) (tail(
                        (local arg)
                        (set arg (
                           (App(
                               (App( (App( (Literal :) (Literal offset) ))
                                  (App( (Literal Constant) (Literal Offset) ))
                               ))
                               (App( (App( (Literal :) (Literal (head dst)) )) (Literal (tail dst)) ))
                           ))
                        ))
                        (set r (get-prog (assemble-apply-fragment( ctx body arg () ))))
                     )))
                     (u (fail (UndefinedStackGetter 'get arg_type u)))
                  ))
               ) ()
            )
         ))
         ( (GlobalFunction( _ _ )) () )
         ( (Fragment( _ _ )) () )
         ( (Label( l luid )) (
            if r () (
               if (eq(l v)) (
                  (set r luid)
               ) ()
            )
         ) )
         ( u (
            (fail (InvalidLocal u))
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (ReferenceToUndefinedVariable v))
   ))
   r
));

set-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local((Set l) lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s '%r15 \n
                     \t 'mov \s '%r12 , \s '0 \[ '%r15 \] \n
                     \t 'mov \s '%r13 , \s '8 \[ '%r15 \] \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (AssignToUndefinedVariable v))
   ))
   r
));

get-frame := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

mangle-global-function := λname body . (
   (clone-rope (label-case ( name : (typecheck-lookup-type body) )))
);

get-fragment-local := λctx v offset . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Label(l uid)) (
            if r () (
               if (eq(l v)) (
                  (set r (Expr(
                     () uid () () () ctx offset
                  )))
               ) ()
            )
         ))
         ( _ () )
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (ReferenceToUndefinedFragmentVariable v))
   ))
   r
));

get-maybe-function := λctx v arg_type . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r (Variable l))
               ) ()
            )
         ))
         ( (Fragment( (Variable name) body )) (tail(
            ()
            (if r () (
               if (eq(name v)) (
                  (if config-strict (
                     (if (typecheck-apply-plural( (typecheck-lookup-type body) arg_type )) (
                        (set r (Fragment( (Variable name) body )))
                     ) ())
                  ) (
                     (set r (Fragment( (Variable name) body )))
                  ))
               ) ()
            ))
         )))
         ( (GlobalFunction( name body )) (tail(
            ()
            (if r () (
               if (eq(name v)) (
                  (if config-strict (
                     (if (typecheck-apply-plural( (typecheck-lookup-type body) arg_type )) (
                        (set r (GlobalFunction (mangle-global-function( name body ))))
                     ) ())
                  ) (
                     (set r (GlobalFunction (mangle-global-function( name body ))))
                  ))
               ) ()
            ))
         )))
         ( (GlobalVariable name) (
            if r () (
               if (eq(name v)) (
                  (set r (GlobalVariable (label-case name)))
               ) ()
            )
         ))
         ( (StackVariable(name offset type)) (
            if r () (
               if (eq(name v)) (
                  (set r (StackVariable( name offset type )))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   r
));

declare-local := λctx vname offset . (tail(
   (local frame_this)
   (set frame_this (push-zero()))
   (local refer)
   (local eight)
   (set eight (
      inc(inc(inc(inc(inc(inc(inc(inc(
         ()
      ))))))))
   ))
   (local sixteen)
   (set sixteen (mul( eight (inc(inc(()))) )))
   (local set_this)
   (set set_this (
      \t 'mov \s '%r12, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r13, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] \n
   ))
   (set refer (
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] , '%r12 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] , '%r13 \n
   ))
   (set ctx (ctx (Local(vname refer)) ))
   (set ctx (ctx (Local((Set vname) set_this)) ))
   (Expr(frame_this set_this () () () ctx (inc offset)))
));

i2s := λi . (tail(
   (local ten)
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (local sign)
   (local s)
   (local r)
   (if (is-neg i) (
      (set sign '-)
      (set i (inv i))
   ) ())
   (while i (
      (set r (mod(i ten)))
      (set s ((clone-rope(digit r) s)))
      (set i (div(i ten)))
   ))
   (if s () (set s 0))
   (clone-rope (sign s))
));

s2i := λs . (tail(
   (local i)
   (local is_neg)
   (local one)
   (local two)
   (local three)
   (local four)
   (local five)
   (local six)
   (local seven)
   (local eight)
   (local nine)
   (local ten)
   (set one( inc() ))
   (set two( inc(inc( )) ))
   (set three( inc(inc(inc( ))) ))
   (set four( inc(inc(inc(inc( )))) ))
   (set five( inc(inc(inc(inc(inc( ))))) ))
   (set six( inc( inc(inc(inc(inc(inc( ))))) ) ))
   (set seven( inc(inc( inc(inc(inc(inc(inc( ))))) )) ))
   (set eight( inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))) ))
   (set nine( inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) )))) ))
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (if (eq( (head-string s) '- )) (
      (set is_neg True)
      (set s (tail-string s))
   ) ())
   (while s (
      (set i (mul( i ten )))
      (match (head-string s) (
         ()
         ('0 ())
         ('1 (set i (add( i one )))) 
         ('2 (set i (add( i two )))) 
         ('3 (set i (add( i three )))) 
         ('4 (set i (add( i four )))) 
         ('5 (set i (add( i five )))) 
         ('6 (set i (add( i six )))) 
         ('7 (set i (add( i seven )))) 
         ('8 (set i (add( i eight ))))          
         ('9 (set i (add( i nine ))))          
         (u (fail (InvalidDigit u)))
      ))
      (set s (tail-string s))
   ))
   (if is_neg (
      (mul( (dec()) i ))
   ) i )
));

destructure-args := λctx e offset . (match e (
   ()
   ( Nil (tail(
      ()
      (Expr( () () () () () ctx offset ))
   )))
   ( (App( (App( (Literal :) (Variable n) )) nt )) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( (Variable n) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( ( (App( h t )) ) (tail(
      (local ta)
      (set ta (destructure-args(ctx t offset)))
      (set offset (get-offset ta))
      (set ctx (get-pc ta))
      (local ha)
      (set ha (destructure-args(ctx h offset)))
      (set offset (get-offset ha))
      (set ctx (get-pc ha))
      (local prog)
      (set prog (prog (push-this()) ))
      (set prog (prog (\t 'call \s 'tail \n) ))
      (set prog (prog (get-prog ta) ))
      (set prog (prog (pop-this()) ))
      (set prog (prog (\t 'call \s 'head \n) ))
      (set prog (prog (get-prog ha) ))
      (Expr(
         ( (get-frame ta) (get-frame ha) )
         prog
         ( (get-unframe ta) (get-unframe ha) )
         () () ctx offset
      ))
   )))
   ( _ (
      (fail (InvalidFunctionParameters DidYouForgetToSeparateADotTokenInFunctionParam? e))
   ))
));

# Data Segments

assemble-data-header := λ .(
  '.data                                  \n
);

stdlib-data := λ .(
  'load_file_bsz:                         \n
  \t '.quad \s '1024                      \n
  'load_file_buf:                         \n
  \t '.zero \s '1024                      \n
  'argv:                                  \n
  \t '.zero \s '16                        \n
  'nil_literal:                           \n
  \t '.ascii \s " \[ \] "                 \n
  \t '.zero \s 1                          \n
  'newline:                               \n
  \t '.ascii \s " \\n "                   \n
  'left_paren:                            \n
  \t '.ascii \s " \[ "                    \n
  'right_paren:                           \n
  \t '.ascii \s " \] "                    \n
  'space:                                 \n
  \t '.ascii \s " \s "                    \n
  'true:                                  \n
  \t '.ascii \s "True"                    \n
  \t '.zero \s '1                         \n
  '__digit:                               \n
  \t '.zero \s '2                         \n
  'hex_buffer:                            \n
  \t '.ascii \s "0123456789abcdef"        \n
  '__mutable_char:                        \n
  \t '.zero \s '2                         \n
  '__dump_i:                              \n
  \t '.ascii \s '"0000000000000000"       \n
  \t '.zero \s '1                         \n
  'err_fopen:                             \n
  \t '.ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t '.zero \s '1                         \n
);

assemble-program-header := λ .(
   '.global \s '_start                    \n
   '.text                                 \n
   '_start:                               \n
   \t 'jmp \s 'main                       \n
);

stdlib-functions := λ . (
   'print_s:                           \n
   # if .head is zero, then this is Nil
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s 'print_s_nil              \n

   # if only .tail is zero, then this is an Atom
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'print_s_atom             \n

   # if .head and .tail are non-zero, then this is a Cons
   (system-call( '$1 '$1 '$left_paren '$1 ))
   (push-this())
   \t 'call \s 'head                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$space '$1 ))
   (push-this())
   \t 'call \s 'tail                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$right_paren '$1 ))
   \t 'ret                             \n

   'print_s_nil:                       \n
   # nil is two bytes "()" located in the data section at $nil_literal
   (system-call( '$1 '$1 '$nil_literal '$2 ))
   \t 'ret                             \n

   'print_s_atom:                      \n
   \t 'call \s 'strlen                 \n # '%r8 is string length of this atom
   (system-call( '$1 '$1 '%r12 '%r8 )) \n
   \t 'ret                             \n

   'is_atom:                              \n
   \t 'cmp \s '$0, '%r12                  \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, '%r13                  \n
   \t 'jne \s 'return_nil                 \n
   \t 'jmp \s 'return_true                \n

   'is_cons:                              \n
   \t 'cmp \s '$0, '%r12                  \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, '%r13                  \n
   \t 'je \s 'return_nil                  \n
   \t 'jmp \s 'return_true                \n

   'head_string:                          \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'movb \s '0 \[ '%r12 \] , \s '%bl   \n
   \t 'mov \s '$__mutable_char, \s '%r12  \n
   \t 'movb \s '%bl, \s '0 \[ '%r12 \]    \n
   \t 'ret                                \n

   'tail_string:                          \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'inc \s '%r12                       \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'ret                                \n

   'head:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
   \t 'ret                                \n

   'tail:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
   \t 'ret                                \n

   'strlen:                               \n
   \t 'xor \s '%r8, \s '%r8               \n
   \t 'mov \s '%r12, \s '%rax             \n
   'strlen_loop:                          \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]     \n
   \t 'jz \s 'strlen_exit                 \n
   \t 'inc \s '%r8                        \n
   \t 'inc \s '%rax                       \n
   \t 'jmp \s 'strlen_loop                \n
   'strlen_exit:                          \n
   \t 'ret                                \n

   'streq:                                \n
   'streq_loop:                           \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%rax \] , \s '%cl    \n
   \t 'mov \s '0 \[ '%rbx \] , \s '%dl    \n

   \t 'cmp \s '%cl, \s '%dl               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%cl                \n
   \t 'je \s 'streq_true                  \n
   \t 'inc \s '%rax                       \n
   \t 'inc \s '%rbx                       \n
   \t 'jmp \s 'streq_loop                 \n
   'streq_true:                           \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'eq:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'call \s 'streq                     \n
   \t 'ret                                \n

   'return_nil:                           \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'return_true:                          \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'not:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jne \s 'not_yield_nil              \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
   'not_yield_nil:                        \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'clone_rope:                           \n
   \t 'mov \s '$0, \s '%r8                \n
   \t 'mov \s '$0, \s '%r9                \n
   (allocate-atom-grow '$0)
   \t 'call \s '__clone_rope              \n
   (allocate-atom-grow '$1)
   \t 'movb \s '$0, \s '0 \[ '%r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   '__clone_rope:                         \n
   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s '__clone_rope_notcons        \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'mov \s '8 \[ '%r12 \] , '%r13      \n
   \t 'mov \s '0 \[ '%r12 \] , '%r12      \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'mov \s '0 \[ '%r13 \] , '%r12      \n
   \t 'mov \s '8 \[ '%r13 \] , '%r13      \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'jmp \s '__clone_rope_end           \n

   #if not cons, concat
   '__clone_rope_notcons:                 \n

   #if nil, return
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s '__clone_rope_end            \n

   #if atom, break into characters and concat
   '__clone_rope_small:                   \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s '__clone_rope_end            \n
   (allocate-atom-grow '$1)
   \t 'movb \s '0 \[ '%r12 \] , \s '%bl   \n
   \t 'movb \s '%bl, \s '0 \[ '%r9 \]     \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r12                       \n
   \t 'jmp \s '__clone_rope_small         \n

   '__clone_rope_end:                     \n
   \t 'ret                                \n

   'is:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'is_neg:                               \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jge \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'inc:                                  \n
   \t 'inc \s '%r12                       \n
   \t 'ret                                \n

   'dec:                                  \n
   \t 'dec \s '%r12                       \n
   \t 'ret                                \n

   'inv:                                  \n
   \t 'neg \s '%r12                       \n
   \t 'ret                                \n

   'mul:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'imul \s '%rax, \s '%rbx            \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'add:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'add \s '%rax, \s '%rbx             \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'div:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'ret                                \n

   'mod:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rdx, \s '%r12             \n
   \t 'ret                                \n

   'dump_i:                               \n
   \t 'mov \s '%r12, \s '%r8              \n
   \t 'mov \s '$__dump_i, \s '%r12        \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$__dump_i, \s '%r11        \n
   \t 'cmp \s '$0, \s '%r8                \n
   \t 'jge \s 'dump_i_positive            \n
   \t 'jmp \s 'dump_i_negative            \n
   'dump_i_positive:                      \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$48, \s '0 \[ '%r11 \]    \n
   \t 'ret                                \n
   'dump_i_negative:                      \n
   \t 'neg \s '%r8                        \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$45, \s '0 \[ '%r11 \]    \n
   \t 'ret                                \n
   # if return value is positive then open was a success

   'dump_i_digits:                        \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[0]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '0 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[1]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '1 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[2]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '2 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[3]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '3 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[4]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '4 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[5]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '5 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[6]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '6 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[7]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '7 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[8]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '8 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[9]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '9 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[10]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '10 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[11]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '11 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[12]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '12 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[13]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '13 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[14]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '14 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[15]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '15 \[ '%r11 \]     \n
   \t 'ret                                \n

   #move ascii representation of lower byte of '%r8 into '%cl
   'put8:                                 \n
   \t 'mov \s '%r8b, \s '%al              \n # lower byte of '%r11 goes into '%rax
   \t 'and \s '$0xf, \s '%al              \n # only show lower 4 bits
   \t 'mov \s '$hex_buffer, '%r10         \n # '%r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b             \n # '%r10 is index into char in hex buffer
   \t 'mov \s '0 \[ '%r10 \] , \s '%cl     \n # '%cl is a hexadecimal char
   \t 'ret                                \n

   'digit:                                \n
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'add \s '$48, \s '%rax               \n
   \t 'mov \s '$__digit, \s '%r12          \n
   \t 'mov \s '%al, \s '0 \[ '%r12 \]      \n
   \t 'mov \s '$0, \s '%r13                \n
   \t 'ret                                \n

   'write_file:                           \n
   #open file
   \t 'mov \s '0 \[ '%r12 \] , \s '%rdi    \n # file name
   \t 'pushq \s '0 \[ '%r13 \]             \n # data to write
   \t 'mov \s '$2, \s '%rax               \n # syscall open
   \t 'mov \s '$577, \s '%rsi              \n
   \t 'mov \s '$420, \s '%rdx             \n # mode
   \t 'syscall                            \n
   \t 'mov \s '%rax, \s '%r8              \n # r8 now holds file descriptor

   #write to file
   \t 'pop \s '%rax                       \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'mov \s '%r8, \s '%r10              \n # '%r10 has file descriptor
   \t 'call \s 'strlen                    \n
   (system-call( '$1 '%r10 '%r12 '%r8 ))

   #close file
   (system-call( '$3 '%r10 '$0 '$0 ))
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file:                            \n

   # open file
   (system-call( '$2 '%r12 '$0 '$0 ))
   # file descriptor is in '%rax

   \t 'cmp \s '$0, \s '%rax               \n
   # if return value is positive then open was a success
   \t 'jge \s 'load_file_contents         \n

   \t 'mov \s '$err_fopen, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file_contents:                   \n
   \t 'mov \s '$0, \s '%r8                \n
   \t 'mov \s '$0, \s '%r9                \n
   (allocate-atom-grow '$0)
   # r8 holds pointer to head of new data
   # r9 holds pointer to tail of new data
   \t 'mov \s '$0, \s '%r10               \n # r10 holds amount of data on buffer currently
   \t 'mov \s '$load_file_buf, \s '%r11   \n # r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:                       \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'je \s 'load_file_bufempty          \n
   (allocate-atom-grow '$1)
   \t 'movb \s '0 \[ '%r11 \] , \s '%bl    \n
   \t 'mov \s '%bl, \s '0 \[ '%r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r11                       \n
   \t 'dec \s '%r10                       \n
   \t 'jmp \s 'load_file_loop             \n

   # read file
   'load_file_bufempty:                   \n
   \t 'push \s '%rax                      \n
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'mov \s '$load_file_bsz, \s '%rdx   \n
   \t 'mov \s '0 \[ '%rdx \] , \s '%rdx   \n
   (system-call( '$0 '%r10 '$load_file_buf () ))
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'pop \s '%rax                       \n
   \t 'mov \s '$load_file_buf, \s '%r11   \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'jne \s 'load_file_loop             \n

   # close file
   (system-call( '$3 '%rax '$0 '$0 ))
   (allocate-atom-grow '$1)
   \t 'movb \s '$0, \s '0 \[ '%r9 \]       \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
);

inline-head := λ . (
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
);

inline-tail := λ . (
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
);

enter-function := λ .(
   \t 'push \s '%rbp                       \n
   \t 'mov \s '%rsp, \s '%rbp               \n
);

exit-function := λ .(
   \t 'mov \s '%rbp, \s '%rsp               \n
   \t 'pop \s '%rbp                        \n
   \t 'ret                                \n
);

push-this := λ .(
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
);

push-zero := λ .(
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
);

pop-this := λ .(
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
);

yield-nil := λ . (
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
);

yield-cons-s := λctx l r ce offset used . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local rused)
   (match used (
      ()
      ( Used (tail(
         (set e1 (compile-expr( ctx l offset Used )))
         (set offset (get-offset e1))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
         (set offset (get-offset e2))
         (set prog (prog (get-prog e1)))
         (set prog (prog (push-this())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (close())))
         (set prog (prog (pop-this())))
         (set prog (prog (\t 'push \s '%r8 \n)))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r8, \s '%r12 \n)))
         (set prog (prog (\t 'pop \s '%r13 \n)))
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( _ (tail(
         (set rused ( if (eq(used Tail)) Used Unused ))
         (set e1 (compile-expr( ctx l offset Unused )))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) rused )))
         (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
   ))
));

yield-cons := λctx l r ce offset used . (tail(
   (local e1)
   (local e2)
   (if config-strict (tail(
      (local typel)
      (set typel (typecheck-lookup-type l))
      (local typer)
      (set typer (typecheck-lookup-type r))
      (local typece)
      (set typece (typecheck-lookup-type ce))
      (match (typel typer typece) (
         ()
         ( (_ Fragment _) (tail(
            (set e1 (compile-expr( ctx l offset Used )))
            (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
            (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
         )))
         ( (Fragment _ _) (tail(
            (set e1 (compile-expr( ctx l offset Used )))
            (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
            (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
         )))
         ( (_ _ _) (tail(
            ()
            (yield-cons-s( ctx l r ce offset used ))
         )))
      ))
   )) (
      (yield-cons-s( ctx l r ce offset used ))
   ))
));

yield-atom-cache := ();
yield-atom := λctx a offset . (tail(
   (local cache)
   (set cache yield-atom-cache)
   (local id)
   (local data)
   (while cache (
      (if (eq( (head (head cache)) a )) (
         (set id (tail (head cache)))
      ) ())
      (set cache (tail cache))
   ))
   (if id () (
      (set id (uuid()))
      (set data (id ': \n \t '.ascii \s " (escape-sequences a) " \n \t '.zero \s 1 \n))
      (set yield-atom-cache ((a id) yield-atom-cache))
   ))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
      )
      ()
      ()
      data
      ctx
      offset
   ))
));

$uuid := ();
uuid := λ . (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

escape-sequences := λt . match t (
   ()
   ( () () )
   ( \\ \\\\ )
   ( \\: \: )
   ( \\o \o )
   ( \\n (\\ 'n))
   ( \\t \t )
   ( \\s \s )
   ( \\l \l )
   ( \\[ \[ )
   ( \\] \] )
   ( (l r) ( (escape-sequences l) (escape-sequences r) ) )
   ( s (tail(
      (local c)
      (local cs)
      (local is_escape)
      (while s (
         (set c (head-string s))
         (set s (tail-string s))
         (match c (
            ()
            ( " (
               (set cs (cs \\ "))
               (set is_escape ())
            ))
            (\\ (
               (if is_escape (
                 (set cs ( cs \\\\ ))
                 (set is_escape ())
               ) (set is_escape True))
            ))
            (_ (
               (if is_escape (
                  (match c (
                     ()
                     ( , (set cs (cs .)))
                     ( _ (fail( InvalidEscapeCharacter (c s) )))
                  ))
               ) (set cs (cs (clone-rope c))))
               (set is_escape ())
            ))
         ))
      ))
      (clone-rope cs)
   )))
);

close := λe . (
   e
   (allocate-cons ())
   (\t 'mov \s '%r12, \s '0 \[ '%r8 \] \n)
   (\t 'mov \s '%r13, \s '8 \[ '%r8 \] \n)
);

is-builtin := λf . (match f (
   ()
   ('is True)
   ('is-atom True)
   ('is-cons True)
   ('eq True)
   ('not True)
   ('head True)
   ('head-string True)
   ('tail-string True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('add True)
   ('mul True)
   ('div True)
   ('mod True)
   ('inv True)
   ('is-neg True)
   ('digit True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

system-call := λrax rdi rsi rdx . (
   (if rax (\t 'mov \s rax , \s '%rax              \n) ())
   (if rdi (\t 'mov \s rdi , \s '%rdi              \n) ())
   (if rsi (\t 'mov \s rsi , \s '%rsi              \n) ())
   (if rdx (\t 'mov \s rdx , \s '%rdx              \n) ())
   \t 'syscall                            \n
);

yield-patterns := λctx p offset . match p (
   ()
   ( Nil (tail(
      ()
      (Expr( () (\t 'mov \s '$0, \s '%r14 \n) () () () ctx offset ))
   )))
   ( (App( prev (App( lhs rhs )) )) (tail(
      (local e1)
      (local e2)
      (local e3)
      (local prog)
      (set e1 (yield-patterns(ctx prev offset)))
      (set e2 (destructure-pattern-lhs((get-pc e1) lhs (get-offset e1))))
      (set e3 (compile-expr((get-pc e2) rhs (get-offset e2) Used)))
      (local label_skip)
      (set label_skip (uuid()))
      (set prog (prog (get-prog e1)))
      (set prog (prog (\t 'cmp \s '$0, \s '%r14 \n)))
      (set prog (prog (\t 'jne \s label_skip \n)))
      (set prog (prog (get-prog e2)))
      (set prog (prog (\t 'cmp \s '$0, \s '%r14 \n)))
      (set prog (prog (\t 'je \s label_skip \n)))
      (set prog (prog (get-prog e3)))
      (set prog (prog (\t 'mov \s '$1, \s '%r14 \n)))
      (set prog (prog (label_skip ': \n)))
      (Expr( 
         ((get-frame e1) (get-frame e2) (get-frame e3))
         prog
         ((get-unframe e1) (get-unframe e2) (get-unframe e3))
         ((get-text e1) (get-text e2) (get-text e3))
         ((get-data e1) (get-data e2) (get-data e3))
         ctx
         (get-offset e3)
      ))
   )))
   ( _ (
      (fail (InvalidPatternsCase p))
   ))
);

destructure-pattern-lhs := λctx lhs offset . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local label_skip)
   (match lhs (
      ()
      ( (Variable '_) (tail(
         ()
         (Expr( () (\t 'mov \s '$1, \s '%r14 \n) () () () ctx offset ))
      )))
      ( (Variable v) (tail(
         (set e1 (declare-local(ctx v offset)))
         (Expr(
            (get-frame e1)
            ((get-prog e1) \t 'mov \s '$1, \s '%r14 \n)
            (get-unframe e1)
            (get-text e1)
            (get-data e1)
            (get-pc e1)
            (get-offset e1)
         ))
      )))
      ( (Literal l) (tail(
         (set e1 (yield-atom(ctx l offset)))
         (set label_skip (uuid()))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))       
         (set prog (prog (\t 'cmp \s '$0, \s '%r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))       
         (set prog (prog (\t 'mov \s '%r12, \s '%rax \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'mov \s '%r12, \s '%rbx \n)))
         (set prog (prog (\t 'call \s 'streq \n)))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s '%r14 \n)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( Nil (tail(
         (set label_skip (uuid()))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'cmp \s '$0, \s '%r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s '%r14 \n)))
         (set prog (prog (label_skip ': \n)))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( l r )) (tail(
         (set e1 (destructure-pattern-lhs(ctx l offset)))
         (set e2 (destructure-pattern-lhs((get-pc e1) r (get-offset e1))))
         (set label_skip (uuid()))
         (set prog (prog (\t 'mov \s '$0, \s '%r14 \n)))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s '%r13 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (inline-head())))
         (set prog (prog (get-prog e1)))
         (set prog (prog (pop-this())))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s '%r14 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$0, \s '%r14 \n)))
         (set prog (prog (inline-tail())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( 
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      (_ (fail (UnexpectedPattern lhs)))
   ))
));

before-main := λ .(
   # before_main_argv:
   #    argv = ()
   #    let t = argv
   #    for a in argv:
   #       t.tail = (a ())
   #       t = t.tail

   'main:                              \n
   compile-argv-hook
);

exit-cleanup := λ . (system-call( '$60 '$0 '$0 '$0 ));
