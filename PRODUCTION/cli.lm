
main := (
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (local config)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config (config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--compile (set mode Compile))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
);

tokenize-file := λpath. (
   tokenize (load-file path)
);

#returns (lhs rhs)
parse-lambda := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (local lmb)
   (set lmb (head er))
   (set toks (tail er))
   (match lmb (
      ()
      ((Literal \,) (
         (set lmb (Nil (parse-many-expressions toks)))
         (set toks ())
      ))
   ))
   (while toks (
      (set er (parse-one-expression toks))
      (match er (
         ()
         (((Literal \,) r) (
            (set lmb (lmb (parse-many-expressions r)))
            (set toks ())
         ))
         ((e ()) (
            (set lmb (lmb e))
            (print-s (ExpectedLambdaRhs lmb))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))
   lmb
));

parse-one-expression := λtoks. (tail(
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set expr (Lambda (parse-lambda r)))
         (set remainder ())
      ))
      ( ( \] r ) (
         (print-s (DANGLING_PARENTHESES toks))
         (set remainder ())
      ))
      ( ( \[ r ) (
         (local depth)
         (set depth 1)
         (local nested)
         (while depth (
            (if r (
               (local next)
               (set next (head r))
               (set r (tail r))
               (match next (
                  ()
                  ( \[ (
                     (set nested (nested next))
                     (set depth (1 depth))
                  ))
                  ( \] (
                     (set depth (tail depth))
                     (if depth (
                        (set nested (nested next))
                     ) ())
                  ))
                  ( _ (
                     (set nested (nested next))
                  ))
               ))
            ) (
               (print-s UNCLOSED_PARENTHESES)
               (set depth ())
            ))
         ))
         (set expr (parse-many-expressions (reverse-list nested)))
         (set remainder r)
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

print-ctx := λctx. (
   while ctx (
      (print-s (tail ctx))
      (set ctx (head ctx))
   )
);

get-local := λctx v. (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (Global(l body)) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r15 \n
                     \t 'mov \s '0 \[ %r15 \] , \s %r12 \n
                     \t 'mov \s '8 \[ %r15 \] , \s %r13 \n
                     \t 'mov \s '16 \[ %r15 \] , \s %r14 \n
                     \t 'mov \s '24 \[ %r15 \] , \s %r15 \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (print-s (ReferenceToUndefinedLocal v))
   ))
   r
));
get-global := λctx v. (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Global(name body)) (
            if r () (
               if (eq(name v)) (
                  (set r (Global(name body)))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   r
));
set-local := λctx v. (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local((Set l) lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (Global(l body)) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r8 \n
                     \t 'mov \s %r12 , \s '0 \[ %r8 \] \n
                     \t 'mov \s %r13 , \s '8 \[ %r8 \] \n
                     \t 'mov \s %r14 , \s '16 \[ %r8 \] \n
                     \t 'mov \s %r15 , \s '24 \[ %r8 \] \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (print-s (AssignToUndefinedLocal v))
   ))
   r
));

parse-many-expressions := λtoks. (tail(
   (local er)
   (set er (parse-one-expression toks))
   (local return)
   (set return (head er))
   (local remainder)
   (set remainder (tail er))
   (while remainder (
      (set er (parse-one-expression remainder))
      (set return (App (return (head er))))
      (set remainder (tail er))
   ) (head er))
   return
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local key)
   (local rhs)
   (local a)
   (foreach-atom toks (
      (set a $_)
      (if (eq(a \:)) (
         (if key (
            (set program (program (Global (key (parse-many-expressions (reverse-list rhs))))))
            (set key ())
         ) ())
         (set rhs ())
      ) (
         (if a (set rhs (rhs a)) ())
         (match rhs (
            ()
            ( ( (() k) ':=) (
               (set key k)
               (set rhs ())
            ))
            ( _ () )
         ))
      ))
   ))
   (if key (
     (set program (program (Global (key (parse-many-expressions (reverse-list rhs))))))
   ) ())
   program
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

reverse-list := λl. (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv. (tail(
   (local is_v)
   (local passed_char)
   (local c)
   (foreach-char v (
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_v True) (set passed_char True) ))
         ('_ ( (set is_v True) (set passed_char True) ))
         ('a ( (set is_v True) (set passed_char True) ))
         ('b ( (set is_v True) (set passed_char True) ))
         ('c ( (set is_v True) (set passed_char True) ))
         ('d ( (set is_v True) (set passed_char True) ))
         ('e ( (set is_v True) (set passed_char True) ))
         ('f ( (set is_v True) (set passed_char True) ))
         ('g ( (set is_v True) (set passed_char True) ))
         ('h ( (set is_v True) (set passed_char True) ))
         ('i ( (set is_v True) (set passed_char True) ))
         ('j ( (set is_v True) (set passed_char True) ))
         ('k ( (set is_v True) (set passed_char True) ))
         ('l ( (set is_v True) (set passed_char True) ))
         ('m ( (set is_v True) (set passed_char True) ))
         ('n ( (set is_v True) (set passed_char True) ))
         ('o ( (set is_v True) (set passed_char True) ))
         ('p ( (set is_v True) (set passed_char True) ))
         ('q ( (set is_v True) (set passed_char True) ))
         ('r ( (set is_v True) (set passed_char True) ))
         ('s ( (set is_v True) (set passed_char True) ))
         ('t ( (set is_v True) (set passed_char True) ))
         ('u ( (set is_v True) (set passed_char True) ))
         ('v ( (set is_v True) (set passed_char True) ))
         ('w ( (set is_v True) (set passed_char True) ))
         ('x ( (set is_v True) (set passed_char True) ))
         ('y ( (set is_v True) (set passed_char True) ))
         ('z ( (set is_v True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_v
));
