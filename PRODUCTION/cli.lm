
main := (
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (local config)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config (config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--compile (set mode Compile))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (--typecheck (set mode Typecheck))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (Typecheck (foreach-atom inputs (
         if $_ (print-s (show-ascript (typecheck (parse-program (tokenize (load-file $_)))))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
);

#this is necessary to circumvent a bug with the bootstrap compiler trying to call globals as functions syntactically
global := λvalue. value;
fail := λmsg. print-s msg;

type-definitions := ();
type-context := ();
types-have-changed := ();

tokenize-file := λpath. (
   tokenize (load-file path)
);

typecheck := λprogram. (tail(
   (set types-have-changed True)
   (while types-have-changed (
      (set types-have-changed ())
      (infer-prog program)
   ))
   program
));

lookup-type := λterm. (tail(
   (local tctx)
   (set tctx type-context)
   (local found)
   (local ttt)
   (while tctx (
      (set ttt (head tctx))
      (if (is( (head ttt) term )) (
         (set found (tail ttt))
         (set tctx ())
      ) (
         (set tctx (tail tctx))
      ))
   ))
   found
));

ascript := λt tt. (
   (set type-context ((t tt) type-context))
   (set types-have-changed True)
);

show-ascript := λp. (tail(
   (local term)
   (set term (match p (
      ()
      ( () () )
      ( Nil p )
      ( (Variable _) p )
      ( (Literal _) p )
      ( (App( f x )) (
         (App( (show-ascript f) (show-ascript x) ))
      ))
      ( (Lambda( lhs rhs )) (
         (App( (show-ascript lhs) (show-ascript rhs) ))
      ))
      ( (prog (GExpr( g ))) (
         ( (show-ascript prog) (GExpr( show-ascript g )) )
      ))
      ( (prog (Global( n v ))) (
         ( (show-ascript prog) (Global( n (show-ascript v) )) )
      ))
      ( (prog (Type( tn td ))) (
         ( (show-ascript prog) (Type( tn td )) )
      ))
      ( unknown (
         print-s (UnknownTerm unknown)
      ))
   )))
   (local type)
   (set type (lookup-type p))
   (if type (
      (if (eq( type ? )) (
         term
      ) ( 
         (:( term type ))
      ))
   ) (
      term
   ))
));

global-context := ();

infer-prog := λp. (
   (while p (
      (infer-expr( (global global-context) (tail p) ))
      (set p (head p))
   ))
);

infer-ctx := λctx e. (match e (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (ctx (v (typeof-ascript tt)))
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      ( (infer-ctx( ctx ps )) (v (typeof-ascript tt)))
   ))
   ( (Variable v) (
      (ctx (v S))
   ))
   ( (App( ps (Variable v) )) (
      ( (infer-ctx( ctx ps )) (v S))
   ))
   ( u (
      print-s (UnknownLhs u)
   ))
));

typeof-gvar := λv. (tail(
   (local gctx)
   (set gctx global-context)
   (local tt)
   (while gctx (
      (match (tail gctx) (
         ()
         ( (Global( gn gt )) (
            if (eq( v gn )) (
               (set gctx ())
               (set tt gt)
            ) (
               (set gctx (head gctx))
            )
         ))
      ))
   ))
   tt
));

typeof-var := λctx v. (match ctx (
   ()
   ( () (typeof-gvar v) )
   ( (cs (cv ct)) (
      if (eq( v cv )) (
         ct
      ) (
         (typeof-var( cs v ))
      )
   ))
));

typeof-ascript := λtt. (match tt (
   ()
   ( (Literal tname) (
      tname
   ))
   ( (Variable tname) (
      tname
   ))
));

typeof-lhs := λlhs. (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (typeof-ascript tt)
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      (Cons( (typeof-lhs ps) (typeof-ascript tt) ))
   ))
   ( (Variable v) (
      S
   ))
   ( (App( ps (Variable v) )) (
      (Cons( (typeof-lhs ps) S ))
   ))
   ( u (
      print-s (UnknownLhs u)
   ))
));

unify-sub := λctx v. (match ctx (
   ()
   ( Accept v )
   ( (Bind( s1 s2 )) (
      if (eq( v s1 )) s2 v
   ))
   ( (ctxl ctxr) (tail(
      (local lv)
      (set lv (unify-sub( ctxl v )))
      (local rv)
      (set rv (unify-sub( ctxr v )))
      (if (is( lv v )) () (set v lv))
      (if (is( rv v )) () (set v rv))
      v
   )))
));

unify-ctx := λctx v. (match v (
   ()
   ( (vl vr) (
      ( (unify-ctx( ctx vl )) (unify-ctx( ctx vr )) )
   ))
   ( _ (unify-sub( ctx v )))
));

unify-args := λlt rt. (match (lt rt) (
   ()
   ( ((lt1 rt1) (lt2 rt2)) (
      (match ( (unify-args(lt1 lt2)) (unify-args(rt1 rt2)) ) (
         ()
         ( (() _) () )
         ( (_ ()) () )
         ( (lctx rctx) (lctx rctx) )
      ))
   ))
   ( (a1 a2) (
      (if (eq( a1 a2 )) (
         Accept
      ) (
         (if (is-variable a1) (
            (if (is-variable a2) (
               Accept
            ) (
               (Bind( a1 a2 ))
            ))
         ) (
            (if (is-variable a2) (
               (Bind( a2 a1 ))
            ) (
               ()
            ))
         ))
      ))
   ))
   (_ (fail (UnknownUnify lt rt)))
));

infer-expr := λctx e. (
   (if (lookup-type e) () (
      match e (
         ()
         ( () () )
         ( (GExpr ge) (
            (infer-expr( ctx ge ))
         ))
         ( (Global( gln gle )) (
            (infer-expr( ctx gle ))
            (match (lookup-type gle) (
               ()
               ( () () )
               ( glt (
                  (set global-context ( (global global-context) (Global( gln glt )) ))
                  (ascript( e ? ))
               ))
            ))
         ))
         ( (Type( l ds )) (
            (set type-definitions (e type-definitions))
            (ascript( e ? ))
         ))
         ( Nil (
            (ascript( e Nil ))
         ))
         ( (Literal _) (
            (ascript( e Atom ))
         ))
         ( (App( l r )) (
            (infer-expr( ctx l ))
            (infer-expr( ctx r ))
            (match ( (lookup-type l) (lookup-type r) ) (
               ()
               ( (() _) () )
               ( (_ ()) () )
               ( ( (->(lt rt)) pt ) (
                  (ascript( e (unify-ctx( (unify-args(lt pt)) rt )) ))
               ))
               ( (lt rt) (
                  (ascript( e (Cons(lt rt)) ))
               ))
            ))
         ))
         ( (Lambda( lhs rhs )) (
            (set ctx (infer-ctx( ctx lhs )))
            (infer-expr( ctx rhs ))
            (match (lookup-type rhs) (
               ()
               ( () () )
               ( rt (
                  (ascript( e (->( (typeof-lhs lhs) rt)) ))
               ))
            ))
         ))
         ( (Variable v) (
            (match (typeof-var( ctx v )) (
               ()
               ( () () )
               ( tt (ascript( e tt )) )
            ))
         ))
         ( u (print-s (UnknownTerm u)) )
      )
   ))
);

parse-lambda := λtoks. (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal \,) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal \,) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (expect( \, toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

unexpect := λt. print-s (UnexpectedToken t);
expect := λt ts. ();
#expect := λt ts. if (eq( t (head ts) )) () (print-s (ExpectedToken t));

parse-one-expression := λtoks. (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Lit \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks. (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set program ( program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set program ( program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set program (program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
   program
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

reverse-list := λl. (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv. (tail(
   (local is_v)
   (local passed_char)
   (local c)
   (foreach-char v (
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_v True) (set passed_char True) ))
         ('_ ( (set is_v True) (set passed_char True) ))
         ('a ( (set is_v True) (set passed_char True) ))
         ('b ( (set is_v True) (set passed_char True) ))
         ('c ( (set is_v True) (set passed_char True) ))
         ('d ( (set is_v True) (set passed_char True) ))
         ('e ( (set is_v True) (set passed_char True) ))
         ('f ( (set is_v True) (set passed_char True) ))
         ('g ( (set is_v True) (set passed_char True) ))
         ('h ( (set is_v True) (set passed_char True) ))
         ('i ( (set is_v True) (set passed_char True) ))
         ('j ( (set is_v True) (set passed_char True) ))
         ('k ( (set is_v True) (set passed_char True) ))
         ('l ( (set is_v True) (set passed_char True) ))
         ('m ( (set is_v True) (set passed_char True) ))
         ('n ( (set is_v True) (set passed_char True) ))
         ('o ( (set is_v True) (set passed_char True) ))
         ('p ( (set is_v True) (set passed_char True) ))
         ('q ( (set is_v True) (set passed_char True) ))
         ('r ( (set is_v True) (set passed_char True) ))
         ('s ( (set is_v True) (set passed_char True) ))
         ('t ( (set is_v True) (set passed_char True) ))
         ('u ( (set is_v True) (set passed_char True) ))
         ('v ( (set is_v True) (set passed_char True) ))
         ('w ( (set is_v True) (set passed_char True) ))
         ('x ( (set is_v True) (set passed_char True) ))
         ('y ( (set is_v True) (set passed_char True) ))
         ('z ( (set is_v True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_v
));
