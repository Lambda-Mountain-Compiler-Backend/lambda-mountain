
# Static Globals

cli-config                               := ();
parse-parsed-program                     := ();
assemble-text-section                    := ();
assemble-data-section                    := ();
typecheck-subtypes                       := ();

# Static Global Initializers

typecheck-init := λ. (
   (set typecheck-subtypes 
     (
        (
           (() (Atom S))
           (Nil S)
        )
        ((Cons(S S)) S)
     )
   )
   (local mode)
);

# Cli Entry Point

main := (
   (typecheck-init())

   (local mode)
   (set mode Compile)
   (local inputs)
   (local args)
   (set args (tail argv))
   (while args (match args (
      ()
      ( (-o (tgt remainder)) (
         (set cli-config ( cli-config (Target tgt)))
         (set args remainder)
      ))
      ( (--compile remainder) (
         (set mode Compile)
         (set args remainder)
      ))
      ( (--parse remainder) (
         (set mode Parse)
         (set args remainder)
      ))
      ( (--parse-expression remainder) (
         (set mode ParseExpression)
         (set args remainder)
      ))
      ( (--tokenize remainder) (
         (set mode Tokenize)
         (set args remainder)
      ))
      ( (--typecheck remainder) (
         (set mode Typecheck)
         (set args remainder)
      ))
      ( (fp remainder) (
         (set inputs (fp inputs))
         (set args remainder)
      ))
   )))
   (while inputs (match mode (
      ()
      (Compile (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Parse (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Typecheck (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (ParseExpression (
         (print-s (parse-expression (tokenize-file (head inputs))))
         (set inputs (tail inputs))
      ))
      (Tokenize (
         (print-s (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
   )))
   (match mode (
      ()
      (Compile (assemble parse-parsed-program))
      (Parse (print-s parse-parsed-program))
      (Typecheck (print-s (show-ascript (typecheck parse-parsed-program))))
   ))
);

# Tokenizer 

tokenize-file := λpath . (
   tokenize (load-file path)
);

tokenize := λtext . (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)

   (while text ( (set char (head-string text)) (set text (tail-string text)) (match char (      
      ()

#     These characters are special characters
#     They are removed during tokenization
      (() ())
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

# Parser

parse-program := λtoks . (tail(
   (local program)
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('import (relative-path remainder)) (
            (parse-program (tokenize-file relative-path))
            (set toks remainder)
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program (parse-parsed-program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
   program
));

parse-lambda := λtoks . (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal .) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal .) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (parse-expect( . toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

parse-unexpect := λt . fail (UnexpectedToken t);
parse-expect := λt ts . ();
#parse-expect := λt ts . if (eq( t (head ts) )) () (fail (ExpectedToken t));

parse-one-expression := λtoks . (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (parse-unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (parse-expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks . (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks . (parse-many-expressions toks);

# Typechecker

typecheck := λ. ();
show-ascript := λ. ();

# Assembler

assemble := λprogram . (
   print-s program
);

# Utility Functions

fail := λmsg . (print-s msg) (exit 1);

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv . (match (head-string v) (
   ()
   ('$ True )
   ('_ True )
   ('a True )
   ('b True )
   ('c True )
   ('d True )
   ('e True )
   ('f True )
   ('g True )
   ('h True )
   ('i True )
   ('j True )
   ('k True )
   ('l True )
   ('m True )
   ('n True )
   ('o True )
   ('p True )
   ('q True )
   ('r True )
   ('s True )
   ('t True )
   ('u True )
   ('v True )
   ('w True )
   ('x True )
   ('y True )
   ('z True )
));

# Data Segments

assemble-program-break := λ. (
   '__current_break:                     \n
   \t '.zero \s '8                       \n
   '__program_break:                     \n
);


