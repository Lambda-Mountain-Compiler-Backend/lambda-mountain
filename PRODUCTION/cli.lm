
main := (
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (local config)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config (config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--compile (set mode Compile))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (--typecheck (set mode Typecheck))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Parse (foreach-atom inputs (
         if $_ (print-s (parse-program (tokenize (load-file $_)))) ()
      )))
      (Typecheck (foreach-atom inputs (
         if $_ (print-s (typecheck (parse-program (tokenize (load-file $_))))) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize (load-file $_)))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize (load-file $_))) ()
      )))
   ))
);

tokenize-file := λpath. (
   tokenize (load-file path)
);

typecheck := λprogram. program;

parse-lambda := λtoks. (tail(
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
       ()
      ((Literal \,) (
         (set lmb (Nil (parse-many-expressions toks)))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal \,) r) (
            (set lmb (lmb (parse-many-expressions r)))
            (set toks ())
         ))
         ((e ()) (
            (expect( \, toks ))
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   lmb
));

unexpect := λt. print-s (UnexpectedToken t);
expect := λt ts. ();
#expect := λt ts. if (eq( t (head ts) )) () (print-s (ExpectedToken t));

parse-one-expression := λtoks. (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set expr (Lambda (parse-lambda r)))
         (set remainder ())
      ))
      ( ( \] r ) (
         (unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Lit \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks. (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder tl)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks. (parse-many-expressions toks);

parse-program := λtoks. (tail(
   (local program)
   (local pme)
   (while toks (
      match toks (
         ()
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set program ( program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set program ((head pme) program))
            (set toks (tail pme))
         ))
      )
   ))
   program
));

tokenize := λtext. (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))
      (. (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program .))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

reverse-list := λl. (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv. (tail(
   (local is_v)
   (local passed_char)
   (local c)
   (foreach-char v (
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_v True) (set passed_char True) ))
         ('_ ( (set is_v True) (set passed_char True) ))
         ('a ( (set is_v True) (set passed_char True) ))
         ('b ( (set is_v True) (set passed_char True) ))
         ('c ( (set is_v True) (set passed_char True) ))
         ('d ( (set is_v True) (set passed_char True) ))
         ('e ( (set is_v True) (set passed_char True) ))
         ('f ( (set is_v True) (set passed_char True) ))
         ('g ( (set is_v True) (set passed_char True) ))
         ('h ( (set is_v True) (set passed_char True) ))
         ('i ( (set is_v True) (set passed_char True) ))
         ('j ( (set is_v True) (set passed_char True) ))
         ('k ( (set is_v True) (set passed_char True) ))
         ('l ( (set is_v True) (set passed_char True) ))
         ('m ( (set is_v True) (set passed_char True) ))
         ('n ( (set is_v True) (set passed_char True) ))
         ('o ( (set is_v True) (set passed_char True) ))
         ('p ( (set is_v True) (set passed_char True) ))
         ('q ( (set is_v True) (set passed_char True) ))
         ('r ( (set is_v True) (set passed_char True) ))
         ('s ( (set is_v True) (set passed_char True) ))
         ('t ( (set is_v True) (set passed_char True) ))
         ('u ( (set is_v True) (set passed_char True) ))
         ('v ( (set is_v True) (set passed_char True) ))
         ('w ( (set is_v True) (set passed_char True) ))
         ('x ( (set is_v True) (set passed_char True) ))
         ('y ( (set is_v True) (set passed_char True) ))
         ('z ( (set is_v True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_v
));
