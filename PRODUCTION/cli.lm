
# Static Globals

cli-config                               := ();
parse-parsed-program                     := ();
assemble-text-section                    := ();
assemble-data-section                    := ();
typecheck-subtypes                       := ();
typecheck-context                        := ();
typecheck-constructors                   := ();
typecheck-types-have-changed             := ();
typecheck-global-context                 := ();

# Static Global Initializers

typecheck-init := λ. (
   (set typecheck-subtypes 
     (
        (
           (() (Atom S))
           (Nil S)
        )
        ((Cons(S S)) S)
     )
   )
   (local mode)
);

# Cli Entry Point

main := (
   (typecheck-init())

   (local mode)
   (set mode Compile)
   (local inputs)
   (local args)
   (set args (tail argv))
   (while args (match args (
      ()
      ( (-o (tgt remainder)) (
         (set cli-config ( cli-config (Target tgt)))
         (set args remainder)
      ))
      ( (--compile remainder) (
         (set mode Compile)
         (set args remainder)
      ))
      ( (--parse remainder) (
         (set mode Parse)
         (set args remainder)
      ))
      ( (--parse-expression remainder) (
         (set mode ParseExpression)
         (set args remainder)
      ))
      ( (--tokenize remainder) (
         (set mode Tokenize)
         (set args remainder)
      ))
      ( (--typecheck remainder) (
         (set mode Typecheck)
         (set args remainder)
      ))
      ( (fp remainder) (
         (set inputs (fp inputs))
         (set args remainder)
      ))
   )))
   (while inputs (match mode (
      ()
      (Compile (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Parse (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Typecheck (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (ParseExpression (
         (print-s (parse-expression (tokenize-file (head inputs))))
         (set inputs (tail inputs))
      ))
      (Tokenize (
         (print-s (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
   )))
   (match mode (
      ()
      (Compile (assemble parse-parsed-program))
      (Parse (print-s parse-parsed-program))
      (Typecheck (print-s (typecheck-show-ascript (typecheck parse-parsed-program))))
   ))
);

# Tokenizer 

tokenize-file := λpath . (
   tokenize (load-file path)
);

tokenize := λtext . (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)

   (while text ( (set char (head-string text)) (set text (tail-string text)) (match char (      
      ()

#     These characters are special characters
#     They are removed during tokenization
      (() ())
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

# Parser

parse-program := λtoks . (tail(
   (local program)
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('import (relative-path remainder)) (
            (parse-program (tokenize-file relative-path))
            (set toks remainder)
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program (parse-parsed-program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
   program
));

parse-lambda := λtoks . (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal .) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal .) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (parse-expect( . toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

parse-unexpect := λt . fail (UnexpectedToken t);
parse-expect := λt ts . ();
#parse-expect := λt ts . if (eq( t (head ts) )) () (fail (ExpectedToken t));

parse-one-expression := λtoks . (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (parse-unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (parse-expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks . (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks . (parse-many-expressions toks);

# Typechecker

typecheck := λprogram . (tail(
   (local p)
   (set p program)
   (while p (
      (typecheck-infer-type-expr( (tail p) ))
      (set p (head p))
   ))
   (set typecheck-types-have-changed True)
   (while typecheck-types-have-changed (
      (set typecheck-types-have-changed ())
      (typecheck-infer-prog program)
   ))
   program
));

typecheck-lookup-type := λterm . (tail(
   (local tctx)
   (set tctx typecheck-context)
   (local found)
   (local ttt)
   (while tctx (
      (set ttt (head tctx))
      (if (is( (head ttt) term )) (
         (set found (tail ttt))
         (set tctx ())
      ) (
         (set tctx (tail tctx))
      ))
   ))
   found
));

typecheck-ascript := λt tt . (
   if tt (
      (set typecheck-context ((t tt) typecheck-context))
      (set typecheck-types-have-changed True)
   ) ()
);

typecheck-show-ascript := λp . (tail(
   (local term)
   (set term (match p (
      ()
      ( () () )
      ( Nil p )
      ( (Variable _) p )
      ( (Literal _) p )
      ( (App( f x )) (
         (App( (typecheck-show-ascript f) (typecheck-show-ascript x) ))
      ))
      ( (Lambda( lhs rhs )) (
         (Lambda( (typecheck-show-ascript lhs) (typecheck-show-ascript rhs) ))
      ))
      ( (prog (GExpr( g ))) (
         ( (typecheck-show-ascript prog) (GExpr( typecheck-show-ascript g )) )
      ))
      ( (prog (Global( n v ))) (
         ( (typecheck-show-ascript prog) (Global( n (typecheck-show-ascript v) )) )
      ))
      ( (prog (Type( tn td ))) (
         ( (typecheck-show-ascript prog) (Type( tn td )) )
      ))
      ( unknown (
         fail (UnknownTerm unknown)
      ))
   )))

   (local type)
   (set type (typecheck-lookup-type p))
   (if type (
      (if (eq( type ? )) (
         term
      ) ( 
         (:( term type ))
      ))
   ) (
      term
   ))
));

typecheck-infer-prog := λp . (
   (while p (
      (typecheck-infer-expr( typecheck-global-context (tail p) ))
      (set p (head p))
   ))
);

typecheck-infer-ctx := λctx e . (match e (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (ctx (v (typecheck-typeof-ascript tt)))
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      ( (typecheck-infer-ctx( ctx ps )) (v (typecheck-typeof-ascript tt)))
   ))
   ( (Variable v) (
      (ctx (v S))
   ))
   ( (App( ps (Variable v) )) (
      ( (typecheck-infer-ctx( ctx ps )) (v S))
   ))
   ( Nil (
      ctx
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typecheck-typeof-gvar := λv . (tail(
   (local gctx)
   (set gctx typecheck-global-context)
   (local tt)
   (while gctx (
      (match (tail gctx) (
         ()
         ( (Global( gn gt )) (
            (if (eq( v gn )) (
               (if tt (
                  (set tt (And(tt gt)) )
               ) (
                  (set tt gt)
               ))
            ) ())
            (set gctx (head gctx))
         ))
      ))
   ))
   tt
));

typecheck-typeof-var := λctx v . (match ctx (
   ()
   ( () (typecheck-typeof-gvar v) )
   ( (cs (cv ct)) (
      if (eq( v cv )) (
         ct
      ) (
         (typecheck-typeof-var( cs v ))
      )
   ))
));

typecheck-typeof-ascript := λtt . (match tt (
   ()
   ( (Literal tname) (
      tname
   ))
   ( (Variable tname) (
      tname
   ))
));

typecheck-typeof-lhs := λlhs . (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (typecheck-typeof-ascript tt)
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      (Cons( (typecheck-typeof-lhs ps) (typecheck-typeof-ascript tt) ))
   ))
   ( (Variable v) (
      S
   ))
   ( (App( ps (Variable v) )) (
      (Cons( (typecheck-typeof-lhs ps) S ))
   ))
   ( Nil (
      Nil
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typecheck-unify-sub := λctx v . (match ctx (
   ()
   ( Accept v )
   ( (Bind( s1 s2 )) (
      if (eq( v s1 )) s2 v
   ))
   ( (ctxl ctxr) (tail(
      (local lv)
      (set lv (typecheck-unify-sub( ctxl v )))
      (local rv)
      (set rv (typecheck-unify-sub( ctxr v )))
      (if (is( lv v )) (
         (if (is( rv v )) () (set v rv))
      ) (set v lv))
      v
   )))
));

typecheck-unify-ctx := λctx v . (match v (
   ()
   ( (vl vr) (
      ( (typecheck-unify-ctx( ctx vl )) (typecheck-unify-ctx( ctx vr )) )
   ))
   ( _ (
      (typecheck-unify-sub( ctx v ))
   ))
));

typecheck-unify-implies := λlt rt . (if (eq(lt rt)) True (tail(
   (local accept)
   (local subtypes)
   (local st)
   (set subtypes typecheck-subtypes)
   (while subtypes (
      (set st (tail subtypes))
      (if (eq( (head st) lt )) (
         (if (eq( (tail st) rt )) (
            (set accept True)
         ) ())
      ) ())
      (set subtypes (head subtypes))
   ))
   accept
)));

typecheck-unify-args := λlt rt . (match (lt rt) (
   ()
   ( ((lt1 rt1) (lt2 rt2)) (
      (match ( (typecheck-unify-args(lt1 lt2)) (typecheck-unify-args(rt1 rt2)) ) (
         ()
         ( (() _) () )
         ( (_ ()) () )
         ( (lctx rctx) (lctx rctx) )
      ))
   ))
   ( (a1 a2) (
      (if (typecheck-unify-implies( a2 a1 )) ( # argument type must imply parameter type
         Accept
      ) (
         (if (is-variable a1) (
            (if (is-variable a2) (
               Accept
            ) (
               (Bind( a1 a2 ))
            ))
         ) (
            (if (is-variable a2) (
               (Bind( a2 a1 ))
            ) (
               ()
            ))
         ))
      ))
   ))
   (_ (tail(
      (fail (UnknownUnify lt rt))
      ?
   )))
));

typecheck-apply-plural := λmany pt . (match many(
   ()
   ( (And( t1 t2 )) (tail(
      (local r)
      (set r (typecheck-apply-plural( t1 pt )))
      (if r r (typecheck-apply-plural( t2 pt )))
   )))
   ( (->(lt rt)) (
      (typecheck-unify-ctx( (typecheck-unify-args(lt pt)) rt ))
   ))
));

typecheck-safe-apply-plural := λterm many pt . (tail(
   (local r)
   (set r (typecheck-apply-plural( many pt )))
   (if r r (
      fail (TypeError( InvalidArgument many pt ))
   ))
));

typecheck-infer-type-compound := λcompound . (match compound (
   ()
   ((Literal tt) tt)
   ((App( lt rt )) (Cons( (typecheck-infer-type-compound lt) (typecheck-infer-type-compound rt) )))
   (u (fail (UnknownTypeCompound u)))
));

typecheck-infer-type-constructor := λname body . (match body (
   ()
   ( (Literal tag) (
      (set typecheck-constructors ( typecheck-constructors (tag tag) ))
      (set typecheck-subtypes ( typecheck-subtypes (tag (typecheck-infer-type-compound name)) ))
   ))
   ( (App( (Literal tag) args )) (
      (local ctype)
      (set ctype (typecheck-infer-type-compound args))
      (set typecheck-constructors ( typecheck-constructors (tag (->(ctype (tag ctype)))) ))
      (set typecheck-subtypes ( typecheck-subtypes ((tag ctype) (typecheck-infer-type-compound name)) ))
   ))
));

typecheck-infer-type-definition := λname def . (match def (
   ()
   ( (App( (App( tds (Literal |) )) body )) (
      (typecheck-infer-type-definition( name tds ))
      (typecheck-infer-type-constructor( name body ))
   ))
   ( body (
      (typecheck-infer-type-constructor( name body ))
   ))
));

typecheck-infer-constructor-type := λtag . (tail(
   (local ctype)
   (local constructors)
   (set constructors typecheck-constructors)
   (while constructors (
      (if (eq( tag (head(tail(constructors))) )) (
         (if ctype (
            (set ctype (And( ctype (tail(tail(constructors))) )))
         ) (
            (set ctype (tail(tail(constructors))))
         ))
      ) ())
      (set constructors (head constructors))
   ))
   ctype
));

typecheck-infer-type-expr := λe . (match e (
   ()
   ( (Type( l ds )) (
      (typecheck-infer-type-definition( l ds ))
      (typecheck-ascript( e ? ))
   ))
   (_ ())
));

typecheck-infer-expr := λctx e . (
   (if (typecheck-lookup-type e) () (
      match e (
         ()
         ( () () )
         ( (GExpr ge) (
            (typecheck-infer-expr( ctx ge ))
         ))
         ( (Global( gln gle )) (
            (typecheck-infer-expr( ctx gle ))
            (match (typecheck-lookup-type gle) (
               ()
               ( () () )
               ( glt (
                  (set typecheck-global-context ( typecheck-global-context (Global( gln glt )) ))
                  (typecheck-ascript( e ? ))
               ))
            ))
         ))
         ( (Type( l ds )) ())
         ( Nil (
            (typecheck-ascript( e Nil ))
         ))
         ( (Literal lit) (
            (local ctype)
            (set ctype (typecheck-infer-constructor-type lit))
            (if ctype (
               (typecheck-ascript( e (And( ctype Atom )) ))
            ) (
               (typecheck-ascript( e Atom ))
            ))
         ))
         ( (App( l r )) (
            (typecheck-infer-expr( ctx l ))
            (typecheck-infer-expr( ctx r ))
            (match ( (typecheck-lookup-type l) (typecheck-lookup-type r) ) (
               ()
               ( (() _) () )
               ( (_ ()) () )
               ( ( (->(lt rt)) pt ) (
                  (typecheck-ascript( e (typecheck-safe-apply-plural( e (->(lt rt)) pt )) ))
               ))
               ( ( (And(t1 t2)) pt ) (
                  (typecheck-ascript( e (typecheck-safe-apply-plural( e (And(t1 t2)) pt )) ))
               ))
               ( (lt rt) (
                  (typecheck-ascript( e (Cons(lt rt)) ))
               ))
            ))
         ))
         ( (Lambda( lhs rhs )) (
            (set ctx (typecheck-infer-ctx( ctx lhs )))
            (typecheck-infer-expr( ctx rhs ))
            (match (typecheck-lookup-type rhs) (
               ()
               ( () () )
               ( rt (
                  (typecheck-ascript( e (->( (typecheck-typeof-lhs lhs) rt)) ))
               ))
            ))
         ))
         ( (Variable v) (
            (match (typecheck-typeof-var( ctx v )) (
               ()
               ( () () )
               ( tt (typecheck-ascript( e tt )) )
            ))
         ))
         ( u (fail (UnknownTerm u)) )
      )
   ))
);

# Assembler

assemble := λprogram . (
   print-s program
);

# Utility Functions

fail := λmsg . (print-s msg) (exit 1);

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv . (match (head-string v) (
   ()
   ('$ True )
   ('_ True )
   ('a True )
   ('b True )
   ('c True )
   ('d True )
   ('e True )
   ('f True )
   ('g True )
   ('h True )
   ('i True )
   ('j True )
   ('k True )
   ('l True )
   ('m True )
   ('n True )
   ('o True )
   ('p True )
   ('q True )
   ('r True )
   ('s True )
   ('t True )
   ('u True )
   ('v True )
   ('w True )
   ('x True )
   ('y True )
   ('z True )
));

# Data Segments

assemble-program-break := λ. (
   '__current_break:                     \n
   \t '.zero \s '8                       \n
   '__program_break:                     \n
);


