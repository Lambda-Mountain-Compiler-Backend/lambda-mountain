
# Dependencies

import STDLIB/default-cons-allocator.lm;
import STDLIB/default-atom-allocator.lm;

import PRODUCTION/utility.lm;
import PRODUCTION/tokenize.lm;
import PRODUCTION/parse.lm;
import PRODUCTION/preprocess.lm;
import PRODUCTION/typecheck.lm;
import PRODUCTION/expression.lm;
import PRODUCTION/codegen-dynamic.lm;
import PRODUCTION/codegen-strict.lm;
import PRODUCTION/assemble.lm;

# Static Globals

config-nostd                             := ();
config-strict                            := ();
cli-config                               := ();

# Cli Entry Point

main := (
   (local inputs)
   (local args)

   (typecheck-init())

   (local mode)
   (set mode Compile)

   (set args (tail argv))

   (while args (match args (
      ()
      ( ('-o (tgt remainder)) (
         (set cli-config ( cli-config (Target tgt)))
         (set args remainder)
      ))
      ( ('--compile remainder) (
         (set mode Compile)
         (set args remainder)
      ))
      ( ('--strict remainder) (
         (set config-strict True)
         (set args remainder)
      ))
      ( ('--parse remainder) (
         (set mode Parse)
         (set args remainder)
      ))
      ( ('--nostd remainder) (
         (set config-strict True)
         (set config-nostd True)
         (set args remainder)
      ))
      ( ('--parse-expression remainder) (
         (set mode ParseExpression)
         (set args remainder)
      ))
      ( ('--tokenize remainder) (
         (set mode Tokenize)
         (set args remainder)
      ))
      ( ('--typecheck remainder) (
         (set mode Typecheck)
         (set args remainder)
      ))
      ( (fp remainder) (
         (set inputs (fp inputs))
         (set args remainder)
      ))
      ( u (
         fail (UnexpectionCommand u)
      ))
   )))

   (while inputs (match mode (
      ()
      (Compile (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Parse (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Typecheck (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (ParseExpression (
         (print-s (parse-expression (tokenize-file (head inputs))))
         (set inputs (tail inputs))
      ))
      (Tokenize (
         (print-s (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (u (
         (fail (UnknownMode u))
      ))
   )))

   (set parse-parsed-program (parse-apply-macros parse-parsed-program))
   (if config-strict (typecheck parse-parsed-program) ())

   (match mode (
      ()
      (Compile (assemble parse-parsed-program))
      (Parse (print-s parse-parsed-program))
      (Typecheck (print-s (typecheck-show-ascript (typecheck parse-parsed-program))))
   ))
);

# Tokenizer 

tokenize-file := λpath . (match path (
   ()
   (() ())
   ((_ _) ())
   (fp (tokenize (load-file fp)))
));


tokenize := λtext . (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)

   (while text (
      (set char (head-string text))
      (set text (tail-string text))
   (match char (      
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

merge-list := λl r . (tail( if l (
   (while r (
      (set l (l (tail r)))      
      (set r (head r))
   ))
   l
) r ));

substitute-macro-body := λkvs e . (match e (
   ()
   ((Variable n) (tail(
      (while kvs (match kvs (
         ()
         ( Accept (set kvs ()) )
         ( (ks Accept) (set kvs ks) )
         ( (ks ()) (set kvs ks) )
         ( (ks (KV(k v))) (
            (if (eq(n k)) (
               (set e v)
               (set kvs ())
            ) (
               (set kvs ks)
            ))
         ))
         ( u (fail (UnrecognizedKVMacro kvs)))
      )))
      e
   )))
   ( () () )
   ( (vl vr) (
      (substitute-macro-body( kvs vl ))
      (substitute-macro-body( kvs vr ))
   ))
   ( v v )
));

try-destructure-macro := λlhs e . (match (lhs e) (
   ()
   ( ( Nil Nil ) Accept )
   ( ( (App(pl pr)) (App(el er)) ) (tail(
      (local ll)
      (set ll (try-destructure-macro(pl el)))
      (local rl)
      (set rl (try-destructure-macro(pr er)))
      (if ll (
         (if rl (
            (merge-list( ll rl ))
         ) ())
      ) ())
   )))
   ( ((Literal pl) (Variable el)) (
      (if (eq( pl el )) Accept ())
   ))
   ( ((Literal pl) (Literal el)) (
      (if (eq( pl el )) Accept ())
   ))
   ( ( (App( (Literal :Literal:) (Variable pv) )) (Literal el)) (
      (Accept (KV( pv e )))
   ))
   ( ( (App( (Literal :Variable:) (Variable pv) )) (Variable el)) (
      (Accept (KV( pv e )))
   ))
   ( ((Variable pv) e) (
      (Accept (KV( pv e )))
   ))
));

is-suffix := λs suff . (tail(
   (local match)
   (while s (
      (if (eq( s suff )) (set match True) ())
      (set s (tail-string s))
   ))
   match
));

remove-suffix := λs suff . (tail(
   (local prefix)
   (while s (
      (if (eq( s suff )) (
         (set s ())
      ) (
         (set prefix (prefix (clone-rope (head-string s))))
         (set s (tail-string s))
      ))
   ))
   (clone-rope prefix)
));

define-calling-convention-s := λ ctx fname lmb . (tail(
   ()
   (match lmb (
      ()
      ( (Lambda( lhs rhs )) (tail(
         (local e1)
         (local e2)
         (local text)
         (set e1 (destructure-args(ctx lhs ())))
         (set e2 (compile-expr((get-pc e1) rhs (get-offset e1) Used)))
         (set text ( text (mangle-global-function( fname lmb )) ': \n ))
         (set text ( text (enter-function()) ))
         (set text ( text (get-frame e1) (get-frame e2) ))
         (set text ( text (get-prog e1) (get-prog e2) ))
         (set text ( text (exit-function()) ))
         (set text ( text (get-text e1) (get-text e2) ))
         (Expr(
            () () () text ( (get-data e1) (get-data e2) ) () ()
         ))
      )))
   ))
));

define-sizeof-type := λ tt . (tail(
   (local eight)
   (set eight (inc(inc(inc(inc
              (inc(inc(inc(inc ()
              )))) )))) )
   (match tt (
      ()
      (I8 (inc()) )
      (U8 (inc()) )
      (I16 (inc(inc())) )
      (U16 (inc(inc())) )
      (I32 (inc(inc(inc(inc())))) )
      (U32 (inc(inc(inc(inc())))) )
      (I64 eight )
      (U64 eight )
      (u (fail (UnknownSizeof tt)))
   ))
));

define-calling-convention-stack-destructure-args := λ ctx lhs offset . (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable lname) )) ltype )) (tail(
      (set ltype (typecheck-infer-type-compound ltype))
      (local size)
      (set size (define-sizeof-type ltype))
      (local new_offset)
      (set new_offset (add( offset (define-sizeof-type ltype) )) )
      (Expr(
         () () () () ()
         ( ctx (StackVariable(
            lname (i2s (add( offset (mul( (dec()) size )) )) ) ltype
         )) )
         (i2s new_offset)
      ))
   )))
   ( (App( more (App( (App( (Literal :) (Variable lname) )) ltype )) )) (tail(
      (set ltype (typecheck-infer-type-compound ltype))
      (local size)
      (set size (define-sizeof-type ltype))
      (local new_offset)
      (set new_offset (add( offset (mul( (dec()) (define-sizeof-type ltype) )) )) )
      (set ctx (define-calling-convention-stack-destructure-args( ctx more new_offset )))
      (Expr(
         () () () () ()
         ( (get-pc ctx) (StackVariable(
            lname (i2s (add( offset (mul( (dec()) size )) )) ) ltype
         )) )
         (get-offset ctx)
      ))
   )))
   ( u (fail (UnknownStackArg lhs)))
));

define-calling-convention-stack := λ ctx fname lmb . (tail(
   ()
   (match lmb (
      ()
      ( (Lambda( lhs rhs )) (tail(
         (local e1)
         (local e2)
         (local text)
         (set e1 (define-calling-convention-stack-destructure-args( ctx lhs () )))
         (set e2 (compile-expr( (get-pc e1) rhs (get-offset e1) Used)))
         (set text ( text (mangle-global-function( fname lmb )) ': \n ))
         (set text ( text (get-frame e2) ))
         (set text ( text (get-prog e2) ))
         (set text ( text (\t 'ret \n) ))
         (set text ( text (get-text e2) ))
         (Expr(
            () () () text ( (get-data e2) ) () ()
         ))
      )))
   ))
));

apply-calling-convention-stack := λ ctx e fname arg offset used . (tail(
   (local e1)
   (match (get-maybe-function(ctx fname (typecheck-lookup-type arg))) (
      ()
      ( (GlobalFunction mangledname) (tail(
         (set e1 (destructure-calling-convention-stack( ctx e fname arg offset used )))
         (Expr(
            (get-frame e1)
            ( (enter-function()) (get-prog e1) (\t 'call \s mangledname \n)
              (\t 'mov \s '%rbp, \s '%rsp               \n
               \t 'pop \s '%rbp                        \n) )
            (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1)
         ))
      )))
      ( (Fragment( vname body )) (tail(
         ()
         (assemble-apply-fragment( ctx body arg offset ))
      )))
      ( (StackVariable _) (tail(
         (set e1 (compile-expr( ctx arg offset used )))
         (local l)
         (set l (get-local( ctx fname )))
         (if l () (fail (UnknownFunctionLocal fname)))
         (Expr( (get-frame e1) (l (get-prog e1)) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( l (fail (UnknownFunctionCall fname l)) )
   ))
));

destructure-push-stack := λ ctx arg offset . (match arg (
   ()
   ( (App( (App( (Variable 'as) inner_arg )) tt )) (
      (match (get-maybe-function(ctx 'push (typecheck-lookup-type inner_arg))) (
         ()
         ( (Fragment( (Variable _) body )) (
            (assemble-apply-fragment( ctx body inner_arg offset ))
         ))
         ( v (
            (fail (ReferenceToUndefinedVariable 'push (typecheck-lookup-type arg)))
         ))
      ))
   ))
   ( _ (
      (match (get-maybe-function(ctx 'push (typecheck-lookup-type arg))) (
         ()
         ( (Fragment( (Variable _) body )) (
            (assemble-apply-fragment( ctx body arg offset ))
         ))
         ( v (
            (fail (ReferenceToUndefinedVariable 'push (typecheck-lookup-type arg)))
         ))
      ))
   ))
));

destructure-calling-convention-stack := λ ctx e fname arg offset used . (tail(
   ()
   (match (typecheck-lookup-type arg) (
      ()
      ( (Cons( t1 t2 )) (
         (match arg (
            ()
            ( (App( e1 e2 )) (tail(
               (set e1 (destructure-calling-convention-stack( ctx e fname e1 offset used )))
               (set e2 (destructure-calling-convention-stack( (get-pc e1) e fname e1 (get-offset e2) used )))
               (Expr(
                  ((get-frame e1) (get-frame e1))
                  ((get-prog e1) (get-prog e1))
                  ((get-unframe e1) (get-unframe e1))
                  ((get-text e1) (get-text e1))
                  ((get-data e1) (get-data e1))
                  (get-pc e2)
                  (get-offset e2)
               ))
            )))
            ( v (
               (fail (InvalidParameter fname arg))
            ))
         ))
      ))
      ( t1 (destructure-push-stack( ctx arg offset )) )
   ))
));

apply-calling-convention-s := λ ctx e fname arg offset used . (tail(
   (local e1)
   (local prog)
   (if (is-builtin fname) (tail(
      ()
      (if (eq(fname 'tail)) (tail(
         (set e1 (compile-expr(ctx arg offset Tail)))
         (Expr( (get-frame e1) (get-prog e1) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )) (tail(
         (set e1 (compile-expr(ctx arg offset Used)))
         (set prog ((get-prog e1) (\t 'call \s (label-case fname) \n)))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
   )) (tail(
      ()
      (match (get-maybe-function(ctx fname (typecheck-lookup-type arg))) (
         ()
         ( (GlobalFunction mangledname) (tail(
            (set e1 (compile-expr(ctx arg offset Used)))
            (set prog ((get-prog e1) (\t 'call \s mangledname \n)))
            (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
         )))
         ( (Fragment( (Variable _) body )) (
            (assemble-apply-fragment( ctx body arg offset ))
         ))
         ( () (
            (fail (ReferenceToUndefinedVariable fname (typecheck-lookup-type arg)))
         ))
         ( v (tail(
            ()
            (yield-cons(ctx v arg e offset Used))
         )))
      ))
   )))
));

# Utility Functions

fail := λmsg . (print-s msg) (exit 1);

deep-eq := λl r . match (l r) (
   ()
   ( (() ()) True )
   ( ((ll lr) (rl rr)) (
      if (deep-eq( ll rl )) (
         (deep-eq( lr rr ))
      ) ()
   ))
   ( (la ra) (eq( la ra )) )
);

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

label-case := λk . (match k (
   ()
   (() ())
   ((l r) ('_ (label-case l) (label-case r) '_))
   (a (label-case-atom a))
));

label-case-atom := λk . (tail(
   (local nk)
   (while k (match (head-string k) (
      ()
      (() ())
      ('- (
         (set nk (nk '_))
         (set k (tail-string k))
      ))
      (': (
         (set nk (nk '_C_))
         (set k (tail-string k))
      ))
      ('< (
         (set nk (nk '_LB_))
         (set k (tail-string k))
      ))
      ('> (
         (set nk (nk '_RB_))
         (set k (tail-string k))
      ))
      (\[ (
         (set nk (nk '_LP_))
         (set k (tail-string k))
      ))
      (\] (
         (set nk (nk '_RP_))
         (set k (tail-string k))
      ))
      ('$ (
         (set nk (nk '_DS_))
         (set k (tail-string k))
      ))
      (c (
         (set nk (nk (clone-rope c)))
         (set k (tail-string k))
      ))
   )))
   (clone-rope nk)
));

is-variable := λv . (match (head-string v) (
   ()
   ('@ True )
   ('? True )
   ('! True )
   ('= True )
   ('> True )
   ('< True )
   ('/ True )
   ('* True )
   ('+ True )
   ('- True )
   ('$ True )
   ('_ True )
   ('a True )
   ('b True )
   ('c True )
   ('d True )
   ('e True )
   ('f True )
   ('g True )
   ('h True )
   ('i True )
   ('j True )
   ('k True )
   ('l True )
   ('m True )
   ('n True )
   ('o True )
   ('p True )
   ('q True )
   ('r True )
   ('s True )
   ('t True )
   ('u True )
   ('v True )
   ('w True )
   ('x True )
   ('y True )
   ('z True )
));

get-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s '%r15 \n
                     \t 'mov \s '0 \[ '%r15 \] , \s '%r12     \n
                     \t 'mov \s '8 \[ '%r15 \] , \s '%r13     \n
                  ))
               ) ()
            )
         ))
         ( (StackVariable( l offset ltype )) (
            if r () (
               if (eq(l v)) (
                  (local size)
                  (set size (i2s (define-sizeof-type ltype)))
                  # register allocation = '%r12, '%r13 only for now
                  (local dst)
                  (match size (
                     ()
                     (1 (set dst ( R12B (Constant Reg8) )))
                     (2 (set dst ( R12W (Constant Reg16) )))
                     (4 (set dst ( R12D (Constant Reg32) )))
                     (8 (set dst ( R12 (Constant Reg64) )))
                     (u (fail (InvalidStackVariableSize u)))
                  ))
                  (local arg_type)
                  (set arg_type (Cons( (Constant Offset) (tail dst) )))
                  (match (get-maybe-function( ctx 'get arg_type )) (
                     ()
                     ( (Fragment( fname body )) (tail(
                        (local arg)
                        (set arg (
                           (App(
                               (App( (App( (Literal :) (Literal offset) ))
                                  (App( (Literal Constant) (Literal Offset) ))
                               ))
                               (App( (App( (Literal :) (Literal (head dst)) )) (Literal (tail dst)) ))
                           ))
                        ))
                        (set r (get-prog (assemble-apply-fragment( ctx body arg () ))))
                     )))
                     (u (fail (UndefinedStackGetter 'get arg_type u)))
                  ))
               ) ()
            )
         ))
         ( (GlobalFunction( _ _ )) () )
         ( (Fragment( _ _ )) () )
         ( (Label( l luid )) (
            if r () (
               if (eq(l v)) (
                  (set r luid)
               ) ()
            )
         ) )
         ( u (
            (fail (InvalidLocal u))
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (ReferenceToUndefinedVariable v))
   ))
   r
));

set-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local((Set l) lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s '%r15 \n
                     \t 'mov \s '%r12 , \s '0 \[ '%r15 \] \n
                     \t 'mov \s '%r13 , \s '8 \[ '%r15 \] \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (AssignToUndefinedVariable v))
   ))
   r
));

get-frame := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

mangle-global-function := λname body . (
   (clone-rope (label-case ( name : (typecheck-lookup-type body) )))
);

get-fragment-local := λctx v offset . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Label(l uid)) (
            if r () (
               if (eq(l v)) (
                  (set r (Expr(
                     () uid () () () ctx offset
                  )))
               ) ()
            )
         ))
         ( (StackVariable(l loffset ltype)) (
            if r () (
               if (eq(l v)) (
                  (set r (Expr(
                     () loffset () () () ctx offset
                  )))
               ) ()
            )
         ))
         ( _ () )
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (ReferenceToUndefinedFragmentVariable v))
   ))
   r
));

get-maybe-function := λctx v arg_type . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r (Variable l))
               ) ()
            )
         ))
         ( (Fragment( (Variable name) body )) (tail(
            ()
            (if r () (
               if (eq(name v)) (
                  (if config-strict (
                     (if (typecheck-apply-plural( (typecheck-lookup-type body) arg_type )) (
                        (set r (Fragment( (Variable name) body )))
                     ) ())
                  ) (
                     (set r (Fragment( (Variable name) body )))
                  ))
               ) ()
            ))
         )))
         ( (GlobalFunction( name body )) (tail(
            ()
            (if r () (
               if (eq(name v)) (
                  (if config-strict (
                     (if (typecheck-apply-plural( (typecheck-lookup-type body) arg_type )) (
                        (set r (GlobalFunction (mangle-global-function( name body ))))
                     ) ())
                  ) (
                     (set r (GlobalFunction (mangle-global-function( name body ))))
                  ))
               ) ()
            ))
         )))
         ( (GlobalVariable name) (
            if r () (
               if (eq(name v)) (
                  (set r (GlobalVariable (label-case name)))
               ) ()
            )
         ))
         ( (StackVariable(name offset type)) (
            if r () (
               if (eq(name v)) (
                  (set r (StackVariable( name offset type )))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   r
));

declare-local := λctx vname offset . (tail(
   (local frame_this)
   (set frame_this (push-zero()))
   (local refer)
   (local eight)
   (set eight (
      inc(inc(inc(inc(inc(inc(inc(inc(
         ()
      ))))))))
   ))
   (local sixteen)
   (set sixteen (mul( eight (inc(inc(()))) )))
   (local set_this)
   (set set_this (
      \t 'mov \s '%r12, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r13, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] \n
   ))
   (set refer (
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] , '%r12 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] , '%r13 \n
   ))
   (set ctx (ctx (Local(vname refer)) ))
   (set ctx (ctx (Local((Set vname) set_this)) ))
   (Expr(frame_this set_this () () () ctx (inc offset)))
));

i2s := λi . (tail(
   (local ten)
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (local sign)
   (local s)
   (local r)
   (if (is-neg i) (
      (set sign '-)
      (set i (inv i))
   ) ())
   (while i (
      (set r (mod(i ten)))
      (set s ((clone-rope(digit r) s)))
      (set i (div(i ten)))
   ))
   (if s () (set s 0))
   (clone-rope (sign s))
));

s2i := λs . (tail(
   (local i)
   (local is_neg)
   (local one)
   (local two)
   (local three)
   (local four)
   (local five)
   (local six)
   (local seven)
   (local eight)
   (local nine)
   (local ten)
   (set one( inc() ))
   (set two( inc(inc( )) ))
   (set three( inc(inc(inc( ))) ))
   (set four( inc(inc(inc(inc( )))) ))
   (set five( inc(inc(inc(inc(inc( ))))) ))
   (set six( inc( inc(inc(inc(inc(inc( ))))) ) ))
   (set seven( inc(inc( inc(inc(inc(inc(inc( ))))) )) ))
   (set eight( inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))) ))
   (set nine( inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) )))) ))
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (if (eq( (head-string s) '- )) (
      (set is_neg True)
      (set s (tail-string s))
   ) ())
   (while s (
      (set i (mul( i ten )))
      (match (head-string s) (
         ()
         ('0 ())
         ('1 (set i (add( i one )))) 
         ('2 (set i (add( i two )))) 
         ('3 (set i (add( i three )))) 
         ('4 (set i (add( i four )))) 
         ('5 (set i (add( i five )))) 
         ('6 (set i (add( i six )))) 
         ('7 (set i (add( i seven )))) 
         ('8 (set i (add( i eight ))))          
         ('9 (set i (add( i nine ))))          
         (u (fail (InvalidDigit u)))
      ))
      (set s (tail-string s))
   ))
   (if is_neg (
      (mul( (dec()) i ))
   ) i )
));

destructure-args := λctx e offset . (match e (
   ()
   ( Nil (tail(
      ()
      (Expr( () () () () () ctx offset ))
   )))
   ( (App( (App( (Literal :) (Variable n) )) nt )) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( (Variable n) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( ( (App( h t )) ) (tail(
      (local ta)
      (set ta (destructure-args(ctx t offset)))
      (set offset (get-offset ta))
      (set ctx (get-pc ta))
      (local ha)
      (set ha (destructure-args(ctx h offset)))
      (set offset (get-offset ha))
      (set ctx (get-pc ha))
      (local prog)
      (set prog (prog (push-this()) ))
      (set prog (prog (\t 'call \s 'tail \n) ))
      (set prog (prog (get-prog ta) ))
      (set prog (prog (pop-this()) ))
      (set prog (prog (\t 'call \s 'head \n) ))
      (set prog (prog (get-prog ha) ))
      (Expr(
         ( (get-frame ta) (get-frame ha) )
         prog
         ( (get-unframe ta) (get-unframe ha) )
         () () ctx offset
      ))
   )))
   ( _ (
      (fail (InvalidFunctionParameters DidYouForgetToSeparateADotTokenInFunctionParam? e))
   ))
));

# Data Segments

stdlib-data := λ .(
  'load_file_bsz:                         \n
  \t '.quad \s '1024                      \n
  'load_file_buf:                         \n
  \t '.zero \s '1024                      \n
  'argv:                                  \n
  \t '.zero \s '16                        \n
  'nil_literal:                           \n
  \t '.ascii \s " \[ \] "                 \n
  \t '.zero \s 1                          \n
  'newline:                               \n
  \t '.ascii \s " \\n "                   \n
  'left_paren:                            \n
  \t '.ascii \s " \[ "                    \n
  'right_paren:                           \n
  \t '.ascii \s " \] "                    \n
  'space:                                 \n
  \t '.ascii \s " \s "                    \n
  'true:                                  \n
  \t '.ascii \s "True"                    \n
  \t '.zero \s '1                         \n
  '__digit:                               \n
  \t '.zero \s '2                         \n
  'hex_buffer:                            \n
  \t '.ascii \s "0123456789abcdef"        \n
  '__mutable_char:                        \n
  \t '.zero \s '2                         \n
  '__dump_i:                              \n
  \t '.ascii \s '"0000000000000000"       \n
  \t '.zero \s '1                         \n
  'err_fopen:                             \n
  \t '.ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t '.zero \s '1                         \n
);

stdlib-functions := λ . (
   'print_s:                           \n
   # if .head is zero, then this is Nil
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s 'print_s_nil              \n

   # if only .tail is zero, then this is an Atom
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'print_s_atom             \n

   # if .head and .tail are non-zero, then this is a Cons
   (system-call( '$1 '$1 '$left_paren '$1 ))
   (push-this())
   \t 'call \s 'head                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$space '$1 ))
   (push-this())
   \t 'call \s 'tail                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$right_paren '$1 ))
   \t 'ret                             \n

   'print_s_nil:                       \n
   # nil is two bytes "()" located in the data section at $nil_literal
   (system-call( '$1 '$1 '$nil_literal '$2 ))
   \t 'ret                             \n

   'print_s_atom:                      \n
   \t 'call \s 'strlen                 \n # '%r8 is string length of this atom
   (system-call( '$1 '$1 '%r12 '%r8 )) \n
   \t 'ret                             \n

   'is_atom:                              \n
   \t 'cmp \s '$0, '%r12                  \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, '%r13                  \n
   \t 'jne \s 'return_nil                 \n
   \t 'jmp \s 'return_true                \n

   'is_cons:                              \n
   \t 'cmp \s '$0, '%r12                  \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, '%r13                  \n
   \t 'je \s 'return_nil                  \n
   \t 'jmp \s 'return_true                \n

   'head_string:                          \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'movb \s '0 \[ '%r12 \] , \s '%bl   \n
   \t 'mov \s '$__mutable_char, \s '%r12  \n
   \t 'movb \s '%bl, \s '0 \[ '%r12 \]    \n
   \t 'ret                                \n

   'tail_string:                          \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'inc \s '%r12                       \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'ret                                \n

   'head:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
   \t 'ret                                \n

   'tail:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
   \t 'ret                                \n

   'strlen:                               \n
   \t 'xor \s '%r8, \s '%r8               \n
   \t 'mov \s '%r12, \s '%rax             \n
   'strlen_loop:                          \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]     \n
   \t 'jz \s 'strlen_exit                 \n
   \t 'inc \s '%r8                        \n
   \t 'inc \s '%rax                       \n
   \t 'jmp \s 'strlen_loop                \n
   'strlen_exit:                          \n
   \t 'ret                                \n

   'streq:                                \n
   'streq_loop:                           \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%rax \] , \s '%cl    \n
   \t 'mov \s '0 \[ '%rbx \] , \s '%dl    \n

   \t 'cmp \s '%cl, \s '%dl               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%cl                \n
   \t 'je \s 'streq_true                  \n
   \t 'inc \s '%rax                       \n
   \t 'inc \s '%rbx                       \n
   \t 'jmp \s 'streq_loop                 \n
   'streq_true:                           \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'eq:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'call \s 'streq                     \n
   \t 'ret                                \n

   'return_nil:                           \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'return_true:                          \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'not:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jne \s 'not_yield_nil              \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
   'not_yield_nil:                        \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'clone_rope:                           \n
   \t 'mov \s '$0, \s '%r8                \n
   \t 'mov \s '$0, \s '%r9                \n
   (allocate-atom-grow '$0)
   \t 'call \s '__clone_rope              \n
   (allocate-atom-grow '$1)
   \t 'movb \s '$0, \s '0 \[ '%r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   '__clone_rope:                         \n
   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s '__clone_rope_notcons        \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'mov \s '8 \[ '%r12 \] , '%r13      \n
   \t 'mov \s '0 \[ '%r12 \] , '%r12      \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'mov \s '0 \[ '%r13 \] , '%r12      \n
   \t 'mov \s '8 \[ '%r13 \] , '%r13      \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'jmp \s '__clone_rope_end           \n

   #if not cons, concat
   '__clone_rope_notcons:                 \n

   #if nil, return
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s '__clone_rope_end            \n

   #if atom, break into characters and concat
   '__clone_rope_small:                   \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s '__clone_rope_end            \n
   (allocate-atom-grow '$1)
   \t 'movb \s '0 \[ '%r12 \] , \s '%bl   \n
   \t 'movb \s '%bl, \s '0 \[ '%r9 \]     \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r12                       \n
   \t 'jmp \s '__clone_rope_small         \n

   '__clone_rope_end:                     \n
   \t 'ret                                \n

   'is:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'is_neg:                               \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jge \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'inc:                                  \n
   \t 'inc \s '%r12                       \n
   \t 'ret                                \n

   'dec:                                  \n
   \t 'dec \s '%r12                       \n
   \t 'ret                                \n

   'inv:                                  \n
   \t 'neg \s '%r12                       \n
   \t 'ret                                \n

   'mul:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'imul \s '%rax, \s '%rbx            \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'add:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'add \s '%rax, \s '%rbx             \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'div:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'ret                                \n

   'mod:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rdx, \s '%r12             \n
   \t 'ret                                \n

   'dump_i:                               \n
   \t 'mov \s '%r12, \s '%r8              \n
   \t 'mov \s '$__dump_i, \s '%r12        \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$__dump_i, \s '%r11        \n
   \t 'cmp \s '$0, \s '%r8                \n
   \t 'jge \s 'dump_i_positive            \n
   \t 'jmp \s 'dump_i_negative            \n
   'dump_i_positive:                      \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$48, \s '0 \[ '%r11 \]    \n
   \t 'ret                                \n
   'dump_i_negative:                      \n
   \t 'neg \s '%r8                        \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$45, \s '0 \[ '%r11 \]    \n
   \t 'ret                                \n
   # if return value is positive then open was a success

   'dump_i_digits:                        \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[0]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '0 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[1]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '1 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[2]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '2 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[3]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '3 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[4]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '4 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[5]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '5 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[6]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '6 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[7]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '7 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[8]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '8 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[9]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '9 \[ '%r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[10]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '10 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[11]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '11 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[12]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '12 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[13]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '13 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[14]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '14 \[ '%r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # '%r8[15]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '15 \[ '%r11 \]     \n
   \t 'ret                                \n

   #move ascii representation of lower byte of '%r8 into '%cl
   'put8:                                 \n
   \t 'mov \s '%r8b, \s '%al              \n # lower byte of '%r11 goes into '%rax
   \t 'and \s '$0xf, \s '%al              \n # only show lower 4 bits
   \t 'mov \s '$hex_buffer, '%r10         \n # '%r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b             \n # '%r10 is index into char in hex buffer
   \t 'mov \s '0 \[ '%r10 \] , \s '%cl     \n # '%cl is a hexadecimal char
   \t 'ret                                \n

   'digit:                                \n
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'add \s '$48, \s '%rax               \n
   \t 'mov \s '$__digit, \s '%r12          \n
   \t 'mov \s '%al, \s '0 \[ '%r12 \]      \n
   \t 'mov \s '$0, \s '%r13                \n
   \t 'ret                                \n

   'write_file:                           \n
   #open file
   \t 'mov \s '0 \[ '%r12 \] , \s '%rdi    \n # file name
   \t 'pushq \s '0 \[ '%r13 \]             \n # data to write
   \t 'mov \s '$2, \s '%rax               \n # syscall open
   \t 'mov \s '$577, \s '%rsi              \n
   \t 'mov \s '$420, \s '%rdx             \n # mode
   \t 'syscall                            \n
   \t 'mov \s '%rax, \s '%r8              \n # r8 now holds file descriptor

   #write to file
   \t 'pop \s '%rax                       \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'mov \s '%r8, \s '%r10              \n # '%r10 has file descriptor
   \t 'call \s 'strlen                    \n
   (system-call( '$1 '%r10 '%r12 '%r8 ))

   #close file
   (system-call( '$3 '%r10 '$0 '$0 ))
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file:                            \n

   # open file
   (system-call( '$2 '%r12 '$0 '$0 ))
   # file descriptor is in '%rax

   \t 'cmp \s '$0, \s '%rax               \n
   # if return value is positive then open was a success
   \t 'jge \s 'load_file_contents         \n

   \t 'mov \s '$err_fopen, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file_contents:                   \n
   \t 'mov \s '$0, \s '%r8                \n
   \t 'mov \s '$0, \s '%r9                \n
   (allocate-atom-grow '$0)
   # r8 holds pointer to head of new data
   # r9 holds pointer to tail of new data
   \t 'mov \s '$0, \s '%r10               \n # r10 holds amount of data on buffer currently
   \t 'mov \s '$load_file_buf, \s '%r11   \n # r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:                       \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'je \s 'load_file_bufempty          \n
   (allocate-atom-grow '$1)
   \t 'movb \s '0 \[ '%r11 \] , \s '%bl    \n
   \t 'mov \s '%bl, \s '0 \[ '%r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r11                       \n
   \t 'dec \s '%r10                       \n
   \t 'jmp \s 'load_file_loop             \n

   # read file
   'load_file_bufempty:                   \n
   \t 'push \s '%rax                      \n
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'mov \s '$load_file_bsz, \s '%rdx   \n
   \t 'mov \s '0 \[ '%rdx \] , \s '%rdx   \n
   (system-call( '$0 '%r10 '$load_file_buf () ))
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'pop \s '%rax                       \n
   \t 'mov \s '$load_file_buf, \s '%r11   \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'jne \s 'load_file_loop             \n

   # close file
   (system-call( '$3 '%rax '$0 '$0 ))
   (allocate-atom-grow '$1)
   \t 'movb \s '$0, \s '0 \[ '%r9 \]       \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
);

inline-head := λ . (
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
);

inline-tail := λ . (
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
);

enter-function := λ .(
   \t 'push \s '%rbp                       \n
   \t 'mov \s '%rsp, \s '%rbp               \n
);

exit-function := λ .(
   \t 'mov \s '%rbp, \s '%rsp               \n
   \t 'pop \s '%rbp                        \n
   \t 'ret                                \n
);

push-this := λ .(
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
);

push-zero := λ .(
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
);

pop-this := λ .(
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
);

yield-nil := λ . (
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
);

yield-cons-s := λctx l r ce offset used . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local rused)
   (match used (
      ()
      ( Used (tail(
         (set e1 (compile-expr( ctx l offset Used )))
         (set offset (get-offset e1))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
         (set offset (get-offset e2))
         (set prog (prog (get-prog e1)))
         (set prog (prog (push-this())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (close())))
         (set prog (prog (pop-this())))
         (set prog (prog (\t 'push \s '%r8 \n)))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r8, \s '%r12 \n)))
         (set prog (prog (\t 'pop \s '%r13 \n)))
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( _ (tail(
         (set rused ( if (eq(used Tail)) Used Unused ))
         (set e1 (compile-expr( ctx l offset Unused )))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) rused )))
         (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
   ))
));

yield-cons := λctx l r ce offset used . (tail(
   (local e1)
   (local e2)
   (if config-strict (tail(
      (local typel)
      (set typel (typecheck-lookup-type l))
      (local typer)
      (set typer (typecheck-lookup-type r))
      (local typece)
      (set typece (typecheck-lookup-type ce))
      (match (typel typer typece) (
         ()
         ( (_ Fragment _) (tail(
            (set e1 (compile-expr( ctx l offset Used )))
            (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
            (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
         )))
         ( (Fragment _ _) (tail(
            (set e1 (compile-expr( ctx l offset Used )))
            (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
            (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
         )))
         ( (_ _ _) (tail(
            ()
            (yield-cons-s( ctx l r ce offset used ))
         )))
      ))
   )) (
      (yield-cons-s( ctx l r ce offset used ))
   ))
));

yield-atom-cache := ();
yield-atom := λctx a offset . (tail(
   (local cache)
   (set cache yield-atom-cache)
   (local id)
   (local data)
   (while cache (
      (if (eq( (head (head cache)) a )) (
         (set id (tail (head cache)))
      ) ())
      (set cache (tail cache))
   ))
   (if id () (
      (set id (uuid()))
      (set data (id ': \n \t '.ascii \s " (escape-sequences a) " \n \t '.zero \s 1 \n))
      (set yield-atom-cache ((a id) yield-atom-cache))
   ))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
      )
      ()
      ()
      data
      ctx
      offset
   ))
));

$uuid := ();
uuid := λ . (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

escape-sequences := λt . match t (
   ()
   ( () () )
   ( \\ \\\\ )
   ( \\: \: )
   ( \\o \o )
   ( \\n (\\ 'n))
   ( \\t \t )
   ( \\s \s )
   ( \\l \l )
   ( \\[ \[ )
   ( \\] \] )
   ( (l r) ( (escape-sequences l) (escape-sequences r) ) )
   ( s (tail(
      (local c)
      (local cs)
      (local is_escape)
      (while s (
         (set c (head-string s))
         (set s (tail-string s))
         (match c (
            ()
            ( " (
               (set cs (cs \\ "))
               (set is_escape ())
            ))
            (\\ (
               (if is_escape (
                 (set cs ( cs \\\\ ))
                 (set is_escape ())
               ) (set is_escape True))
            ))
            (_ (
               (if is_escape (
                  (match c (
                     ()
                     ( , (set cs (cs .)))
                     ( _ (fail( InvalidEscapeCharacter (c s) )))
                  ))
               ) (set cs (cs (clone-rope c))))
               (set is_escape ())
            ))
         ))
      ))
      (clone-rope cs)
   )))
);

close := λe . (
   e
   (allocate-cons ())
   (\t 'mov \s '%r12, \s '0 \[ '%r8 \] \n)
   (\t 'mov \s '%r13, \s '8 \[ '%r8 \] \n)
);

is-builtin := λf . (match f (
   ()
   ('is True)
   ('is-atom True)
   ('is-cons True)
   ('eq True)
   ('not True)
   ('head True)
   ('head-string True)
   ('tail-string True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('add True)
   ('mul True)
   ('div True)
   ('mod True)
   ('inv True)
   ('is-neg True)
   ('digit True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

system-call := λrax rdi rsi rdx . (
   (if rax (\t 'mov \s rax , \s '%rax              \n) ())
   (if rdi (\t 'mov \s rdi , \s '%rdi              \n) ())
   (if rsi (\t 'mov \s rsi , \s '%rsi              \n) ())
   (if rdx (\t 'mov \s rdx , \s '%rdx              \n) ())
   \t 'syscall                            \n
);

yield-patterns := λctx p offset . match p (
   ()
   ( Nil (tail(
      ()
      (Expr( () (\t 'mov \s '$0, \s '%r14 \n) () () () ctx offset ))
   )))
   ( (App( prev (App( lhs rhs )) )) (tail(
      (local e1)
      (local e2)
      (local e3)
      (local prog)
      (set e1 (yield-patterns(ctx prev offset)))
      (set e2 (destructure-pattern-lhs((get-pc e1) lhs (get-offset e1))))
      (set e3 (compile-expr((get-pc e2) rhs (get-offset e2) Used)))
      (local label_skip)
      (set label_skip (uuid()))
      (set prog (prog (get-prog e1)))
      (set prog (prog (\t 'cmp \s '$0, \s '%r14 \n)))
      (set prog (prog (\t 'jne \s label_skip \n)))
      (set prog (prog (get-prog e2)))
      (set prog (prog (\t 'cmp \s '$0, \s '%r14 \n)))
      (set prog (prog (\t 'je \s label_skip \n)))
      (set prog (prog (get-prog e3)))
      (set prog (prog (\t 'mov \s '$1, \s '%r14 \n)))
      (set prog (prog (label_skip ': \n)))
      (Expr( 
         ((get-frame e1) (get-frame e2) (get-frame e3))
         prog
         ((get-unframe e1) (get-unframe e2) (get-unframe e3))
         ((get-text e1) (get-text e2) (get-text e3))
         ((get-data e1) (get-data e2) (get-data e3))
         ctx
         (get-offset e3)
      ))
   )))
   ( _ (
      (fail (InvalidPatternsCase p))
   ))
);

destructure-pattern-lhs := λctx lhs offset . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local label_skip)
   (match lhs (
      ()
      ( (Variable '_) (tail(
         ()
         (Expr( () (\t 'mov \s '$1, \s '%r14 \n) () () () ctx offset ))
      )))
      ( (Variable v) (tail(
         (set e1 (declare-local(ctx v offset)))
         (Expr(
            (get-frame e1)
            ((get-prog e1) \t 'mov \s '$1, \s '%r14 \n)
            (get-unframe e1)
            (get-text e1)
            (get-data e1)
            (get-pc e1)
            (get-offset e1)
         ))
      )))
      ( (Literal l) (tail(
         (set e1 (yield-atom(ctx l offset)))
         (set label_skip (uuid()))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))       
         (set prog (prog (\t 'cmp \s '$0, \s '%r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))       
         (set prog (prog (\t 'mov \s '%r12, \s '%rax \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'mov \s '%r12, \s '%rbx \n)))
         (set prog (prog (\t 'call \s 'streq \n)))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s '%r14 \n)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( Nil (tail(
         (set label_skip (uuid()))
         (set prog (prog (\t 'cmp \s '$0, \s '%r12 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'cmp \s '$0, \s '%r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s '%r14 \n)))
         (set prog (prog (label_skip ': \n)))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( l r )) (tail(
         (set e1 (destructure-pattern-lhs(ctx l offset)))
         (set e2 (destructure-pattern-lhs((get-pc e1) r (get-offset e1))))
         (set label_skip (uuid()))
         (set prog (prog (\t 'mov \s '$0, \s '%r14 \n)))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s '%r13 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (inline-head())))
         (set prog (prog (get-prog e1)))
         (set prog (prog (pop-this())))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s '%r14 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$0, \s '%r14 \n)))
         (set prog (prog (inline-tail())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( 
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      (_ (fail (UnexpectedPattern lhs)))
   ))
));

before-main := λ .(
   # before_main_argv:
   #    argv = ()
   #    let t = argv
   #    for a in argv:
   #       t.tail = (a ())
   #       t = t.tail

   'main:                              \n
   compile-argv-hook
);

exit-cleanup := λ . (system-call( '$60 '$0 '$0 '$0 ));
