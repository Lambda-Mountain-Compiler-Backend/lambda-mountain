
config := ();
parsed-program := ();
global-text-section := ();
global-data-section := ();
program-break := λ. (
   'current_break:                     \n
   \t '.zero \s '8                     \n
   'program_break:                     \n
);

#import STDLIB/default-argv-hook;
argv-main-hook := ();
include-argv-hook := λ. if argv-main-hook () (set argv-main-hook (argv-main-hook (
   \t 'pop \s '%rax                    \n # put argc in %rax
   \t 'mov \s '$argv, \s '%r9          \n
   \t 'movq \s '$0, \s '0 \[ '%r9 \]   \n
   \t 'movq \s '$0, \s '8 \[ '%r9 \]   \n

   'before_main_argv:                  \n
   \t 'cmp \s '$0, \s '%rax            \n
   \t 'je \s 'before_main_end          \n

   \t 'pop \s '%r12                    \n #this = argv[i]
   \t 'mov \s '$0, \s '%r13            \n
   (close())                              #r8 is argv[i]

   \t 'mov \s '%r8, \s '0 \[ '%r9 \]   \n #set t.head = argv[i]
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   (close())
   \t 'mov \s '%r8, \s '8 \[ '%r9 \]   \n #set t.tail = ()
   \t 'mov \s '%r8, \s '%r9            \n #set t = t.tail

   \t 'dec \s '%rax                    \n #dec argc
   \t 'jmp \s 'before_main_argv        \n

   'before_main_end:                   \n
)));

sbrk := λsize . (tail(
   (local extend)
   (set extend (uuid()))
   (\t 'mov \s '$current_break, \s '%r9         \n
    \t 'mov \s '0 \[ '%r9 \] , \s '%r8          \n
    \t 'cmp \s '$0, \s '%r8                     \n
    \t 'jne \s extend                           \n
    \t 'mov \s '$program_break, \s '%r8         \n
    \t 'mov \s '%r8, \s '0 \[ '%r9 \]           \n
    extend ':                                   \n
    \t 'add \s '$ size , \s '%r8                \n
    \t 'mov \s '$12, \s '%rax                   \n  # system call brk
    \t 'mov \s '%r8, \s '%rdi                   \n  # new requested brk
    \t 'syscall                                 \n
    \t 'mov \s '%r8, \s '0 \[ '%r9 \]           \n
    \t 'sub \s '$ size , \s '%r8                \n)
));

#import STDLIB/default-atom-allocator;
allocate-cons-s-pointer := ();
allocate-cons-function-id := ();
allocate-cons := λ . (tail(
   # it is save to use %r8, %r9, %r10, %r11 registers in this allocator
   # new cons pointer goes in %r8 register
   (if allocate-cons-s-pointer () (
      (set allocate-cons-s-pointer (uuid()))
      (set global-data-section ( global-data-section (
         allocate-cons-s-pointer ': \n
         \t '.zero \s '8            \n
      )))
      (local page-size)
      (set page-size 1048576) # Pages are 1MB by default
      (set allocate-cons-function-id (uuid()))
      (local while_s_pointer)
      (set while_s_pointer (uuid()))
      (local while_s_pointer_end)
      (set while_s_pointer_end (uuid()))
      (local allocate_new_page)
      (set allocate_new_page (uuid()))
      (local allocate_inside_page)
      (set allocate_inside_page (uuid()))
      (local allocate_done)
      (set allocate_done (uuid()))
      # Page Layout (Zero Initialized is Well Initialized)
      # next_page : *Page
      # used_size : Int
      # page_data : Cons[PageSize]
      (set global-text-section ( global-text-section (
         allocate-cons-function-id ':                               \n
         \t 'mov \s '$ allocate-cons-s-pointer ', \s '%r8           \n  # %r8 is active page pointer **Page
         \t 'mov \s '0 \[ '%r8 \] , \s '%r9                         \n  # %r9 is active page value    *Page
         \t 'cmp \s '$0, \s '%r9                                    \n
         \t 'je \s allocate_new_page                                \n
         while_s_pointer ':                                         \n
         \t 'mov \s '0 \[ '%r9 \] , \s '%r10                        \n  # %r10 is next page value *Page
         \t 'cmp \s '$0, \s '%r10                                   \n
         \t 'je \s allocate_inside_page                             \n  # allocate inside page if we are at end of page list
         \t 'mov \s '%r9  , \s '%r8                                 \n  # set active page pointer **Page
         \t 'mov \s '%r10 , \s '%r9                                 \n  # set active page value    *Page
         \t 'jmp \s while_s_pointer                                 \n  # continue loop until end of page list
         allocate_new_page ':                                       \n
         \t 'push \s '%r8                                           \n
         (sbrk page-size)
         \t 'mov \s '%r8, \s '%r9                                   \n
         \t 'pop \s '%r8                                            \n
         \t 'mov \s '%r9, \s '0 \[ '%r8 \]                          \n  # write link to next page
         \t 'movq \s '$16, \s '0 \[ '%r9 \]                          \n  # increment used size by 1 Cons
         \t 'add \s '$16, \s '%r8                                   \n  # %r8 points to new Cons cell
         \t 'ret                                                    \n
         allocate_inside_page ':                                    \n
         \t 'ret                                                    \n
      )))
   ))
   ( \t 'call \s allocate-cons-function-id \n )
));

#import STDLIB/default-cons-allocator;

main := (
   (set type-subtypes 
     (
        (
           (() (Atom S))
           (Nil S)
        )
        ((Cons(S S)) S)
     )
   )
   (local mode)
   (set mode Compile)
   (local inputs)
   (local target)
   (local option)
   (local arg)
   (foreach-atom (tail argv) ((set arg $_) (if option
      (match option (
         ()
         (() ())
         (SetTarget (
            (set config ( config (Target arg)))
            (set option ())
         ))
      ))
      (match arg (
         ()
         (() ())
         (-o (set option SetTarget))
         (--compile (set mode Compile))
         (--parse (set mode Parse))
         (--parse-expression (set mode ParseExpression))
         (--tokenize (set mode Tokenize))
         (--typecheck (set mode Typecheck))
         (fp (set inputs (fp inputs)))
      ))
   )))
   (match mode (
      ()
      (Compile (foreach-atom inputs (
         if $_ (parse-program (tokenize-file $_)) ()
      )))
      (Parse (foreach-atom inputs (
         if $_ (parse-program (tokenize-file $_)) ()
      )))
      (Typecheck (foreach-atom inputs (
         if $_ (parse-program (tokenize-file $_)) ()
      )))
      (ParseExpression (foreach-atom inputs (
         if $_ (print-s (parse-expression (tokenize-file $_))) ()
      )))
      (Tokenize (foreach-atom inputs (
         if $_ (print-s (tokenize-file $_)) ()
      )))
   ))
   (match mode (
      ()
      (Compile (assemble parsed-program))
      (Parse (print-s parsed-program))
      (Typecheck (print-s (show-ascript (typecheck parsed-program))))
   ))
);

#this is necessary to circumvent a bug with the bootstrap compiler trying to call globals as functions syntactically
fail := λmsg . (print-s msg) (exit 1);

type-context := ();
type-subtypes := ();
type-constructors := ();
types-have-changed := ();

tokenize-file := λpath . (
   tokenize (load-file path)
);

typecheck := λprogram . (tail(
   (local p)
   (set p program)
   (while p (
      (infer-type-expr( (tail p) ))
      (set p (head p))
   ))
   (set types-have-changed True)
   (while types-have-changed (
      (set types-have-changed ())
      (infer-prog program)
   ))
   program
));

lookup-type := λterm . (tail(
   (local tctx)
   (set tctx type-context)
   (local found)
   (local ttt)
   (while tctx (
      (set ttt (head tctx))
      (if (is( (head ttt) term )) (
         (set found (tail ttt))
         (set tctx ())
      ) (
         (set tctx (tail tctx))
      ))
   ))
   found
));

ascript := λt tt . (
   if tt (
      (set type-context ((t tt) type-context))
      (set types-have-changed True)
   ) ()
);

show-ascript := λp . (tail(
   (local term)
   (set term (match p (
      ()
      ( () () )
      ( Nil p )
      ( (Variable _) p )
      ( (Literal _) p )
      ( (App( f x )) (
         (App( (show-ascript f) (show-ascript x) ))
      ))
      ( (Lambda( lhs rhs )) (
         (Lambda( (show-ascript lhs) (show-ascript rhs) ))
      ))
      ( (prog (GExpr( g ))) (
         ( (show-ascript prog) (GExpr( show-ascript g )) )
      ))
      ( (prog (Global( n v ))) (
         ( (show-ascript prog) (Global( n (show-ascript v) )) )
      ))
      ( (prog (Type( tn td ))) (
         ( (show-ascript prog) (Type( tn td )) )
      ))
      ( unknown (
         fail (UnknownTerm unknown)
      ))
   )))

   (local type)
   (set type (lookup-type p))
   (if type (
      (if (eq( type ? )) (
         term
      ) ( 
         (:( term type ))
      ))
   ) (
      term
   ))
));

global-context := ();

infer-prog := λp . (
   (while p (
      (infer-expr( global-context (tail p) ))
      (set p (head p))
   ))
);

infer-ctx := λctx e . (match e (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (ctx (v (typeof-ascript tt)))
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      ( (infer-ctx( ctx ps )) (v (typeof-ascript tt)))
   ))
   ( (Variable v) (
      (ctx (v S))
   ))
   ( (App( ps (Variable v) )) (
      ( (infer-ctx( ctx ps )) (v S))
   ))
   ( Nil (
      ctx
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typeof-gvar := λv . (tail(
   (local gctx)
   (set gctx global-context)
   (local tt)
   (while gctx (
      (match (tail gctx) (
         ()
         ( (Global( gn gt )) (
            (if (eq( v gn )) (
               (if tt (
                  (set tt (And(tt gt)) )
               ) (
                  (set tt gt)
               ))
            ) ())
            (set gctx (head gctx))
         ))
      ))
   ))
   tt
));

typeof-var := λctx v . (match ctx (
   ()
   ( () (typeof-gvar v) )
   ( (cs (cv ct)) (
      if (eq( v cv )) (
         ct
      ) (
         (typeof-var( cs v ))
      )
   ))
));

typeof-ascript := λtt . (match tt (
   ()
   ( (Literal tname) (
      tname
   ))
   ( (Variable tname) (
      tname
   ))
));

typeof-lhs := λlhs . (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (typeof-ascript tt)
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      (Cons( (typeof-lhs ps) (typeof-ascript tt) ))
   ))
   ( (Variable v) (
      S
   ))
   ( (App( ps (Variable v) )) (
      (Cons( (typeof-lhs ps) S ))
   ))
   ( Nil (
      Nil
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

unify-sub := λctx v . (match ctx (
   ()
   ( Accept v )
   ( (Bind( s1 s2 )) (
      if (eq( v s1 )) s2 v
   ))
   ( (ctxl ctxr) (tail(
      (local lv)
      (set lv (unify-sub( ctxl v )))
      (local rv)
      (set rv (unify-sub( ctxr v )))
      (if (is( lv v )) (
         (if (is( rv v )) () (set v rv))
      ) (set v lv))
      v
   )))
));

unify-ctx := λctx v . (match v (
   ()
   ( (vl vr) (
      ( (unify-ctx( ctx vl )) (unify-ctx( ctx vr )) )
   ))
   ( _ (
      (unify-sub( ctx v ))
   ))
));

unify-implies := λlt rt . (if (eq(lt rt)) True (tail(
   (local accept)
   (local subtypes)
   (local st)
   (set subtypes type-subtypes)
   (while subtypes (
      (set st (tail subtypes))
      (if (eq( (head st) lt )) (
         (if (eq( (tail st) rt )) (
            (set accept True)
         ) ())
      ) ())
      (set subtypes (head subtypes))
   ))
   accept
)));

unify-args := λlt rt . (match (lt rt) (
   ()
   ( ((lt1 rt1) (lt2 rt2)) (
      (match ( (unify-args(lt1 lt2)) (unify-args(rt1 rt2)) ) (
         ()
         ( (() _) () )
         ( (_ ()) () )
         ( (lctx rctx) (lctx rctx) )
      ))
   ))
   ( (a1 a2) (
      (if (unify-implies( a2 a1 )) ( # argument type must imply parameter type
         Accept
      ) (
         (if (is-variable a1) (
            (if (is-variable a2) (
               Accept
            ) (
               (Bind( a1 a2 ))
            ))
         ) (
            (if (is-variable a2) (
               (Bind( a2 a1 ))
            ) (
               ()
            ))
         ))
      ))
   ))
   (_ (tail(
      (fail (UnknownUnify lt rt))
      ?
   )))
));

apply-plural := λmany pt . (match many(
   ()
   ( (And( t1 t2 )) (tail(
      (local r)
      (set r (apply-plural( t1 pt )))
      (if r r (apply-plural( t2 pt )))
   )))
   ( (->(lt rt)) (
      (unify-ctx( (unify-args(lt pt)) rt ))
   ))
));

safe-apply-plural := λterm many pt . (tail(
   (local r)
   (set r (apply-plural( many pt )))
   (if r r (
      fail (TypeError( InvalidArgument many pt ))
   ))
));

infer-type-compound := λcompound . (match compound (
   ()
   ((Literal tt) tt)
   ((App( lt rt )) (Cons( (infer-type-compound lt) (infer-type-compound rt) )))
   (u (fail (UnknownTypeCompound u)))
));

infer-type-constructor := λname body . (match body (
   ()
   ( (Literal tag) (
      (set type-constructors ( type-constructors (tag tag) ))
      (set type-subtypes ( type-subtypes (tag (infer-type-compound name)) ))
   ))
   ( (App( (Literal tag) args )) (
      (local ctype)
      (set ctype (infer-type-compound args))
      (set type-constructors ( type-constructors (tag (->(ctype (tag ctype)))) ))
      (set type-subtypes ( type-subtypes ((tag ctype) (infer-type-compound name)) ))
   ))
));

infer-type-definition := λname def . (match def (
   ()
   ( (App( (App( tds (Literal |) )) body )) (
      (infer-type-definition( name tds ))
      (infer-type-constructor( name body ))
   ))
   ( body (
      (infer-type-constructor( name body ))
   ))
));

infer-constructor-type := λtag . (tail(
   (local ctype)
   (local constructors)
   (set constructors type-constructors)
   (while constructors (
      (if (eq( tag (head(tail(constructors))) )) (
         (if ctype (
            (set ctype (And( ctype (tail(tail(constructors))) )))
         ) (
            (set ctype (tail(tail(constructors))))
         ))
      ) ())
      (set constructors (head constructors))
   ))
   ctype
));

infer-type-expr := λe . (match e (
   ()
   ( (Type( l ds )) (
      (infer-type-definition( l ds ))
      (ascript( e ? ))
   ))
   (_ ())
));

infer-expr := λctx e . (
   (if (lookup-type e) () (
      match e (
         ()
         ( () () )
         ( (GExpr ge) (
            (infer-expr( ctx ge ))
         ))
         ( (Global( gln gle )) (
            (infer-expr( ctx gle ))
            (match (lookup-type gle) (
               ()
               ( () () )
               ( glt (
                  (set global-context ( global-context (Global( gln glt )) ))
                  (ascript( e ? ))
               ))
            ))
         ))
         ( (Type( l ds )) ())
         ( Nil (
            (ascript( e Nil ))
         ))
         ( (Literal lit) (
            (local ctype)
            (set ctype (infer-constructor-type lit))
            (if ctype (
               (ascript( e (And( ctype Atom )) ))
            ) (
               (ascript( e Atom ))
            ))
         ))
         ( (App( l r )) (
            (infer-expr( ctx l ))
            (infer-expr( ctx r ))
            (match ( (lookup-type l) (lookup-type r) ) (
               ()
               ( (() _) () )
               ( (_ ()) () )
               ( ( (->(lt rt)) pt ) (
                  (ascript( e (safe-apply-plural( e (->(lt rt)) pt )) ))
               ))
               ( ( (And(t1 t2)) pt ) (
                  (ascript( e (safe-apply-plural( e (And(t1 t2)) pt )) ))
               ))
               ( (lt rt) (
                  (ascript( e (Cons(lt rt)) ))
               ))
            ))
         ))
         ( (Lambda( lhs rhs )) (
            (set ctx (infer-ctx( ctx lhs )))
            (infer-expr( ctx rhs ))
            (match (lookup-type rhs) (
               ()
               ( () () )
               ( rt (
                  (ascript( e (->( (typeof-lhs lhs) rt)) ))
               ))
            ))
         ))
         ( (Variable v) (
            (match (typeof-var( ctx v )) (
               ()
               ( () () )
               ( tt (ascript( e tt )) )
            ))
         ))
         ( u (fail (UnknownTerm u)) )
      )
   ))
);

parse-lambda := λtoks . (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal .) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal .) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (expect( . toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

unexpect := λt . fail (UnexpectedToken t);
expect := λt ts . ();
#expect := λt ts . if (eq( t (head ts) )) () (fail (ExpectedToken t));

parse-one-expression := λtoks . (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (expect( \] (tail pme) ))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks . (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks . (parse-many-expressions toks);

parse-program := λtoks . (tail(
   (local program)
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set parsed-program ( parsed-program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('import (relative-path remainder)) (
            (parse-program (tokenize-file relative-path))
            (set toks remainder)
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set parsed-program ( parsed-program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set parsed-program (parsed-program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
   program
));

tokenize := λtext . (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)
   (foreach-char text ((set char $_) (match char (
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

is-variable := λv . (tail(
   (local is_v)
   (local passed_char)
   (local c)
   (foreach-char v (
      (set c $_)
      (if passed_char () (match c (
         ()
         ('$ ( (set is_v True) (set passed_char True) ))
         ('_ ( (set is_v True) (set passed_char True) ))
         ('a ( (set is_v True) (set passed_char True) ))
         ('b ( (set is_v True) (set passed_char True) ))
         ('c ( (set is_v True) (set passed_char True) ))
         ('d ( (set is_v True) (set passed_char True) ))
         ('e ( (set is_v True) (set passed_char True) ))
         ('f ( (set is_v True) (set passed_char True) ))
         ('g ( (set is_v True) (set passed_char True) ))
         ('h ( (set is_v True) (set passed_char True) ))
         ('i ( (set is_v True) (set passed_char True) ))
         ('j ( (set is_v True) (set passed_char True) ))
         ('k ( (set is_v True) (set passed_char True) ))
         ('l ( (set is_v True) (set passed_char True) ))
         ('m ( (set is_v True) (set passed_char True) ))
         ('n ( (set is_v True) (set passed_char True) ))
         ('o ( (set is_v True) (set passed_char True) ))
         ('p ( (set is_v True) (set passed_char True) ))
         ('q ( (set is_v True) (set passed_char True) ))
         ('r ( (set is_v True) (set passed_char True) ))
         ('s ( (set is_v True) (set passed_char True) ))
         ('t ( (set is_v True) (set passed_char True) ))
         ('u ( (set is_v True) (set passed_char True) ))
         ('v ( (set is_v True) (set passed_char True) ))
         ('w ( (set is_v True) (set passed_char True) ))
         ('x ( (set is_v True) (set passed_char True) ))
         ('y ( (set is_v True) (set passed_char True) ))
         ('z ( (set is_v True) (set passed_char True) ))
         (_ (set passed_char True))
      )))
   ))
   is_v
));

assemble := λprogram . (
   (local target)
   (set target 'tmp.s)
   (while config (
      (match (tail config) (
         ()
         ((Target t) (set target t))
      ))
      (set config (head config))
   ))

   (local main_e)
   (local main_pd)

   (local e1)
   (local e2)

   (local output_pd)
   (set output_pd ( (program-header()) (data-header()) ))

   (local global_ctx)
   (local preview_program)
   (set preview_program program)
   (while preview_program (match preview_program (
      ()
      ( (pc (Global ('main body))) (
         (set preview_program pc)
      ))
      ( (pc (GExpr e)) (
         (set preview_program pc)
      ))
      ( (pc (Global (fname body))) (
         (match body (
            ()
            ( Nil (
               (set output_pd ( (head output_pd) ((tail output_pd) (label-case fname) ': \n \t '.zero \s '16 \n) ))
               (set global_ctx (global_ctx (GlobalVariable fname)))
            ))
            ( (Lambda(lhs rhs)) (
               (set global_ctx (global_ctx (GlobalFunction fname)))
            ))
         ))
         (set preview_program pc)
      ))
   )))

   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set main_e body)
         (set program pc)
      ))
      ( (pc (GExpr e)) (
         (set main_pd (compile-append( main_pd global_ctx e )))
         (set program pc)
      ))
      ( (pc (Global (fname body))) (
         (match body (
            ()
            ( Nil (
            ))
            ( (Lambda(lhs rhs)) (
               (set e1 (destructure-args(global_ctx lhs ())))
               (set e2 (compile-expr((get-pc e1) rhs (get-offset e1) Used)))
               (set output_pd ( ((head output_pd) (label-case fname) ': \n) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (enter-function())) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-frame e1)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-frame e2)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-prog e1)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-prog e2)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (exit-function())) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-text e1)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-text e2)) (tail output_pd) ))
               (set output_pd ( (head output_pd) ((tail output_pd) (get-data e1)) ))
               (set output_pd ( (head output_pd) ((tail output_pd) (get-data e2)) ))
            ))
         ))
         (set program pc)
      ))
   )))

   (if main_e (
      (set main_pd (compile-append( main_pd global_ctx main_e )))
   ) ())
   (set output_pd (
      (
         (head output_pd)
         (before-main())
         (enter-function())
         (get-frame main_pd)
         (get-prog main_pd)
         (exit-cleanup())
         (get-text main_pd)
         global-text-section
         (stdlib-functions())
      )
      ((tail output_pd) (get-data main_pd) global-data-section (program-break()))
   ))
   (write-file (target (clone-rope output_pd)))
);

get-frame := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

get-maybe-function := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r (Variable l))
               ) ()
            )
         ))
         ( (GlobalFunction name) (
            if r () (
               if (eq(name v)) (
                  (set r (GlobalFunction (label-case name)))
               ) ()
            )
         ))
         ( (GlobalVariable name) (
            if r () (
               if (eq(name v)) (
                  (set r (GlobalVariable (label-case name)))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   r
));

get-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r15 \n
                     \t 'mov \s '0 \[ %r15 \] , \s %r12     \n
                     \t 'mov \s '8 \[ %r15 \] , \s %r13     \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (ReferenceToUndefinedVariable v))
   ))
   r
));
set-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local((Set l) lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r15 \n
                     \t 'mov \s %r12 , \s '0 \[ %r15 \] \n
                     \t 'mov \s %r13 , \s '8 \[ %r15 \] \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (AssignToUndefinedVariable v))
   ))
   r
));

compile-expr := λctx e offset used . (tail(
   (local e1)
   (local e2)
   (local e3)
   (local prog)
   (local tail_safe)
   (local return)
   (set return (match e (
      ()
      ( (Variable '$_) (tail(
         ()
         (Expr( () () () () () ctx offset ))
      )))
      ( (Variable 'argv) (tail(
         (include-argv-hook())
         (set prog (prog ( \t 'mov \s '$argv, \s '%r8 \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%r8 \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%r8 \] , '%r13 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (Variable vname) (tail(
         ()
         (Expr( () (get-local(ctx vname)) () () () ctx offset ))
      )))
      ( (App ((Variable 'local) (Variable fname))) (tail(
         (set e1 (declare-local(ctx fname offset)))
         (Expr( (get-frame e1) ((yield-nil()) (get-prog e1)) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( (App( (App( (Variable 'set) (Variable vname) )) x )) (tail(
         (set e1 (compile-expr(ctx x offset Used)))
         (set prog ((get-prog e1) (set-local(ctx vname))))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( (App( (App( (Variable 'while) c )) d )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e2 (compile-expr((get-pc e1) d (get-offset e1) Unused)))
         (local label_while_start)
         (set label_while_start (uuid()))
         (local label_while_end)
         (set label_while_end (uuid()))
         (set prog (prog (label_while_start ': \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_while_end \n)))
         (set prog (prog (get-prog e2)))
         (set prog (prog (\t 'jmp \s label_while_start \n)))
         (set prog (prog (label_while_end ': \n)))
         (set tail_safe True)
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( (App( (Variable 'exit) (Literal _) )) (tail(
         (set tail_safe True)
         (set prog (
            \t 'mov \s '$60, \s '%rax          \n
            \t 'mov \s '$1 , \s '%rdi          \n
            \t 'syscall                        \n
         ))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( (App( (App( (Variable 'if) c )) t )) f )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e2 (compile-expr( (get-pc e1) t (get-offset e1) Used )))
         (set e3 (compile-expr( (get-pc e2) f (get-offset e2) Used )))
         (local label_if_true)
         (set label_if_true (uuid()))
         (local label_if_end)
         (set label_if_end (uuid()))
         (set prog (prog (get-prog e1)))
         (set prog (prog ( \t 'cmp \s '$0, '%r12 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r13 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r14 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog (get-prog e3)))
         (set prog (prog ( \t 'jmp \s label_if_end \n )))
         (set prog (prog ( label_if_true ': \n )))
         (set prog (prog (get-prog e2)))
         (set prog (prog ( label_if_end ': \n )))
         (Expr(
            ((get-frame e1) (get-frame e2) (get-frame e3))
            prog
            ((get-unframe e1) (get-unframe e2) (get-unframe e3))
            ((get-text e1) (get-text e2) (get-text e3))
            ((get-data e1) (get-data e2) (get-data e3))
            (get-pc e3)
            (get-offset e3)
         ))
      )))
      ( (App( (App( (Variable 'match) t )) p )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e2 (yield-patterns((get-pc e1) p (get-offset e1))))
         (local label_skip)
         (set label_skip (uuid()))
         (set prog ((get-prog e1) (get-prog e2)))
         (set prog (prog ( \t 'cmp \s '$0, \s %rsi \n )))
         (set prog (prog ( \t 'jne \s label_skip \n )))
         (set prog (prog (yield-nil())))
         (set prog (prog ( label_skip ': \n )))
         (Expr(
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      ( (App( (App( (Variable 'foreach-atom) t )) d )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e2 (compile-expr((get-pc e1) d (get-offset e1) Unused)))
         (local foreach_atom_label)
         (set foreach_atom_label (uuid()))
         (local foreach_atom_notcons)
         (set foreach_atom_notcons (uuid()))
         (local foreach_atom_ignore)
         (set foreach_atom_ignore (uuid()))
         (local foreach_text)
         (set foreach_text (yield-foreach-atom( foreach_atom_label foreach_atom_notcons foreach_atom_ignore (get-prog e2) )))
         (set prog ( (get-prog e1) \t 'call \s foreach_atom_label \n ))
         (set tail_safe True)
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2) foreach_text) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( (App( (App( (Variable 'foreach-char) t )) d )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e2 (compile-expr((get-pc e1) d (get-offset e1) Unused)))
         (local foreach_char_head)
         (set foreach_char_head (uuid()))
         (local foreach_char_small)
         (set foreach_char_small (uuid()))
         (local foreach_char_end)
         (set foreach_char_end (uuid()))
         (local foreach_char_notcons)
         (set foreach_char_notcons (uuid()))
         (local foreach_char_data)
         (set foreach_char_data (uuid()))
         (local foreach_char_apply)
         (set foreach_char_apply (uuid()))
         (local foreach_data)
         (set foreach_data ( foreach_char_data ': \n \t '.zero \s '2 \n ))
         (local foreach_text)
         (set foreach_text (yield-foreach-char( foreach_char_data foreach_char_head foreach_char_small foreach_char_end foreach_char_notcons foreach_char_apply (get-prog e2) )))
         (set prog ( (get-prog e1) \t 'call \s foreach_char_head \n ))
         (set tail_safe True)
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2) foreach_text) ((get-data e1) (get-data e2) foreach_data) (get-pc e2) (get-offset e2) ))
      )))
      ( (App ((Variable fname) arg)) (tail(
         ()
         (if (is-builtin fname) (tail(
            ()
            (if (eq(fname 'tail)) (tail(
               (set e1 (compile-expr(ctx arg offset Tail)))
               (Expr( (get-frame e1) (get-prog e1) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
            )) (tail(
               (set e1 (compile-expr(ctx arg offset Used)))
               (set prog ((get-prog e1) (\t 'call \s (label-case fname) \n)))
               (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
            )))
         )) (tail(
            ()
            (match (get-maybe-function(ctx fname)) (
               ()
               ( (GlobalFunction mangledname) (tail(
                  (set e1 (compile-expr(ctx arg offset Used)))
                  (set prog ((get-prog e1) (\t 'call \s mangledname \n)))
                  (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
               )))
               ( () (
                  (fail (ReferenceToUndefinedVariable fname))
               ))
               ( v (tail(
                  ()
                  (yield-cons(ctx v arg offset Used))
               )))
            ))
         )))
      )))
      ( (Literal l) (tail(
         ()
         (yield-atom (ctx l offset))
      )))
      ( Nil (tail(
         (set prog (prog ( \t 'mov \s '$0 , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r13 \n )))
         (set tail_safe True)
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App (l r)) (tail(
         (set tail_safe True)
         (yield-cons(ctx l r offset used))
      )))
      ( (GlobalVariable mangled-name) (tail(
         (set prog (
            \t 'mov \s '$ mangled-name , \s %r15   \n
            \t 'mov \s '0 \[ %r15 \] , \s %r12     \n
            \t 'mov \s '8 \[ %r15 \] , \s %r13     \n
         ))
         (Expr( () prog () () () ctx offset ))
      )))
      ( u (fail (UnrecognizedExpression u)) )
   )))
   (if tail_safe return (tail(
      ()
      (if (eq(used Tail)) (tail(
         (set prog (get-prog return))
         (set prog (prog (\t 'call \s 'tail \n)))
         (Expr( (get-frame return) prog (get-unframe return) (get-text return) (get-data return) (get-pc return) (get-offset return) ))
      )) (
         return
      ))
   )))
));

compile-append := λoutput_e gctx e . (tail(
   (set e (compile-expr( gctx e (get-offset output_e) Used )))
   (Expr(
      ((get-frame output_e) (get-frame e))
      ((get-prog output_e) (get-prog e))
      ((get-unframe output_e) (get-unframe e))
      ((get-text output_e) (get-text e))
      ((get-data output_e) (get-data e))
      (get-pc e)
      (get-offset e)
   ))
));

data-header := λ .(
  '.data                                  \n
  'load_file_bsz:                         \n
  \t '.quad \s '1024                      \n
  'load_file_buf:                         \n
  \t '.zero \s '1024                      \n
  'argv:                                  \n
  \t '.zero \s '16                        \n
  'a_counter:                             \n
  \t '.zero \s '8                         \n
  'a_section:                             \n
  \t '.zero \s '536870912                 \n
  'nil_literal:                           \n
  \t '.ascii \s " \[ \] "                 \n
  \t '.zero \s 1                          \n
  'newline:                               \n
  \t '.ascii \s " \\n "                   \n
  'left_paren:                            \n
  \t '.ascii \s " \[ "                    \n
  'right_paren:                           \n
  \t '.ascii \s " \] "                    \n
  'space:                                 \n
  \t '.ascii \s " \s "                    \n
  'true:                                  \n
  \t '.ascii \s "True"                    \n
  \t '.zero \s '1                         \n
  '__digit:                               \n
  \t '.zero \s '2                         \n
  'hex_buffer:                            \n
  \t '.ascii \s "0123456789abcdef"        \n
  '__dump_i:                              \n
  \t '.ascii \s '"0000000000000000"       \n
  \t '.zero \s '1                         \n
  'err_fopen:                             \n
  \t '.ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t '.zero \s '1                         \n
);

program-header := λ .(
   '.global \s '_start                    \n
   '.text                                 \n
   '_start:                               \n
   \t 'jmp \s 'main                       \n
);

exit-cleanup := λ . (system-call( '$60 '$0 '$0 '$0 ));

system-call := λrax rdi rsi rdx . (
   \t 'mov \s rax , \s '%rax              \n
   \t 'mov \s rdi , \s '%rdi              \n
   \t 'mov \s rsi , \s '%rsi              \n
   \t 'mov \s rdx , \s '%rdx              \n
   \t 'syscall                            \n
);

before-main := λ .(
   # before_main_argv:
   #    argv = ()
   #    let t = argv
   #    for a in argv:
   #       t.tail = (a ())
   #       t = t.tail

   'main:                              \n
   argv-main-hook
);

close := λe . (
   e
   (allocate-cons ())
   (\t 'mov \s '%r12, \s '0 \[ '%r8 \] \n)
   (\t 'mov \s '%r13, \s '8 \[ '%r8 \] \n)
);

is-builtin := λf . (match f (
   ()
   ('is True)
   ('eq True)
   ('not True)
   ('head True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('add True)
   ('mul True)
   ('div True)
   ('mod True)
   ('inv True)
   ('is-neg True)
   ('digit True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

label-case := λk . (tail(
   (local nk)
   (foreach-char k (match $_ (
      ()
      ('- (set nk (nk '_)))
      ('$ (set nk (nk '_I_)))
      (c (set nk (nk (clone-rope c))))
   )))
   (clone-rope nk)
));

stdlib-functions := λ . (
   'print_s:                           \n
   # if .head is zero, then this is Nil
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s 'print_s_nil              \n

   # if only .tail is zero, then this is an Atom
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'print_s_atom             \n

   # if .head and .tail are non-zero, then this is a Cons
   (system-call( '$1 '$1 '$left_paren '$1 ))
   (push-this())
   \t 'call \s 'head                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$space '$1 ))
   (push-this())
   \t 'call \s 'tail                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$right_paren '$1 ))
   \t 'ret                             \n

   'print_s_nil:                       \n
   # nil is two bytes "()" located in the data section at $nil_literal
   (system-call( '$1 '$1 '$nil_literal '$2 ))
   \t 'ret                             \n

   'print_s_atom:                      \n
   \t 'call \s 'strlen                 \n # %r8 is string length of this atom
   (system-call( '$1 '$1 '%r12 '%r8 )) \n
   \t 'ret                             \n

   'head:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
   \t 'ret                                \n

   'tail:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
   \t 'ret                                \n

   'strlen:                               \n
   \t 'xor \s '%r8, \s '%r8               \n
   \t 'mov \s '%r12, \s '%rax             \n
   'strlen_loop:                          \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]     \n
   \t 'jz \s 'strlen_exit                 \n
   \t 'inc \s '%r8                        \n
   \t 'inc \s '%rax                       \n
   \t 'jmp \s 'strlen_loop                \n
   'strlen_exit:                          \n
   \t 'ret                                \n

   'streq:                                \n
   'streq_loop:                           \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ %rax \] , \s '%cl     \n
   \t 'mov \s '0 \[ %rbx \] , \s '%dl     \n

   \t 'cmp \s '%cl, \s '%dl               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%cl                \n
   \t 'je \s 'streq_true                  \n
   \t 'inc \s '%rax                       \n
   \t 'inc \s '%rbx                       \n
   \t 'jmp \s 'streq_loop                 \n
   'streq_true:                           \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'eq:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'call \s 'streq                     \n
   \t 'ret                                \n

   'return_nil:                           \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'not:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jne \s 'not_yield_nil              \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
   'not_yield_nil:                        \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'clone_rope:                           \n
   \t 'mov \s '$a_section, \s '%r8        \n
   \t 'mov \s '$a_counter, \s '%r10       \n
   \t 'mov \s '0 \[ %r10 \] , \s '%r11    \n
   \t 'add \s '%r11, \s '%r8              \n
   \t 'mov \s '%r8, \s '%r9               \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   \t 'call \s '__clone_rope              \n
   \t 'movb \s '$0, \s '0 \[ %r9 \]       \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '$a_section, \s '%r10       \n
   \t 'sub \s '%r10, \s '%r9              \n
   \t 'mov \s '$a_counter, \s '%r10       \n
   \t 'mov \s '%r9, \s '0 \[ %r10 \]      \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   '__clone_rope:                         \n
   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'clone_rope_notcons          \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'mov \s '8 \[ %r12 \] , '%r13       \n
   \t 'mov \s '0 \[ %r12 \] , '%r12       \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'mov \s '0 \[ %r13 \] , '%r12       \n
   \t 'mov \s '8 \[ %r13 \] , '%r13       \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'jmp \s 'clone_rope_end             \n

   #if not cons, concat
   'clone_rope_notcons:                   \n

   #if nil, return
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'clone_rope_end              \n

   #if atom, break into characters and concat
   'clone_rope_small:                     \n
   \t 'cmpb \s '$0, \s '0 \[ %r12 \]      \n
   \t 'je \s 'clone_rope_end              \n
   \t 'movb \s '0 \[ %r12 \] , \s '%bl    \n
   \t 'movb \s '%bl, \s '0 \[ %r9 \]      \n
   \t 'inc \s '%r12                       \n
   \t 'inc \s '%r9                        \n
   \t 'jmp \s 'clone_rope_small           \n

   'clone_rope_end:                       \n
   \t 'ret                                \n

   'is:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'is_neg:                               \n
   \t 'cmp \s '$0, \s %r12                \n
   \t 'jge \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'inc:                                  \n
   \t 'inc \s '%r12                       \n
   \t 'ret                                \n

   'dec:                                  \n
   \t 'dec \s '%r12                       \n
   \t 'ret                                \n

   'inv:                                  \n
   \t 'neg \s '%r12                       \n
   \t 'ret                                \n

   'mul:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'imul \s '%rax, \s '%rbx            \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'add:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'add \s '%rax, \s '%rbx             \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'div:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'ret                                \n

   'mod:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rdx, \s '%r12             \n
   \t 'ret                                \n

   'dump_i:                               \n
   \t 'mov \s '%r12, \s '%r8              \n
   \t 'mov \s '$__dump_i, \s '%r12        \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$__dump_i, \s '%r11        \n
   \t 'cmp \s '$0, \s '%r8                \n
   \t 'jge \s 'dump_i_positive            \n
   \t 'jmp \s 'dump_i_negative            \n
   'dump_i_positive:                      \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$48, \s '0 \[ %r11 \]     \n
   \t 'ret                                \n
   'dump_i_negative:                      \n
   \t 'neg \s '%r8                        \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$45, \s '0 \[ %r11 \]     \n
   \t 'ret                                \n
   # if return value is positive then open was a success

   'dump_i_digits:                        \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[0]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '0 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[1]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '1 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[2]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '2 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[3]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '3 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[4]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '4 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[5]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '5 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[6]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '6 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[7]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '7 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[8]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '8 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[9]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '9 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[10]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '10 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[11]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '11 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[12]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '12 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[13]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '13 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[14]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '14 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[15]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '15 \[ %r11 \]     \n
   \t 'ret                                \n

   #move ascii representation of lower byte of %r8 into %cl
   'put8:                                 \n
   \t 'mov \s '%r8b, \s '%al              \n # lower byte of %r11 goes into %rax
   \t 'and \s '$0xf, \s '%al              \n # only show lower 4 bits
   \t 'mov \s '$hex_buffer, '%r10         \n # %r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b             \n # %r10 is index into char in hex buffer
   \t 'mov \s '0 \[ %r10 \] , \s '%cl     \n # %cl is a hexadecimal char
   \t 'ret                                \n

   'digit:                                \n
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'add \s '$48, \s %rax               \n
   \t 'mov \s '$__digit, \s %r12          \n
   \t 'mov \s '%al, \s '0 \[ %r12 \]      \n
   \t 'mov \s '$0, \s %r13                \n
   \t 'ret                                \n

   'write_file:                           \n
   #open file
   \t 'mov \s '0 \[ %r12 \] , \s '%rdi    \n # file name
   \t 'pushq \s '0 \[ %r13 \]             \n # data to write
   \t 'mov \s '$2, \s '%rax               \n # syscall open
   \t 'mov \s '$577, \s %rsi              \n
   \t 'mov \s '$420, \s '%rdx             \n # mode
   \t 'syscall                            \n
   \t 'mov \s '%rax, \s '%r8              \n # r8 now holds file descriptor

   #write to file
   \t 'pop \s '%rax                       \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'mov \s '%r8, \s '%r10              \n # %r10 has file descriptor
   \t 'call \s 'strlen                    \n
   (system-call( '$1 '%r10 '%r12 '%r8 ))

   #close file
   (system-call( '$3 '%r10 '$0 '$0 ))
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file:                            \n

   # open file
   (system-call( '$2 '%r12 '$0 '$0 ))
   # file descriptor is in %rax

   \t 'cmp \s '$0, \s '%rax               \n
   # if return value is positive then open was a success
   \t 'jge \s 'load_file_contents         \n

   \t 'mov \s '$err_fopen, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file_contents:                   \n
   \t 'mov \s '$a_section, \s '%r8        \n
   \t 'mov \s '$a_counter, \s '%r10       \n
   \t 'mov \s '0 \[ '%r10 \] , \s '%r11   \n
   \t 'add \s '%r11, \s '%r8              \n
   \t 'mov \s '%r8, \s '%r9               \n
   \t 'mov \s '$0, \s '%r10               \n
   \t 'mov \s '$load_file_buf, \s '%r11   \n
   #r8 holds pointer to head of new data
   #r9 holds pointer to tail of new data
   #r10 holds amount of data on buffer currently
   #r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:                       \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'je \s 'load_file_bufempty          \n
   \t 'movb \s '0 \[ %r11 \] , \s '%bl    \n
   \t 'mov \s '%bl, \s '0 \[ '%r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r11                       \n
   \t 'dec \s '%r10                       \n
   \t 'jmp \s 'load_file_loop             \n

   # read file
   'load_file_bufempty:                   \n
   \t 'push \s '%rax                      \n
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'mov \s '$load_file_bsz, \s '%rdx   \n
   \t 'mov \s '0 \[ '%rdx \] , \s '%rdx   \n
   (system-call( '$0 '%r10 '$load_file_buf %rdx ))
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'pop \s '%rax                       \n
   \t 'mov \s '$load_file_buf, \s '%r11   \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'jne \s 'load_file_loop             \n

   # close file
   (system-call( '$3 '%rax '$0 '$0 ))

   \t 'movb \s '$0, \s '0 \[ %r9 \]       \n
   \t 'inc \s '%r9                        \n
   \t 'sub \s '%r8, \s '%r9               \n
   \t 'mov \s '$a_counter, \s '%r10       \n
   \t 'mov \s '%r9, \s '0 \[ %r10 \]      \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$0, \s '%r14               \n
   \t 'mov \s '$0, \s '%r15               \n
   \t 'ret                                \n
);

inline-head := λ . (
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
);

inline-tail := λ . (
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
);

enter-function := λ .(
   \t 'push \s %rbp                       \n
   \t 'mov \s %rsp, \s %rbp               \n
);

exit-function := λ .(
   \t 'mov \s %rbp, \s %rsp               \n
   \t 'pop \s %rbp                        \n
   \t 'ret                                \n
);

push-this := λ .(
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
);

push-zero := λ .(
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
);

unpush-this := λ .(
   \t 'pop \s '%r8                        \n
   \t 'pop \s '%r8                        \n
);

pop-this := λ .(
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
);

yield-nil := λ . (
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
);

yield-cons := λctx l r offset used . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local rused)
   (match used (
      ()
      ( Used (tail(
         (set e1 (compile-expr( ctx l offset Used )))
         (set offset (get-offset e1))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
         (set offset (get-offset e2))
         (set prog (prog (get-prog e1)))
         (set prog (prog (push-this())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r8, \s '%r9 \n)))
         (set prog (prog (pop-this())))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r8, \s '%r12 \n)))
         (set prog (prog (\t 'mov \s '%r9, \s '%r13 \n)))
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( _ (tail(
         (set rused ( if (eq(used Tail)) Used Unused ))
         (set e1 (compile-expr( ctx l offset Unused )))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) rused )))
         (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
   ))
));

yield-atom := λctx a offset . (tail(
   (local id)
   (set id (uuid()))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
      )
      ()
      ()
      (id ': \n \t '.ascii \s " (escape-sequences a) " \n \t '.zero \s 1 \n)
      ctx
      offset
   ))
));

$uuid := ();
uuid := λ . (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

escape-sequences := λt . match t (
   ()
   ( () () )
   ( \\ \\\\ )
   ( \\: \: )
   ( \\o \o )
   ( \\n (\\ 'n))
   ( \\t \t )
   ( \\s \s )
   ( \\l \l )
   ( \\[ \[ )
   ( \\] \] )
   ( (l r) ( (escape-sequences l) (escape-sequences r) ) )
   ( s (tail(
      (local c)
      (local cs)
      (local is_escape)
      (foreach-char s (
         (set c $_)
         (match c (
            ()
            ( " (
               (set cs (cs \\ "))
               (set is_escape ())
            ))
            (\\ (
               (if is_escape (
                 (set cs ( cs \\\\ ))
                 (set is_escape ())
               ) (set is_escape True))
            ))
            (_ (
               (if is_escape (
                  (match c (
                     ()
                     ( , (set cs (cs .)))
                     ( _ (fail( InvalidEscapeCharacter (c s) )))
                  ))
               ) (set cs (cs (clone-rope c))))
               (set is_escape ())
            ))
         ))
      ))
      (clone-rope cs)
   )))
);

declare-local := λctx vname offset . (tail(
   (local frame_this)
   (set frame_this (push-zero()))
   (local unframe_this)
   (set unframe_this (unpush-this()))
   (local refer)
   (local eight)
   (set eight (
      inc(inc(inc(inc(inc(inc(inc(inc(
         ()
      ))))))))
   ))
   (local sixteen)
   (set sixteen (mul( eight (inc(inc(()))) )))
   (local set_this)
   (set set_this (
      \t 'mov \s '%r12, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r13, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] \n
   ))
   (set refer (
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] , %r12 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] , %r13 \n
   ))
   (set ctx (ctx (Local(vname refer)) ))
   (set ctx (ctx (Local((Set vname) set_this)) ))
   (Expr(frame_this set_this unframe_this () () ctx (inc offset)))
));

i2s := λi . (tail(
   (local ten)
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (local sign)
   (local s)
   (local r)
   (if (is-neg i) (
      (set sign '-)
      (set i (inv i))
   ) ())
   (while i (
      (set r (mod(i ten)))
      (set s ((clone-rope(digit r) s)))
      (set i (div(i ten)))
   ))
   (if s () (set s 0))
   (clone-rope (sign s))
));

destructure-args := λctx e offset . (match e (
   ()
   ( Nil (tail(
      ()
      (Expr( () () () () () ctx offset ))
   )))
   ( (Variable n) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( ( (App( h t )) ) (tail(
      (local ta)
      (set ta (destructure-args(ctx t offset)))
      (set offset (get-offset ta))
      (set ctx (get-pc ta))
      (local ha)
      (set ha (destructure-args(ctx h offset)))
      (set offset (get-offset ha))
      (set ctx (get-pc ha))
      (local prog)
      (set prog (prog (push-this()) ))
      (set prog (prog (\t 'call \s 'tail \n) ))
      (set prog (prog (get-prog ta) ))
      (set prog (prog (pop-this()) ))
      (set prog (prog (\t 'call \s 'head \n) ))
      (set prog (prog (get-prog ha) ))
      (Expr(
         ( (get-frame ta) (get-frame ha) )
         prog
         ( (get-unframe ta) (get-unframe ha) )
         () () ctx offset
      ))
   )))
   ( _ (
      (fail (InvalidFunctionParameters e))
   ))
));

yield-foreach-atom := λforeach-head foreach-notcons foreach-ignore foreach-apply . (
   #define label for this function
   foreach-head ':                           \n

   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13                  \n
   \t 'je \s foreach-notcons                 \n
   (push-this())
   \t 'call \s 'head                         \n
   \t 'call \s foreach-head                  \n
   (pop-this())
   (push-this())
   \t 'call \s 'tail                         \n
   \t 'call \s foreach-head                  \n
   (pop-this())
   \t 'ret                                   \n

   #if not cons, apply
   foreach-notcons ':                        \n
   \t 'cmp \s '$0, \s '%r12                  \n
   \t 'je \s foreach-ignore                  \n
   (push-this())
   foreach-apply
   (pop-this())
   \t 'ret                                   \n

   foreach-ignore ':                         \n
   \t 'ret                                   \n
);

yield-foreach-char := λforeach-data foreach-head foreach-small foreach-end foreach-notcons foreach-apply foreach-expr . (
   #define label for this function
   foreach-head ': \n

   #if this is a cons, recurse
   \t 'cmp \s '$0, \s %r13                   \n
   \t 'je \s foreach-notcons                 \n
   (push-this())
   \t 'call \s 'head                         \n
   \t 'call \s foreach-head                  \n
   (pop-this())
   (push-this())
   \t 'call \s 'tail                         \n
   \t 'call \s foreach-head                  \n
   (pop-this())
   \t 'ret                                   \n

   #if not cons, apply
   foreach-notcons ':                        \n
   (push-this())

   #if nil, apply and return
   \t 'mov \s '%r12, \s '%r8                 \n
   \t 'cmp \s '$0, \s '%r12                  \n
   \t 'jne \s foreach-small                  \n
   \t 'call \s foreach-apply                 \n
   (pop-this())
   \t 'ret                                   \n

   #if atom, break into characters and apply
   foreach-small ':                          \n
   \t 'cmpb \s '$0, \s '0 \[ %r8 \]          \n
   \t 'je \s foreach-end                     \n
   \t 'push \s '%r8                          \n
   \t 'mov \s '$ foreach-data , \s '%r12     \n
   \t 'mov \s '$0, \s '%r13                  \n
   \t 'mov \s '$0, \s '%r14                  \n
   \t 'mov \s '$0, \s '%r15                  \n
   \t 'movb \s '0 \[ %r8 \] , \s '%bl        \n
   \t 'movb \s '%bl, \s '0 \[ %r12 \]        \n
   \t 'movb \s '$0, \s '1 \[ %r12 \]         \n
   \t 'call \s foreach-apply                 \n
   \t 'pop \s '%r8                           \n
   \t 'inc \s '%r8                           \n
   \t 'jmp \s foreach-small                  \n

   foreach-end ':                            \n
   (pop-this())
   \t 'ret                                   \n

   foreach-apply ':                          \n
   foreach-expr
   \t 'ret                                   \n
);

yield-patterns := λctx p offset . match p (
   ()
   ( Nil (tail(
      ()
      (Expr( () (\t 'mov \s '$0, \s %rsi \n) () () () ctx offset ))
   )))
   ( (App( prev (App( lhs rhs )) )) (tail(
      (local e1)
      (local e2)
      (local e3)
      (local prog)
      (set e1 (yield-patterns(ctx prev offset)))
      (set e2 (destructure-pattern-lhs((get-pc e1) lhs (get-offset e1))))
      (set e3 (compile-expr((get-pc e2) rhs (get-offset e2) Used)))
      (local label_skip)
      (set label_skip (uuid()))
      (set prog (prog (get-prog e1)))
      (set prog (prog (\t 'cmp \s '$0, \s %rsi \n)))
      (set prog (prog (\t 'jne \s label_skip \n)))
      (set prog (prog (get-prog e2)))
      (set prog (prog (\t 'cmp \s '$0, \s %rsi \n)))
      (set prog (prog (\t 'je \s label_skip \n)))
      (set prog (prog (get-prog e3)))
      (set prog (prog (\t 'mov \s '$1, \s %rsi \n)))
      (set prog (prog (label_skip ': \n)))
      (Expr( 
         ((get-frame e1) (get-frame e2) (get-frame e3))
         prog
         ((get-unframe e1) (get-unframe e2) (get-unframe e3))
         ((get-text e1) (get-text e2) (get-text e3))
         ((get-data e1) (get-data e2) (get-data e3))
         ctx
         (get-offset e3)
      ))
   )))
   ( _ (
      (fail (InvalidPatternsCase p))
   ))
);

destructure-pattern-lhs := λctx lhs offset . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local label_skip)
   (match lhs (
      ()
      ( (Variable '_) (tail(
         ()
         (Expr( () (\t 'mov \s '$1, \s %rsi \n) () () () ctx offset ))
      )))
      ( (Variable v) (tail(
         (set e1 (declare-local(ctx v offset)))
         (Expr(
            (get-frame e1)
            ((get-prog e1) \t 'mov \s '$1, \s %rsi \n)
            (get-unframe e1)
            (get-text e1)
            (get-data e1)
            (get-pc e1)
            (get-offset e1)
         ))
      )))
      ( (Literal l) (tail(
         (set e1 (yield-atom(ctx l offset)))
         (set label_skip (uuid()))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))       
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))       
         (set prog (prog (\t 'mov \s %r12, \s %rax \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'mov \s %r12, \s %rbx \n)))
         (set prog (prog (\t 'call \s 'streq \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s %rsi \n)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( Nil (tail(
         (set label_skip (uuid()))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s %rsi \n)))
         (set prog (prog (label_skip ': \n)))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( l r )) (tail(
         (set e1 (destructure-pattern-lhs(ctx l offset)))
         (set e2 (destructure-pattern-lhs((get-pc e1) r (get-offset e1))))
         (set label_skip (uuid()))
         (set prog (prog (\t 'mov \s '$0, \s %rsi \n)))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (inline-head())))
         (set prog (prog (get-prog e1)))
         (set prog (prog (pop-this())))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %rsi \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$0, \s %rsi \n)))
         (set prog (prog (inline-tail())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( 
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      (_ (fail (UnexpectedPattern lhs)))
   ))
));
