
# Dependencies

import STDLIB/default-cons-allocator.lm;
import STDLIB/default-atom-allocator.lm;

# Static Globals

config-nostd                             := ();
cli-config                               := ();
parse-parsed-program                     := ();
parse-macros                             := ();
typecheck-subtypes                       := ();
typecheck-context                        := ();
typecheck-constructors                   := ();
typecheck-types-have-changed             := ();
typecheck-global-context                 := ();
assemble-text-section                    := ();
assemble-data-section                    := ();
compile-argv-hook                        := ();

# Static Global Initializers

typecheck-init := λ. (
   (set typecheck-subtypes 
     (
        (
           (() (Atom S))
           (Nil S)
        )
        ((Cons(S S)) S)
     )
   )
   (local mode)
);

# Cli Entry Point

main := (
   (local inputs)
   (local args)

   (typecheck-init())

   (local mode)
   (set mode Compile)

   (set args (tail argv))

   (while args (match args (
      ()
      ( (-o (tgt remainder)) (
         (set cli-config ( cli-config (Target tgt)))
         (set args remainder)
      ))
      ( (--compile remainder) (
         (set mode Compile)
         (set args remainder)
      ))
      ( (--strict remainder) (
         (set mode Strict)
         (set args remainder)
      ))
      ( (--parse remainder) (
         (set mode Parse)
         (set args remainder)
      ))
      ( (--nostd remainder) (
         (set mode Strict)
         (set config-nostd True)
         (set args remainder)
      ))
      ( (--parse-expression remainder) (
         (set mode ParseExpression)
         (set args remainder)
      ))
      ( (--tokenize remainder) (
         (set mode Tokenize)
         (set args remainder)
      ))
      ( (--typecheck remainder) (
         (set mode Typecheck)
         (set args remainder)
      ))
      ( (fp remainder) (
         (set inputs (fp inputs))
         (set args remainder)
      ))
      ( u (
         fail (UnexpectionCommand u)
      ))
   )))

   (while inputs (match mode (
      ()
      (Compile (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Strict (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Parse (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (Typecheck (
         (parse-program (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (ParseExpression (
         (print-s (parse-expression (tokenize-file (head inputs))))
         (set inputs (tail inputs))
      ))
      (Tokenize (
         (print-s (tokenize-file (head inputs)))
         (set inputs (tail inputs))
      ))
      (u (
         (fail (UnknownMode u))
      ))
   )))

   (set parse-parsed-program (parse-apply-macros parse-parsed-program))

   (match mode (
      ()
      (Compile (assemble parse-parsed-program))
      (Strict (assemble (typecheck parse-parsed-program)))
      (Parse (print-s parse-parsed-program))
      (Typecheck (print-s (typecheck-show-ascript (typecheck parse-parsed-program))))
   ))
);

# Tokenizer 

tokenize-file := λpath . (match path (
   ()
   (() ())
   ((_ _) ())
   (fp (tokenize (load-file fp)))
));


tokenize := λtext . (tail(
   (local program)
   (local buffer)
   (local in_comment)
   (local char)

   (while text (
      (set char (head-string text))
      (set text (tail-string text))
   (match char (      
      ()

#     These characters are special characters
#     They are removed during tokenization
      (\o (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment True)
      ))
      (\n (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set in_comment ())
      ))
      (\s (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))
      (\t (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      ))

#     These characters are special characters
#     They are isolated during tokenization
      (\[ (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \[))
      )))
      (\] (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \]))
      )))
      (\' (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \'))
      )))
      (\: (if in_comment () (
         (if buffer (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
         (set program (program \:))
      )))

      (c (if in_comment () (
         (set buffer (
            buffer (clone-rope c)
         ))
         (if (eq(\l (clone-rope buffer))) (
            (set program (program (clone-rope buffer)))
            (set buffer ())
         ) ())
      )))
   ))))
   (if buffer (
      (set program (program (clone-rope buffer)))
   ) ())
   (reverse-list program)
));

# Parser

parse-program := λtoks . (tail(
   (local pme)
   (local pme2)
   (while toks (
      match toks (
         ()
         ((\: remainder) (
            (set toks remainder)
         ))
         (('macro remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-one-expression remainder))
            (set parse-macros (parse-macros (Macro( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('fragment remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (parse-expect( := remainder ))
            (set remainder (tail remainder))
            (set pme2 (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Fragment( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('type remainder) (
            (set pme (parse-one-expression remainder))
            (set remainder (tail pme))
            (set pme2 (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Type( (head pme) (head pme2) )) ))
            (set toks (tail pme2))
         ))
         (('import (relative-path remainder)) (
            (parse-program (tokenize-file relative-path))
            (set toks remainder)
         ))
         ((key (:= remainder)) (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program ( parse-parsed-program (Global (key (head pme))) ))
            (set toks (tail pme))
         ))
         (remainder (
            (set pme (parse-many-expressions remainder))
            (set parse-parsed-program (parse-parsed-program (GExpr (head pme)) ))
            (set toks (tail pme))
         ))
      )
   ))
));

merge-list := λl r . (tail( if l (
   (while r (
      (set l (l (tail r)))      
      (set r (head r))
   ))
   l
) r ));

substitute-macro-body := λkvs e . (match e (
   ()
   ((Variable n) (tail(
      (while kvs (match kvs (
         ()
         ( Accept (set kvs ()) )
         ( (ks Accept) (set kvs ks) )
         ( (ks ()) (set kvs ks) )
         ( (ks (KV(k v))) (
            (if (eq(n k)) (
               (set e v)
               (set kvs ())
            ) (
               (set kvs ks)
            ))
         ))
         ( u (fail (UnrecognizedKVMacro kvs)))
      )))
      e
   )))
   ( () () )
   ( (vl vr) (
      (substitute-macro-body( kvs vl ))
      (substitute-macro-body( kvs vr ))
   ))
   ( v v )
));

try-destructure-macro := λlhs e . (match (lhs e) (
   ()
   ( ( Nil Nil ) Accept )
   ( ( (App(pl pr)) (App(el er)) ) (tail(
      (local ll)
      (set ll (try-destructure-macro(pl el)))
      (local rl)
      (set rl (try-destructure-macro(pr er)))
      (if ll (
         (if rl (
            (merge-list( ll rl ))
         ) ())
      ) ())
   )))
   ( ((Literal pl) (Variable el)) (
      (if (eq( pl el )) Accept ())
   ))
   ( ((Literal pl) (Literal el)) (
      (if (eq( pl el )) Accept ())
   ))
   ( ( (App( (Literal :Literal:) (Variable pv) )) (Literal el)) (
      (Accept (KV( pv e )))
   ))
   ( ( (App( (Literal :Variable:) (Variable pv) )) (Variable el)) (
      (Accept (KV( pv e )))
   ))
   ( ((Variable pv) e) (
      (Accept (KV( pv e )))
   ))
));

parse-macro-yield-uuids := λids program . (match program (
   ()
   ( (App( (Variable 'uuid) (Variable x) )) (
      (ids ( x (Variable (uuid())) ))
   ))
   ( (l r) (
      (parse-macro-yield-uuids( (parse-macro-yield-uuids( ids l )) r ))
   ))
   ( u ids )
));

parse-macro-substitute-uuids := λids program . (match program (
   ()
   ( (App( (Variable 'uuid) (Variable x) )) (tail(
      (local id)
      (set id program)
      (while ids (tail(
         (local bind)
         (set bind (tail ids))
         (set ids (head ids))
         (if (eq( (head bind) x )) (
            (set id (tail bind))
         ) ())
      )))
      id
   )))
   ( (l r) (
      (parse-macro-substitute-uuids( ids l ))
      (parse-macro-substitute-uuids( ids r ))
   ))
   ( a a )
));

parse-apply-macros := λprogram . (tail(
   (local macros)
   (set macros parse-macros)
   (while macros (match macros (
      ()
      ( (ms (Macro( lhs rhs ))) (tail(
         (local new)
         (set new (try-destructure-macro( lhs program )))
         (if new (tail(
            (set program (substitute-macro-body( new rhs )))
            (set program (parse-macro-substitute-uuids (
               (parse-macro-yield-uuids( () program ))
               program
            )))
            (set program (parse-apply-macros program))
         )) ())
         (set macros ms)
      )))
      ( u (fail (UnrecognizedMacro u)))
   )))
   (match program (
      ()
      ( (l r) (
         (parse-apply-macros l)
         (parse-apply-macros r)
      ))
      ( () () )
      (u u)
   ))
));

parse-lambda := λtoks . (tail(
   (local remainder)
   (local pme)
   (set pme (parse-one-expression toks))
   (local lmb)
   (set lmb (head pme))
   (set toks (tail pme))
   (match lmb (
      ()
      ((Literal .) (
         (set pme (parse-many-expressions toks))
         (set lmb (Nil (head pme)))
         (set remainder (tail pme))
         (set toks ())
      ))
   ))
   (while toks (
      (set pme (parse-one-expression toks))
      (match pme (
         ()
         (((Literal .) r) (
            (set pme (parse-many-expressions r))
            (set lmb (lmb (head pme)))
            (set remainder (tail pme))
            (set toks ())
         ))
         ((e ()) (
            (parse-expect( . toks ))
            (set toks ())
         ))
         ((e r) (
            (set lmb (App (lmb e)))
            (set toks r)
         ))
      ))
   ))	
   (lmb remainder)
));

parse-unexpect := λt . fail (UnexpectedToken t);
parse-expect := λt ts . (if (eq( t (head ts) )) () (fail (ExpectedToken t)));

parse-one-expression := λtoks . (tail(
   (local pme)
   (local remainder)
   (local expr)
   (match toks (
      ()
      ( () (
         (set expr Nil)
         (set remainder ())
      ))
      ( ( \l r ) (
         (set pme (parse-lambda r))
         (set expr (Lambda (head pme)))
         (set remainder (tail pme))
      ))
      ( ( \] r ) (
         (parse-unexpect (head toks))
      ))
      ( ( \[ r ) (
         (set pme (parse-many-expressions r))
         (set expr (head pme))
         (set remainder (tail pme))
      ))
      ( ( \\ (\' r) ) (
         (set expr (Literal \'))
         (set remainder r)
      ))
      ( ( \' (i r) ) (
         (set expr (Literal i))
         (set remainder r)
      ))
      ( (a r) (
         (if (is-variable a) (
            (set expr (Variable a))
         ) (
            (set expr (Literal a))
         ))
         (set remainder r)
      ))
   ))
   (expr remainder)
));

parse-many-expressions := λtoks . (tail(
   (local pme)
   (local expr)
   (local remainder)
   (while toks (
      (match toks (
         ()
         ((\: tl) (
            (set remainder toks)
            (set toks ())
         ))
         ((\] tl) (
            (if expr () (set expr Nil))
            (set remainder tl)
            (set toks ())
         ))
         (_ (
            (set pme (parse-one-expression toks))
            (if expr (
               (set expr (App( expr (head pme) )))
            ) (
               (set expr (head pme))
            ))
            (set toks (tail pme))
         ))
      ))
   ))
   (expr remainder)
));

parse-expression := λtoks . (parse-many-expressions toks);

# Typechecker

typecheck := λprogram . (tail(
   (local p)
   (set p program)
   (while p (
      (typecheck-infer-type-expr( (tail p) ))
      (set p (head p))
   ))
   (set typecheck-types-have-changed True)
   (while typecheck-types-have-changed (
      (set typecheck-types-have-changed ())
      (typecheck-infer-prog program)
   ))
   program
));

typecheck-lookup-type := λterm . (tail(
   (local tctx)
   (set tctx typecheck-context)
   (local found)
   (local ttt)
   (while tctx (
      (set ttt (head tctx))
      (if (is( (head ttt) term )) (
         (set found (tail ttt))
         (set tctx ())
      ) (
         (set tctx (tail tctx))
      ))
   ))
   found
));

typecheck-ascript := λt tt . (
   if tt (
      (set typecheck-context ((t tt) typecheck-context))
      (set typecheck-types-have-changed True)
   ) ()
);

typecheck-show-ascript := λp . (tail(
   (local term)
   (set term (match p (
      ()
      ( () () )
      ( Nil p )
      ( (Variable _) p )
      ( (Literal _) p )
      ( (App( f x )) (
         (App( (typecheck-show-ascript f) (typecheck-show-ascript x) ))
      ))
      ( (Lambda( lhs rhs )) (
         (Lambda( (typecheck-show-ascript lhs) (typecheck-show-ascript rhs) ))
      ))
      ( (prog (GExpr( g ))) (
         ( (typecheck-show-ascript prog) (GExpr( typecheck-show-ascript g )) )
      ))
      ( (prog (Global( n v ))) (
         ( (typecheck-show-ascript prog) (Global( n (typecheck-show-ascript v) )) )
      ))
      ( (prog (Type( tn td ))) (
         ( (typecheck-show-ascript prog) (Type( tn td )) )
      ))
      ( (prog (Fragment( (Variable fragf) body ))) (
         (fail (DefineFragment fragf))
      ))
      ( (prog (Fragment( typf body ))) (
         (fail (DefineFragment typf))
      ))
      ( unknown (
         fail (UnknownTerm unknown)
      ))
   )))

   (local type)
   (set type (typecheck-lookup-type p))
   (if type (
      (if (eq( type ? )) (
         term
      ) ( 
         (:( term type ))
      ))
   ) (
      term
   ))
));

typecheck-infer-prog := λp . (
   (while p (
      (typecheck-infer-expr( typecheck-global-context (tail p) ))
      (set p (head p))
   ))
);

typecheck-infer-ctx := λctx e . (match e (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (ctx (v (typecheck-typeof-ascript tt)))
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      ( (typecheck-infer-ctx( ctx ps )) (v (typecheck-typeof-ascript tt)))
   ))
   ( (Variable v) (
      (ctx (v S))
   ))
   ( (App( ps (Variable v) )) (
      ( (typecheck-infer-ctx( ctx ps )) (v S))
   ))
   ( Nil (
      ctx
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typecheck-typeof-gvar := λv . (tail(
   (local gctx)
   (set gctx typecheck-global-context)
   (local tt)
   (while gctx (
      (match (tail gctx) (
         ()
         ( (Global( gn gt )) (
            (if (eq( v gn )) (
               (if tt (
                  (set tt (And(tt gt)) )
               ) (
                  (set tt gt)
               ))
            ) ())
            (set gctx (head gctx))
         ))
      ))
   ))
   tt
));

typecheck-typeof-var := λctx v . (match ctx (
   ()
   ( () (typecheck-typeof-gvar v) )
   ( (cs (cv ct)) (
      if (eq( v cv )) (
         ct
      ) (
         (typecheck-typeof-var( cs v ))
      )
   ))
));

typecheck-typeof-ascript := λtt . (match tt (
   ()
   ( (Literal tname) (
      tname
   ))
   ( (Variable tname) (
      tname
   ))
));

typecheck-typeof-lhs := λlhs . (match lhs (
   ()
   ( (App( (App( (Literal :) (Variable v) )) tt )) (
      (typecheck-typeof-ascript tt)
   ))
   ( (App( ps (App( (App( (Literal :) (Variable v) )) tt )) )) (
      (Cons( (typecheck-typeof-lhs ps) (typecheck-typeof-ascript tt) ))
   ))
   ( (Variable v) (
      S
   ))
   ( (App( ps (Variable v) )) (
      (Cons( (typecheck-typeof-lhs ps) S ))
   ))
   ( Nil (
      Nil
   ))
   ( u (
      fail (UnknownLhs u)
   ))
));

typecheck-unify-sub := λctx v . (match ctx (
   ()
   ( Accept v )
   ( (Bind( s1 s2 )) (
      if (eq( v s1 )) s2 v
   ))
   ( (ctxl ctxr) (tail(
      (local lv)
      (set lv (typecheck-unify-sub( ctxl v )))
      (local rv)
      (set rv (typecheck-unify-sub( ctxr v )))
      (if (is( lv v )) (
         (if (is( rv v )) () (set v rv))
      ) (set v lv))
      v
   )))
));

typecheck-unify-ctx := λctx v . (match v (
   ()
   ( (vl vr) (
      ( (typecheck-unify-ctx( ctx vl )) (typecheck-unify-ctx( ctx vr )) )
   ))
   ( _ (
      (typecheck-unify-sub( ctx v ))
   ))
));

typecheck-unify-implies := λlt rt . (if (eq(lt rt)) True (tail(
   (local accept)
   (local subtypes)
   (local st)
   (set subtypes typecheck-subtypes)
   (while subtypes (
      (set st (tail subtypes))
      (if (eq( (head st) lt )) (
         (if (eq( (tail st) rt )) (
            (set accept True)
         ) ())
      ) ())
      (set subtypes (head subtypes))
   ))
   accept
)));

typecheck-unify-args := λlt rt . (match (lt rt) (
   ()
   ( ((lt1 rt1) (lt2 rt2)) (
      (match ( (typecheck-unify-args(lt1 lt2)) (typecheck-unify-args(rt1 rt2)) ) (
         ()
         ( (() _) () )
         ( (_ ()) () )
         ( (lctx rctx) (lctx rctx) )
      ))
   ))
   ( (a1 a2) (
      (if (typecheck-unify-implies( a2 a1 )) ( # argument type must imply parameter type
         Accept
      ) (
         (if (is-variable a1) (
            (if (is-variable a2) (
               Accept
            ) (
               (Bind( a1 a2 ))
            ))
         ) (
            (if (is-variable a2) (
               (Bind( a2 a1 ))
            ) (
               ()
            ))
         ))
      ))
   ))
   (_ (tail(
      (fail (UnknownUnify lt rt))
      ?
   )))
));

typecheck-apply-plural := λmany pt . (match many(
   ()
   ( (And( t1 t2 )) (tail(
      (local r)
      (set r (typecheck-apply-plural( t1 pt )))
      (if r r (typecheck-apply-plural( t2 pt )))
   )))
   ( (->(lt rt)) (
      (typecheck-unify-ctx( (typecheck-unify-args(lt pt)) rt ))
   ))
));

typecheck-safe-apply-plural := λterm many pt . (tail(
   (local r)
   (set r (typecheck-apply-plural( many pt )))
   (if r r (
      fail (TypeError( InvalidArgument many pt ))
   ))
));

typecheck-infer-type-compound := λcompound . (match compound (
   ()
   ((Literal tt) tt)
   ((App( lt rt )) (Cons( (typecheck-infer-type-compound lt) (typecheck-infer-type-compound rt) )))
   (u (fail (UnknownTypeCompound u)))
));

typecheck-infer-type-constructor := λname body . (match body (
   ()
   ( (Literal tag) (
      (set typecheck-constructors ( typecheck-constructors (tag tag) ))
      (set typecheck-subtypes ( typecheck-subtypes (tag (typecheck-infer-type-compound name)) ))
   ))
   ( (App( (Literal tag) args )) (
      (local ctype)
      (set ctype (typecheck-infer-type-compound args))
      (set typecheck-constructors ( typecheck-constructors (tag (->(ctype (tag ctype)))) ))
      (set typecheck-subtypes ( typecheck-subtypes ((tag ctype) (typecheck-infer-type-compound name)) ))
   ))
));

typecheck-infer-type-definition := λname def . (match def (
   ()
   ( (App( (App( tds (Literal |) )) body )) (
      (typecheck-infer-type-definition( name tds ))
      (typecheck-infer-type-constructor( name body ))
   ))
   ( body (
      (typecheck-infer-type-constructor( name body ))
   ))
));

typecheck-infer-constructor-type := λtag . (tail(
   (local ctype)
   (local constructors)
   (set constructors typecheck-constructors)
   (while constructors (
      (if (eq( tag (head(tail(constructors))) )) (
         (if ctype (
            (set ctype (And( ctype (tail(tail(constructors))) )))
         ) (
            (set ctype (tail(tail(constructors))))
         ))
      ) ())
      (set constructors (head constructors))
   ))
   ctype
));

typecheck-infer-type-expr := λe . (match e (
   ()
   ( (Type( l ds )) (
      (typecheck-infer-type-definition( l ds ))
      (typecheck-ascript( e ? ))
   ))
   (_ ())
));

typecheck-infer-expr := λctx e . (
   (if (typecheck-lookup-type e) () (
      match e (
         ()
         ( () () )
         ( (GExpr ge) (
            (typecheck-infer-expr( ctx ge ))
         ))
         ( (Global( gln gle )) (
            (typecheck-infer-expr( ctx gle ))
            (match (typecheck-lookup-type gle) (
               ()
               ( () () )
               ( glt (
                  (set typecheck-global-context ( typecheck-global-context (Global( gln glt )) ))
                  (typecheck-ascript( e ? ))
               ))
            ))
         ))
         ( (Type( l ds )) ())
         ( (Fragment( _ _ )) ())
         ( Nil (
            (typecheck-ascript( e Nil ))
         ))
         ( (App( (App( (Literal :) (Literal _) )) tt )) (
            (typecheck-ascript( e (typecheck-infer-type-compound tt) ))
         ))
         ( (Literal lit) (
            (local ctype)
            (set ctype (typecheck-infer-constructor-type lit))
            (if ctype (
               (typecheck-ascript( e (And( ctype Atom )) ))
            ) (
               (typecheck-ascript( e Atom ))
            ))
         ))
         ( (App( l r )) (
            (typecheck-infer-expr( ctx l ))
            (typecheck-infer-expr( ctx r ))
            (match ( (typecheck-lookup-type l) (typecheck-lookup-type r) ) (
               ()
               ( (() _) () )
               ( (_ ()) () )
               ( ( (->(lt rt)) pt ) (
                  (typecheck-ascript( e (typecheck-safe-apply-plural( e (->(lt rt)) pt )) ))
               ))
               ( ( (And(t1 t2)) pt ) (
                  (typecheck-ascript( e (typecheck-safe-apply-plural( e (And(t1 t2)) pt )) ))
               ))
               ( (lt rt) (
                  (typecheck-ascript( e (Cons(lt rt)) ))
               ))
            ))
         ))
         ( (Lambda( lhs rhs )) (
            (set ctx (typecheck-infer-ctx( ctx lhs )))
            (typecheck-infer-expr( ctx rhs ))
            (match (typecheck-lookup-type rhs) (
               ()
               ( () () )
               ( rt (
                  (typecheck-ascript( e (->( (typecheck-typeof-lhs lhs) rt)) ))
               ))
            ))
         ))
         ( (Variable v) (
            (match (typecheck-typeof-var( ctx v )) (
               ()
               ( () () )
               ( tt (typecheck-ascript( e tt )) )
            ))
         ))
         ( u (fail (UnknownTerm u)) )
      )
   ))
);

# Assembler

assemble := λprogram . (
   (local target)
   (set target 'tmp.s)
   (while cli-config (
      (match (tail cli-config) (
         ()
         ((Target t) (set target t))
      ))
      (set cli-config (head cli-config))
   ))

   (local main_e)
   (local main_pd)

   (local e1)
   (local e2)

   (local output_pd)
   (set output_pd ( () (assemble-data-header()) ))

   (local global_ctx)
   (local preview_program)
   (set preview_program program)

   (while preview_program (match preview_program (
      ()
      ( (pc1 (Global ('main body))) (
         (set preview_program pc1)
      ))
      ( (pc2 (GExpr e)) (
         (set preview_program pc2)
      ))
      ( (pc3 (Global (fname body))) (
         (match body (
            ()
            ( Nil (
               (set output_pd (
                  (head output_pd)
                  (
                     (tail output_pd)
                     (label-case fname)
                     ': \n \t '.zero \s '16 \n
                  )
               ))
               (set global_ctx (global_ctx (GlobalVariable fname)))
            ))
            ( (Lambda(lhs rhs)) (
               (set global_ctx (global_ctx (GlobalFunction( fname body ))))
            ))
         ))
         (set preview_program pc3)
      ))
      ( (prog (Fragment( _ _ ))) (
         (set preview_program prog)
      ))
      ( (prog (Type( _ _ ))) (
         (set preview_program prog)
      ))
      ( u (
         (fail (UnexpectedProgram (tail u)))
      ))
   )))

   (while program (match program (
      ()
      ( (pc (Global ('main body))) (
         (set main_e body)
         (set program pc)
      ))
      ( (pc (GExpr e)) (
         (set main_pd (compile-append( main_pd global_ctx e )))
         (set program pc)
      ))
      ( (pc (Global (fname body))) (
         (match body (
            ()
            ( Nil (
            ))
            ( (Lambda(lhs rhs)) (
               (set e1 (destructure-args(global_ctx lhs ())))
               (set e2 (compile-expr((get-pc e1) rhs (get-offset e1) Used)))
               (set output_pd ( ((head output_pd) (mangle-global-function( fname body )) ': \n) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (enter-function())) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-frame e1)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-frame e2)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-prog e1)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-prog e2)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (exit-function())) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-text e1)) (tail output_pd) ))
               (set output_pd ( ((head output_pd) (get-text e2)) (tail output_pd) ))
               (set output_pd ( (head output_pd) ((tail output_pd) (get-data e1)) ))
               (set output_pd ( (head output_pd) ((tail output_pd) (get-data e2)) ))
            ))
         ))
         (set program pc)
      ))
   )))

   (if main_e (
      (set main_pd (compile-append( main_pd global_ctx main_e )))
   ) ())

   (set output_pd (
      (
         (assemble-program-header())
         (before-main())
         (enter-function())
         (get-frame main_pd)
         (get-prog main_pd)
         (exit-cleanup())
         (head output_pd)
         (get-text main_pd)
         (if config-nostd () (stdlib-functions()))
      )
      ((if config-nostd () (stdlib-data())) (tail output_pd) (get-data main_pd))
   ))
   (set output_pd (
      ((head output_pd) assemble-text-section)
      ((tail output_pd) assemble-data-section)
   ))

   (write-file (target (clone-rope output_pd)))
);

# Compile Codegen

compile-include-argv := λ. if compile-argv-hook () (set compile-argv-hook (compile-argv-hook (
   \t 'pop \s '%r10                    \n # put argc in %r10
   \t 'mov \s '$argv, \s '%r9          \n
   \t 'movq \s '$0, \s '0 \[ '%r9 \]   \n
   \t 'movq \s '$0, \s '8 \[ '%r9 \]   \n

   'before_main_argv:                  \n
   \t 'cmp \s '$0, \s '%r10            \n
   \t 'je \s 'before_main_end          \n

   \t 'pop \s '%r12                    \n #this = argv[i]
   \t 'mov \s '$0, \s '%r13            \n
   (close())                              #r8 is argv[i]

   \t 'mov \s '%r8, \s '0 \[ '%r9 \]   \n #set t.head = argv[i]
   \t 'mov \s '$0, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13            \n
   (close())
   \t 'mov \s '%r8, \s '8 \[ '%r9 \]   \n #set t.tail = ()
   \t 'mov \s '%r8, \s '%r9            \n #set t = t.tail

   \t 'dec \s '%r10                    \n #dec argc
   \t 'jmp \s 'before_main_argv        \n

   'before_main_end:                   \n
)));

compile-append := λoutput_e gctx e . (tail(
   (set e (compile-expr( gctx e (get-offset output_e) Used )))
   (Expr(
      ((get-frame output_e) (get-frame e))
      ((get-prog output_e) (get-prog e))
      ((get-unframe output_e) (get-unframe e))
      ((get-text output_e) (get-text e))
      ((get-data output_e) (get-data e))
      (get-pc e)
      (get-offset e)
   ))
));

compile-expr := λctx e offset used . (tail(
   (local e1)
   (local e2)
   (local e3)
   (local prog)
   (local tail_safe)
   (local return)
   (set return (match e (
      ()
      ( (Variable '$_) (tail(
         ()
         (Expr( () () () () () ctx offset ))
      )))
      ( (Variable 'argv) (tail(
         (compile-include-argv())
         (set prog (prog ( \t 'mov \s '$argv, \s '%r8 \n )))
         (set prog (prog ( \t 'mov \s '0 \[ '%r8 \] , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '8 \[ '%r8 \] , '%r13 \n )))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (Variable vname) (tail(
         ()
         (Expr( () (get-local(ctx vname)) () () () ctx offset ))
      )))
      ( (App ((Variable 'local) (Variable fname))) (tail(
         (set e1 (declare-local(ctx fname offset)))
         (Expr( (get-frame e1) ((yield-nil()) (get-prog e1)) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( (App( (Lambda( (Variable lhs) rhs )) bind )) (tail(
         (set e1 (declare-local(ctx lhs offset)))
         (set e2 (compile-expr((get-pc e1) bind (get-offset e1) Used)))
         (set e3 (compile-expr((get-pc e2) rhs (get-offset e2) Used)))
         (set prog ( prog (yield-nil()) (get-prog e1) ))
         (set prog ( prog (get-prog e2) (set-local((get-pc e2) lhs)) ))
         (set prog ( prog (get-prog e3) ))
         (Expr(
            ((get-frame e1) (get-frame e2) (get-frame e3))
            prog
            ((get-unframe e1) (get-unframe e2) (get-unframe e3))
            ((get-text e1) (get-text e2) (get-text e3))
            ((get-data e1) (get-data e2) (get-data e3))
            (get-pc e3) (get-offset e3)
         ))
      )))
      ( (App( (App( (Variable 'set) (Variable vname) )) x )) (tail(
         (set e1 (compile-expr(ctx x offset Used)))
         (set prog ((get-prog e1) (set-local(ctx vname))))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( (App( (App( (Variable 'while) c )) d )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e2 (compile-expr((get-pc e1) d (get-offset e1) Unused)))
         (local label_while_start)
         (set label_while_start (uuid()))
         (local label_while_end)
         (set label_while_end (uuid()))
         (set prog (prog (label_while_start ': \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_while_end \n)))
         (set prog (prog (get-prog e2)))
         (set prog (prog (\t 'jmp \s label_while_start \n)))
         (set prog (prog (label_while_end ': \n)))
         (set tail_safe True)
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( (App( (Variable 'exit) (Literal _) )) (tail(
         (set tail_safe True)
         (set prog (
            \t 'mov \s '$60, \s '%rax          \n
            \t 'mov \s '$1 , \s '%rdi          \n
            \t 'syscall                        \n
         ))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( (App( (App( (Variable 'if) c )) t )) f )) (tail(
         (set e1 (compile-expr(ctx c offset Used)))
         (set e2 (compile-expr( (get-pc e1) t (get-offset e1) Used )))
         (set e3 (compile-expr( (get-pc e2) f (get-offset e2) Used )))
         (local label_if_true)
         (set label_if_true (uuid()))
         (local label_if_end)
         (set label_if_end (uuid()))
         (set prog (prog (get-prog e1)))
         (set prog (prog ( \t 'cmp \s '$0, '%r12 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog ( \t 'cmp \s '$0, '%r13 \n )))
         (set prog (prog ( \t 'jne \s label_if_true \n )))
         (set prog (prog (get-prog e3)))
         (set prog (prog ( \t 'jmp \s label_if_end \n )))
         (set prog (prog ( label_if_true ': \n )))
         (set prog (prog (get-prog e2)))
         (set prog (prog ( label_if_end ': \n )))
         (Expr(
            ((get-frame e1) (get-frame e2) (get-frame e3))
            prog
            ((get-unframe e1) (get-unframe e2) (get-unframe e3))
            ((get-text e1) (get-text e2) (get-text e3))
            ((get-data e1) (get-data e2) (get-data e3))
            (get-pc e3)
            (get-offset e3)
         ))
      )))
      ( (App( (App( (Variable 'match) t )) p )) (tail(
         (set e1 (compile-expr(ctx t offset Used)))
         (set e2 (yield-patterns((get-pc e1) p (get-offset e1))))
         (local label_skip)
         (set label_skip (uuid()))
         (set prog ((get-prog e1) (get-prog e2)))
         (set prog (prog ( \t 'cmp \s '$0, \s %r14 \n )))
         (set prog (prog ( \t 'jne \s label_skip \n )))
         (set prog (prog (yield-nil())))
         (set prog (prog ( label_skip ': \n )))
         (Expr(
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      ( (App ((Variable fname) arg)) (tail(
         ()
         (if (is-builtin fname) (tail(
            ()
            (if (eq(fname 'tail)) (tail(
               (set e1 (compile-expr(ctx arg offset Tail)))
               (Expr( (get-frame e1) (get-prog e1) (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
            )) (tail(
               (set e1 (compile-expr(ctx arg offset Used)))
               (set prog ((get-prog e1) (\t 'call \s (label-case fname) \n)))
               (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
            )))
         )) (tail(
            ()
            (match (get-maybe-function(ctx fname arg)) (
               ()
               ( (GlobalFunction mangledname) (tail(
                  (set e1 (compile-expr(ctx arg offset Used)))
                  (set prog ((get-prog e1) (\t 'call \s mangledname \n)))
                  (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
               )))
               ( () (
                  (fail (ReferenceToUndefinedVariable fname (typecheck-lookup-type arg)))
               ))
               ( v (tail(
                  ()
                  (yield-cons(ctx v arg offset Used))
               )))
            ))
         )))
      )))
      ( (Literal l) (tail(
         ()
         (yield-atom (ctx l offset))
      )))
      ( Nil (tail(
         (set prog (prog ( \t 'mov \s '$0 , '%r12 \n )))
         (set prog (prog ( \t 'mov \s '$0 , '%r13 \n )))
         (set tail_safe True)
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App (l r)) (tail(
         (set tail_safe True)
         (yield-cons(ctx l r offset used))
      )))
      ( (GlobalVariable mangled-name) (tail(
         (set prog (
            \t 'mov \s '$ mangled-name , \s %r15   \n
            \t 'mov \s '0 \[ %r15 \] , \s %r12     \n
            \t 'mov \s '8 \[ %r15 \] , \s %r13     \n
         ))
         (Expr( () prog () () () ctx offset ))
      )))
      ( u (fail (UnrecognizedExpression u)) )
   )))
   (if tail_safe return (tail(
      ()
      (if (eq(used Tail)) (tail(
         (set prog (get-prog return))
         (set prog (prog (\t 'call \s 'tail \n)))
         (Expr( (get-frame return) prog (get-unframe return) (get-text return) (get-data return) (get-pc return) (get-offset return) ))
      )) (
         return
      ))
   )))
));

# Utility Functions

fail := λmsg . (print-s msg) (exit 1);

deep-eq := λl r . match (l r) (
   ()
   ( (() ()) True )
   ( ((ll lr) (rl rr)) (
      if (deep-eq( ll rl )) (
         (deep-eq( lr rr ))
      ) ()
   ))
   ( (la ra) (eq( la ra )) )
);

reverse-list := λl . (tail(
   (local r)
   (while l (
      (set r ( (tail l) r ))
      (set l (head l))
   ))
   r
));

label-case := λk . (match k (
   ()
   (() ())
   ((l r) ('_LP_ (label-case l) (label-case r) '_RP_))
   (a (label-case-atom a))
));

label-case-atom := λk . (tail(
   (local nk)
   (while k (match (head-string k) (
      ()
      (() ())
      ('- (
         (set nk (nk '_))
         (set k (tail-string k))
      ))
      ('< (
         (set nk (nk '_LB_))
         (set k (tail-string k))
      ))
      ('> (
         (set nk (nk '_RB_))
         (set k (tail-string k))
      ))
      (\[ (
         (set nk (nk '_LP_))
         (set k (tail-string k))
      ))
      (\] (
         (set nk (nk '_RP_))
         (set k (tail-string k))
      ))
      ('$ (
         (set nk (nk '_DS_))
         (set k (tail-string k))
      ))
      (c (
         (set nk (nk (clone-rope c)))
         (set k (tail-string k))
      ))
   )))
   (clone-rope nk)
));

is-variable := λv . (match (head-string v) (
   ()
   ('$ True )
   ('_ True )
   ('a True )
   ('b True )
   ('c True )
   ('d True )
   ('e True )
   ('f True )
   ('g True )
   ('h True )
   ('i True )
   ('j True )
   ('k True )
   ('l True )
   ('m True )
   ('n True )
   ('o True )
   ('p True )
   ('q True )
   ('r True )
   ('s True )
   ('t True )
   ('u True )
   ('v True )
   ('w True )
   ('x True )
   ('y True )
   ('z True )
));

get-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r15 \n
                     \t 'mov \s '0 \[ %r15 \] , \s %r12     \n
                     \t 'mov \s '8 \[ %r15 \] , \s %r13     \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (ReferenceToUndefinedVariable v))
   ))
   r
));

set-local := λctx v . (tail(
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local((Set l) lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r lrefer)
               ) ()
            )
         ))
         ( (GlobalVariable l) (
            if r () (
               if (eq(l v)) (
                  (set r (
                     \t 'mov \s '$ (label-case l) , \s %r15 \n
                     \t 'mov \s %r12 , \s '0 \[ %r15 \] \n
                     \t 'mov \s %r13 , \s '8 \[ %r15 \] \n
                  ))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   (if r () (
      (fail (AssignToUndefinedVariable v))
   ))
   r
));

get-frame := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) f)
));
get-prog := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) p)
));
get-unframe := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) u)
));
get-text := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) t)
));
get-data := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) d)
));
get-pc := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) pc)
));
get-offset := λe . (match e (
   ()
   ((Expr(f p u t d pc off)) off)
));

mangle-global-function := λname body . (
   (clone-rope (label-case ( name '_C_ (typecheck-lookup-type body) )))
);

get-maybe-function := λctx v arg . (tail(
   (local arg_type)
   (set arg_type (typecheck-lookup-type arg))
   (local r)
   (while ctx (
      (match (tail ctx) (
         ()
         ( (Local(l lrefer)) (
            if r () (
               if (eq(l v)) (
                  (set r (Variable l))
               ) ()
            )
         ))
         ( (GlobalFunction( name body )) (
            if r () (
               if (eq(name v)) (
                  (local f_type)
                  (set f_type (typecheck-lookup-type body))
                  (if (deep-eq( (head(tail f_type)) arg_type )) (
                     (set r (GlobalFunction (mangle-global-function( name body ))))
                  ) ())
               ) ()
            )
         ))
         ( (GlobalVariable name) (
            if r () (
               if (eq(name v)) (
                  (set r (GlobalVariable (label-case name)))
               ) ()
            )
         ))
      ))
      (set ctx (head ctx))
   ))
   r
));

declare-local := λctx vname offset . (tail(
   (local frame_this)
   (set frame_this (push-zero()))
   (local refer)
   (local eight)
   (set eight (
      inc(inc(inc(inc(inc(inc(inc(inc(
         ()
      ))))))))
   ))
   (local sixteen)
   (set sixteen (mul( eight (inc(inc(()))) )))
   (local set_this)
   (set set_this (
      \t 'mov \s '%r12, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] \n
      \t 'mov \s '%r13, \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] \n
   ))
   (set refer (
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) eight)) (dec(())) )) ))
      ) \[ '%rbp \] , %r12 \n
      \t 'mov \s (
         (i2s( (mul( (add( (mul( sixteen offset )) sixteen)) (dec(())) )) ))
      ) \[ '%rbp \] , %r13 \n
   ))
   (set ctx (ctx (Local(vname refer)) ))
   (set ctx (ctx (Local((Set vname) set_this)) ))
   (Expr(frame_this set_this () () () ctx (inc offset)))
));

i2s := λi . (tail(
   (local ten)
   (set ten( inc(inc(inc(inc(inc( inc(inc(inc(inc(inc( ))))) ))))) ))
   (local sign)
   (local s)
   (local r)
   (if (is-neg i) (
      (set sign '-)
      (set i (inv i))
   ) ())
   (while i (
      (set r (mod(i ten)))
      (set s ((clone-rope(digit r) s)))
      (set i (div(i ten)))
   ))
   (if s () (set s 0))
   (clone-rope (sign s))
));

destructure-args := λctx e offset . (match e (
   ()
   ( Nil (tail(
      ()
      (Expr( () () () () () ctx offset ))
   )))
   ( (App( (App( (Literal :) (Variable n) )) nt )) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( (Variable n) (tail(
      ()
      (declare-local(ctx n offset))
   )))
   ( ( (App( h t )) ) (tail(
      (local ta)
      (set ta (destructure-args(ctx t offset)))
      (set offset (get-offset ta))
      (set ctx (get-pc ta))
      (local ha)
      (set ha (destructure-args(ctx h offset)))
      (set offset (get-offset ha))
      (set ctx (get-pc ha))
      (local prog)
      (set prog (prog (push-this()) ))
      (set prog (prog (\t 'call \s 'tail \n) ))
      (set prog (prog (get-prog ta) ))
      (set prog (prog (pop-this()) ))
      (set prog (prog (\t 'call \s 'head \n) ))
      (set prog (prog (get-prog ha) ))
      (Expr(
         ( (get-frame ta) (get-frame ha) )
         prog
         ( (get-unframe ta) (get-unframe ha) )
         () () ctx offset
      ))
   )))
   ( _ (
      (fail (InvalidFunctionParameters DidYouForgetToSeparateADotTokenInFunctionParam? e))
   ))
));

# Data Segments

assemble-data-header := λ .(
  '.data                                  \n
);

stdlib-data := λ .(
  'load_file_bsz:                         \n
  \t '.quad \s '1024                      \n
  'load_file_buf:                         \n
  \t '.zero \s '1024                      \n
  'argv:                                  \n
  \t '.zero \s '16                        \n
  'nil_literal:                           \n
  \t '.ascii \s " \[ \] "                 \n
  \t '.zero \s 1                          \n
  'newline:                               \n
  \t '.ascii \s " \\n "                   \n
  'left_paren:                            \n
  \t '.ascii \s " \[ "                    \n
  'right_paren:                           \n
  \t '.ascii \s " \] "                    \n
  'space:                                 \n
  \t '.ascii \s " \s "                    \n
  'true:                                  \n
  \t '.ascii \s "True"                    \n
  \t '.zero \s '1                         \n
  '__digit:                               \n
  \t '.zero \s '2                         \n
  'hex_buffer:                            \n
  \t '.ascii \s "0123456789abcdef"        \n
  '__mutable_char:                        \n
  \t '.zero \s '2                         \n
  '__dump_i:                              \n
  \t '.ascii \s '"0000000000000000"       \n
  \t '.zero \s '1                         \n
  'err_fopen:                             \n
  \t '.ascii \s '"Could \s 'not \s 'open \s 'file."  \n
  \t '.zero \s '1                         \n
);

assemble-program-header := λ .(
   '.global \s '_start                    \n
   '.text                                 \n
   '_start:                               \n
   \t 'jmp \s 'main                       \n
);

stdlib-functions := λ . (
   'print_s:                           \n
   # if .head is zero, then this is Nil
   \t 'cmp \s '$0, \s '%r12            \n
   \t 'je \s 'print_s_nil              \n

   # if only .tail is zero, then this is an Atom
   \t 'cmp \s '$0, \s '%r13            \n
   \t 'je \s 'print_s_atom             \n

   # if .head and .tail are non-zero, then this is a Cons
   (system-call( '$1 '$1 '$left_paren '$1 ))
   (push-this())
   \t 'call \s 'head                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$space '$1 ))
   (push-this())
   \t 'call \s 'tail                   \n
   \t 'call \s 'print_s                \n
   (pop-this())
   (system-call( '$1 '$1 '$right_paren '$1 ))
   \t 'ret                             \n

   'print_s_nil:                       \n
   # nil is two bytes "()" located in the data section at $nil_literal
   (system-call( '$1 '$1 '$nil_literal '$2 ))
   \t 'ret                             \n

   'print_s_atom:                      \n
   \t 'call \s 'strlen                 \n # %r8 is string length of this atom
   (system-call( '$1 '$1 '%r12 '%r8 )) \n
   \t 'ret                             \n

   'is_atom:                              \n
   \t 'cmp \s '$0, '%r12                  \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, '%r13                  \n
   \t 'jne \s 'return_nil                 \n
   \t 'jmp \s 'return_true                \n

   'is_cons:                              \n
   \t 'cmp \s '$0, '%r12                  \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, '%r13                  \n
   \t 'je \s 'return_nil                  \n
   \t 'jmp \s 'return_true                \n

   'head_string:                          \n
   \t 'cmp \s '$0, \s %r13                \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s %r12                \n
   \t 'je \s 'return_nil                  \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'movb \s '0 \[ %r12 \] , \s '%bl    \n
   \t 'mov \s '$__mutable_char, \s '%r12  \n
   \t 'movb \s '%bl, \s '0 \[ %r12 \]     \n
   \t 'ret                                \n

   'tail_string:                          \n
   \t 'cmp \s '$0, \s %r13                \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s %r12                \n
   \t 'je \s 'return_nil                  \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'inc \s '%r12                       \n
   \t 'cmpb \s '$0, \s '0 \[ '%r12 \]     \n
   \t 'je \s 'return_nil                  \n
   \t 'ret                                \n

   'head:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
   \t 'ret                                \n

   'tail:                                 \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
   \t 'ret                                \n

   'strlen:                               \n
   \t 'xor \s '%r8, \s '%r8               \n
   \t 'mov \s '%r12, \s '%rax             \n
   'strlen_loop:                          \n
   \t 'cmpb \s '$0, \s '0 \[ '%rax \]     \n
   \t 'jz \s 'strlen_exit                 \n
   \t 'inc \s '%r8                        \n
   \t 'inc \s '%rax                       \n
   \t 'jmp \s 'strlen_loop                \n
   'strlen_exit:                          \n
   \t 'ret                                \n

   'streq:                                \n
   'streq_loop:                           \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ %rax \] , \s '%cl     \n
   \t 'mov \s '0 \[ %rbx \] , \s '%dl     \n

   \t 'cmp \s '%cl, \s '%dl               \n
   \t 'jne \s 'return_nil                 \n
   \t 'cmp \s '$0, \s '%cl                \n
   \t 'je \s 'streq_true                  \n
   \t 'inc \s '%rax                       \n
   \t 'inc \s '%rbx                       \n
   \t 'jmp \s 'streq_loop                 \n
   'streq_true:                           \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'eq:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%rax   \n
   \t 'cmp \s '$0, \s '%rax               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%rbx   \n
   \t 'cmp \s '$0, \s '%rbx               \n
   \t 'je \s 'return_nil                  \n
   \t 'call \s 'streq                     \n
   \t 'ret                                \n

   'return_nil:                           \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'return_true:                          \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'not:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'jne \s 'not_yield_nil              \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
   'not_yield_nil:                        \n
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'clone_rope:                           \n
   \t 'mov \s '$0, \s '%r8                \n
   \t 'mov \s '$0, \s '%r9                \n
   (allocate-atom-grow '$0)
   \t 'call \s '__clone_rope              \n
   (allocate-atom-grow '$1)
   \t 'movb \s '$0, \s '0 \[ %r9 \]       \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   '__clone_rope:                         \n
   #if this is a cons, recurse
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s '__clone_rope_notcons        \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'mov \s '8 \[ %r12 \] , '%r13       \n
   \t 'mov \s '0 \[ %r12 \] , '%r12       \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'mov \s '0 \[ %r13 \] , '%r12       \n
   \t 'mov \s '8 \[ %r13 \] , '%r13       \n
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
   \t 'call \s '__clone_rope              \n
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
   \t 'jmp \s '__clone_rope_end           \n

   #if not cons, concat
   '__clone_rope_notcons:                 \n

   #if nil, return
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s '__clone_rope_end            \n

   #if atom, break into characters and concat
   '__clone_rope_small:                   \n
   \t 'cmpb \s '$0, \s '0 \[ %r12 \]      \n
   \t 'je \s '__clone_rope_end            \n
   (allocate-atom-grow '$1)
   \t 'movb \s '0 \[ %r12 \] , \s '%bl    \n
   \t 'movb \s '%bl, \s '0 \[ %r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r12                       \n
   \t 'jmp \s '__clone_rope_small         \n

   '__clone_rope_end:                     \n
   \t 'ret                                \n

   'is:                                   \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '0 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '8 \[ '%r12 \] , \s '%r8    \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r9    \n
   \t 'cmp \s '%r8, \s '%r9               \n
   \t 'jne \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'is_neg:                               \n
   \t 'cmp \s '$0, \s %r12                \n
   \t 'jge \s 'return_nil                 \n
   \t 'mov \s '$true, \s '%r12            \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'inc:                                  \n
   \t 'inc \s '%r12                       \n
   \t 'ret                                \n

   'dec:                                  \n
   \t 'dec \s '%r12                       \n
   \t 'ret                                \n

   'inv:                                  \n
   \t 'neg \s '%r12                       \n
   \t 'ret                                \n

   'mul:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'imul \s '%rax, \s '%rbx            \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'add:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n  
   \t 'mov \s '0 \[ '%r13 \] , '%rbx      \n
   \t 'add \s '%rax, \s '%rbx             \n
   \t 'mov \s '%rbx, \s '%r12             \n
   \t 'ret                                \n

   'div:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'ret                                \n

   'mod:                                  \n
   \t 'cmp \s '$0, \s '%r12               \n
   \t 'je \s 'return_nil                  \n
   \t 'cmp \s '$0, \s '%r13               \n
   \t 'je \s 'return_nil                  \n
   \t 'mov \s '0 \[ '%r12 \] , '%rax      \n #dividend
   \t 'mov \s '$0, \s '%rdx               \n
   \t 'mov \s '0 \[ '%r13 \] , '%rcx      \n #divisor
   \t 'idiv \s '%rcx                      \n
   \t 'mov \s '%rdx, \s '%r12             \n
   \t 'ret                                \n

   'dump_i:                               \n
   \t 'mov \s '%r12, \s '%r8              \n
   \t 'mov \s '$__dump_i, \s '%r12        \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'mov \s '$__dump_i, \s '%r11        \n
   \t 'cmp \s '$0, \s '%r8                \n
   \t 'jge \s 'dump_i_positive            \n
   \t 'jmp \s 'dump_i_negative            \n
   'dump_i_positive:                      \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$48, \s '0 \[ %r11 \]     \n
   \t 'ret                                \n
   'dump_i_negative:                      \n
   \t 'neg \s '%r8                        \n
   \t 'call \s 'dump_i_digits             \n
   \t 'movb \s '$45, \s '0 \[ %r11 \]     \n
   \t 'ret                                \n
   # if return value is positive then open was a success

   'dump_i_digits:                        \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[0]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '0 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[1]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '1 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[2]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '2 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[3]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '3 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[4]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '4 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[5]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '5 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[6]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '6 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[7]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '7 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[8]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '8 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[9]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '9 \[ %r11 \]      \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[10]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '10 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[11]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '11 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[12]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '12 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[13]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '13 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[14]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '14 \[ %r11 \]     \n
   \t 'rol \s '$4, \s '%r8                \n   # %r8[15]
   \t 'call \s 'put8                      \n
   \t 'mov \s '%cl, \s '15 \[ %r11 \]     \n
   \t 'ret                                \n

   #move ascii representation of lower byte of %r8 into %cl
   'put8:                                 \n
   \t 'mov \s '%r8b, \s '%al              \n # lower byte of %r11 goes into %rax
   \t 'and \s '$0xf, \s '%al              \n # only show lower 4 bits
   \t 'mov \s '$hex_buffer, '%r10         \n # %r10 is index into hex buffer
   \t 'add \s '%al, \s '%r10b             \n # %r10 is index into char in hex buffer
   \t 'mov \s '0 \[ %r10 \] , \s '%cl     \n # %cl is a hexadecimal char
   \t 'ret                                \n

   'digit:                                \n
   \t 'mov \s '%r12, \s '%rax             \n
   \t 'add \s '$48, \s %rax               \n
   \t 'mov \s '$__digit, \s %r12          \n
   \t 'mov \s '%al, \s '0 \[ %r12 \]      \n
   \t 'mov \s '$0, \s %r13                \n
   \t 'ret                                \n

   'write_file:                           \n
   #open file
   \t 'mov \s '0 \[ %r12 \] , \s '%rdi    \n # file name
   \t 'pushq \s '0 \[ %r13 \]             \n # data to write
   \t 'mov \s '$2, \s '%rax               \n # syscall open
   \t 'mov \s '$577, \s %rsi              \n
   \t 'mov \s '$420, \s '%rdx             \n # mode
   \t 'syscall                            \n
   \t 'mov \s '%rax, \s '%r8              \n # r8 now holds file descriptor

   #write to file
   \t 'pop \s '%rax                       \n
   \t 'mov \s '%rax, \s '%r12             \n
   \t 'mov \s '%r8, \s '%r10              \n # %r10 has file descriptor
   \t 'call \s 'strlen                    \n
   (system-call( '$1 '%r10 '%r12 '%r8 ))

   #close file
   (system-call( '$3 '%r10 '$0 '$0 ))
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file:                            \n

   # open file
   (system-call( '$2 '%r12 '$0 '$0 ))
   # file descriptor is in %rax

   \t 'cmp \s '$0, \s '%rax               \n
   # if return value is positive then open was a success
   \t 'jge \s 'load_file_contents         \n

   \t 'mov \s '$err_fopen, \s '%r12       \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n

   'load_file_contents:                   \n
   \t 'mov \s '$0, \s '%r8                \n
   \t 'mov \s '$0, \s '%r9                \n
   (allocate-atom-grow '$0)
   # r8 holds pointer to head of new data
   # r9 holds pointer to tail of new data
   \t 'mov \s '$0, \s '%r10               \n # r10 holds amount of data on buffer currently
   \t 'mov \s '$load_file_buf, \s '%r11   \n # r11 holds pointer to head of buffer

   # move data from buffer into string
   'load_file_loop:                       \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'je \s 'load_file_bufempty          \n
   (allocate-atom-grow '$1)
   \t 'movb \s '0 \[ %r11 \] , \s '%bl    \n
   \t 'mov \s '%bl, \s '0 \[ '%r9 \]      \n
   \t 'inc \s '%r9                        \n
   \t 'inc \s '%r11                       \n
   \t 'dec \s '%r10                       \n
   \t 'jmp \s 'load_file_loop             \n

   # read file
   'load_file_bufempty:                   \n
   \t 'push \s '%rax                      \n
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'mov \s '$load_file_bsz, \s '%rdx   \n
   \t 'mov \s '0 \[ '%rdx \] , \s '%rdx   \n
   (system-call( '$0 '%r10 '$load_file_buf () ))
   \t 'mov \s '%rax, \s '%r10             \n
   \t 'pop \s '%rax                       \n
   \t 'mov \s '$load_file_buf, \s '%r11   \n
   \t 'cmp \s '$0, \s '%r10               \n
   \t 'jne \s 'load_file_loop             \n

   # close file
   (system-call( '$3 '%rax '$0 '$0 ))
   (allocate-atom-grow '$1)
   \t 'movb \s '$0, \s '0 \[ %r9 \]       \n
   \t 'inc \s '%r9                        \n
   \t 'mov \s '%r8, \s '%r12              \n
   \t 'mov \s '$0, \s '%r13               \n
   \t 'ret                                \n
);

inline-head := λ . (
   \t 'mov \s '8 \[ '%r12 \] , \s '%r13   \n
   \t 'mov \s '0 \[ '%r12 \] , \s '%r12   \n
);

inline-tail := λ . (
   \t 'mov \s '0 \[ '%r13 \] , \s '%r12   \n
   \t 'mov \s '8 \[ '%r13 \] , \s '%r13   \n
);

enter-function := λ .(
   \t 'push \s %rbp                       \n
   \t 'mov \s %rsp, \s %rbp               \n
);

exit-function := λ .(
   \t 'mov \s %rbp, \s %rsp               \n
   \t 'pop \s %rbp                        \n
   \t 'ret                                \n
);

push-this := λ .(
   \t 'push \s '%r12                      \n
   \t 'push \s '%r13                      \n
);

push-zero := λ .(
   \t 'pushq \s '$0                       \n
   \t 'pushq \s '$0                       \n
);

pop-this := λ .(
   \t 'pop \s '%r13                       \n
   \t 'pop \s '%r12                       \n
);

yield-nil := λ . (
   \t 'mov \s '$0, \s '%r12               \n
   \t 'mov \s '$0, \s '%r13               \n
);

yield-cons := λctx l r offset used . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local rused)
   (match used (
      ()
      ( Used (tail(
         (set e1 (compile-expr( ctx l offset Used )))
         (set offset (get-offset e1))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) Used )))
         (set offset (get-offset e2))
         (set prog (prog (get-prog e1)))
         (set prog (prog (push-this())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (close())))
         (set prog (prog (pop-this())))
         (set prog (prog (\t 'push \s '%r8 \n)))
         (set prog (prog (close())))
         (set prog (prog (\t 'mov \s '%r8, \s '%r12 \n)))
         (set prog (prog (\t 'pop \s '%r13 \n)))
         (Expr( ((get-frame e1) (get-frame e2)) prog ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
      ( _ (tail(
         (set rused ( if (eq(used Tail)) Used Unused ))
         (set e1 (compile-expr( ctx l offset Unused )))
         (set e2 (compile-expr( (get-pc e1) r (get-offset e1) rused )))
         (Expr( ((get-frame e1) (get-frame e2)) ((get-prog e1) (get-prog e2)) ((get-unframe e1) (get-unframe e2)) ((get-text e1) (get-text e2)) ((get-data e1) (get-data e2)) (get-pc e2) (get-offset e2) ))
      )))
   ))
));

yield-atom-cache := ();
yield-atom := λctx a offset . (tail(
   (local cache)
   (set cache yield-atom-cache)
   (local id)
   (local data)
   (while cache (
      (if (eq( (head (head cache)) a )) (
         (set id (tail (head cache)))
      ) ())
      (set cache (tail cache))
   ))
   (if id () (
      (set id (uuid()))
      (set data (id ': \n \t '.ascii \s " (escape-sequences a) " \n \t '.zero \s 1 \n))
      (set yield-atom-cache ((a id) yield-atom-cache))
   ))
   (Expr(
      ()
      (\t 'mov \s '$ id , \s '%r12 \n # $_.$1 = 0, .atom
       \t 'mov \s '$0, \s '%r13    \n # $_.$2 = 0, .head
      )
      ()
      ()
      data
      ctx
      offset
   ))
));

$uuid := ();
uuid := λ . (tail(
   (set $uuid (inc $uuid))
   (clone-rope ('uuid_ (dump-i $uuid)))
));

escape-sequences := λt . match t (
   ()
   ( () () )
   ( \\ \\\\ )
   ( \\: \: )
   ( \\o \o )
   ( \\n (\\ 'n))
   ( \\t \t )
   ( \\s \s )
   ( \\l \l )
   ( \\[ \[ )
   ( \\] \] )
   ( (l r) ( (escape-sequences l) (escape-sequences r) ) )
   ( s (tail(
      (local c)
      (local cs)
      (local is_escape)
      (while s (
         (set c (head-string s))
         (set s (tail-string s))
         (match c (
            ()
            ( " (
               (set cs (cs \\ "))
               (set is_escape ())
            ))
            (\\ (
               (if is_escape (
                 (set cs ( cs \\\\ ))
                 (set is_escape ())
               ) (set is_escape True))
            ))
            (_ (
               (if is_escape (
                  (match c (
                     ()
                     ( , (set cs (cs .)))
                     ( _ (fail( InvalidEscapeCharacter (c s) )))
                  ))
               ) (set cs (cs (clone-rope c))))
               (set is_escape ())
            ))
         ))
      ))
      (clone-rope cs)
   )))
);

close := λe . (
   e
   (allocate-cons ())
   (\t 'mov \s '%r12, \s '0 \[ '%r8 \] \n)
   (\t 'mov \s '%r13, \s '8 \[ '%r8 \] \n)
);

is-builtin := λf . (match f (
   ()
   ('is True)
   ('is-atom True)
   ('is-cons True)
   ('eq True)
   ('not True)
   ('head True)
   ('head-string True)
   ('tail-string True)
   ('tail True)
   ('inc True)
   ('dec True)
   ('add True)
   ('mul True)
   ('div True)
   ('mod True)
   ('inv True)
   ('is-neg True)
   ('digit True)
   ('dump-i True)
   ('print-s True)
   ('print-i True)
   ('print-p True)
   ('print-p True)
   ('print-d True)
   ('clone-rope True)
   ('write-file True)
   ('load-file True)
   (_ ())
));

system-call := λrax rdi rsi rdx . (
   (if rax (\t 'mov \s rax , \s '%rax              \n) ())
   (if rdi (\t 'mov \s rdi , \s '%rdi              \n) ())
   (if rsi (\t 'mov \s rsi , \s '%rsi              \n) ())
   (if rdx (\t 'mov \s rdx , \s '%rdx              \n) ())
   \t 'syscall                            \n
);

yield-patterns := λctx p offset . match p (
   ()
   ( Nil (tail(
      ()
      (Expr( () (\t 'mov \s '$0, \s %r14 \n) () () () ctx offset ))
   )))
   ( (App( prev (App( lhs rhs )) )) (tail(
      (local e1)
      (local e2)
      (local e3)
      (local prog)
      (set e1 (yield-patterns(ctx prev offset)))
      (set e2 (destructure-pattern-lhs((get-pc e1) lhs (get-offset e1))))
      (set e3 (compile-expr((get-pc e2) rhs (get-offset e2) Used)))
      (local label_skip)
      (set label_skip (uuid()))
      (set prog (prog (get-prog e1)))
      (set prog (prog (\t 'cmp \s '$0, \s %r14 \n)))
      (set prog (prog (\t 'jne \s label_skip \n)))
      (set prog (prog (get-prog e2)))
      (set prog (prog (\t 'cmp \s '$0, \s %r14 \n)))
      (set prog (prog (\t 'je \s label_skip \n)))
      (set prog (prog (get-prog e3)))
      (set prog (prog (\t 'mov \s '$1, \s %r14 \n)))
      (set prog (prog (label_skip ': \n)))
      (Expr( 
         ((get-frame e1) (get-frame e2) (get-frame e3))
         prog
         ((get-unframe e1) (get-unframe e2) (get-unframe e3))
         ((get-text e1) (get-text e2) (get-text e3))
         ((get-data e1) (get-data e2) (get-data e3))
         ctx
         (get-offset e3)
      ))
   )))
   ( _ (
      (fail (InvalidPatternsCase p))
   ))
);

destructure-pattern-lhs := λctx lhs offset . (tail(
   (local e1)
   (local e2)
   (local prog)
   (local label_skip)
   (match lhs (
      ()
      ( (Variable '_) (tail(
         ()
         (Expr( () (\t 'mov \s '$1, \s %r14 \n) () () () ctx offset ))
      )))
      ( (Variable v) (tail(
         (set e1 (declare-local(ctx v offset)))
         (Expr(
            (get-frame e1)
            ((get-prog e1) \t 'mov \s '$1, \s %r14 \n)
            (get-unframe e1)
            (get-text e1)
            (get-data e1)
            (get-pc e1)
            (get-offset e1)
         ))
      )))
      ( (Literal l) (tail(
         (set e1 (yield-atom(ctx l offset)))
         (set label_skip (uuid()))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))       
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))       
         (set prog (prog (\t 'mov \s %r12, \s %rax \n)))
         (set prog (prog (get-prog e1)))
         (set prog (prog (\t 'mov \s %r12, \s %rbx \n)))
         (set prog (prog (\t 'call \s 'streq \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s %r14 \n)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( (get-frame e1) prog (get-unframe e1) (get-text e1) (get-data e1) (get-pc e1) (get-offset e1) ))
      )))
      ( Nil (tail(
         (set label_skip (uuid()))
         (set prog (prog (\t 'cmp \s '$0, \s %r12 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'jne \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$1, \s %r14 \n)))
         (set prog (prog (label_skip ': \n)))
         (Expr( () prog () () () ctx offset ))
      )))
      ( (App( l r )) (tail(
         (set e1 (destructure-pattern-lhs(ctx l offset)))
         (set e2 (destructure-pattern-lhs((get-pc e1) r (get-offset e1))))
         (set label_skip (uuid()))
         (set prog (prog (\t 'mov \s '$0, \s %r14 \n)))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %r13 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (inline-head())))
         (set prog (prog (get-prog e1)))
         (set prog (prog (pop-this())))
         (set prog (prog (push-this())))
         (set prog (prog (\t 'cmp \s '$0, \s %r14 \n)))
         (set prog (prog (\t 'je \s label_skip \n)))
         (set prog (prog (\t 'mov \s '$0, \s %r14 \n)))
         (set prog (prog (inline-tail())))
         (set prog (prog (get-prog e2)))
         (set prog (prog (label_skip ': \n)))
         (set prog (prog (pop-this())))
         (Expr( 
            ((get-frame e1) (get-frame e2))
            prog
            ((get-unframe e1) (get-unframe e2))
            ((get-text e1) (get-text e2))
            ((get-data e1) (get-data e2))
            (get-pc e2)
            (get-offset e2)
         ))
      )))
      (_ (fail (UnexpectedPattern lhs)))
   ))
));

before-main := λ .(
   # before_main_argv:
   #    argv = ()
   #    let t = argv
   #    for a in argv:
   #       t.tail = (a ())
   #       t = t.tail

   'main:                              \n
   compile-argv-hook
);

exit-cleanup := λ . (system-call( '$60 '$0 '$0 '$0 ));
