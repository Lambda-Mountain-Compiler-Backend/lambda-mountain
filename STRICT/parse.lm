
type ParsePartial (PME( AST , S )); # term, remainder

print := λ(: x ParsePartial). (: (match x (
   ()
   ( (PME( e s )) (tail(
      (print '\[PME\[_s)
      (print e)
      (print '\s_s)
      (print s)
      (print '\]\]_s)
   )))
)) Nil);

close := λ(: x ParsePartial). (: (tail(
   (mov( (malloc(sizeof ParsePartial)) R8 ))
   (mov( x 0_u64 (as R8 ParsePartial[]) ))
   (as R8 ParsePartial[])
)) ParsePartial[]);

parse := λ. (: (tail(
   (let tokens ast-tokenized-program)
   (while (non-zero tokens) (
      (match tokens (
         ()
         ( (SCons( (SAtom \:_s) remainder )) (
            (set tokens remainder)
         ))
#         ( (SCons( (SAtom 'macro_s) remainder )) (
#            (match (parse-one-expression remainder) (
#               ()
#               ( (PME( mlhs mremainder1 )) (
#                  (match (parse-one-expression mremainder1) (
#                     ()
#                     ( (PME( mrhs mremainder2 )) (tail(
#                        # (set parse-macros (parse-macros (Macro( (head pme) (head pme2) )) ))
#                        ()
#                        (set tokens mremainder2)
#                     )))
#                  ))
#               ))
#            ))
#         ))

#         (('fragment ('type remainder)) (tail(
#            (set pme (parse-one-expression remainder))
#            (set remainder (tail pme))
#            (set pme2 (parse-many-expressions remainder))
#            (set parse-parsed-program ( parse-parsed-program (Type( (head pme) (head pme2) )) ))
#            (set typecheck-fragment-types ( typecheck-fragment-types
#               (typecheck-infer-type-compound (head pme))
#            ))
#            (set toks (tail pme2))
#         )))
#         (('fragment remainder) (tail(
#            (set pme (parse-one-expression remainder))
#            (set remainder (tail pme))
#            (parse-expect( := remainder ))
#            (set remainder (tail remainder))
#            (set pme2 (parse-many-expressions remainder))
#            (set parse-parsed-program ( parse-parsed-program (Fragment( (head pme) (head pme2) )) ))
#            (set toks (tail pme2))
#         )))
#         (('type remainder) (tail(
#            (set pme (parse-one-expression remainder))
#            (set remainder (tail pme))
#            (set pme2 (parse-many-expressions remainder))
#            (set parse-parsed-program ( parse-parsed-program (Type( (head pme) (head pme2) )) ))
#            (set toks (tail pme2))
#         )))
#         (('atom ('suffix (atype (suffix remainder)))) (tail(
#            (set parse-suffix (parse-suffix (atype suffix)))
#            (set toks remainder)
#         )))
#         (('size remainder) (tail(
#            (set pme (parse-one-expression remainder))
#            (set remainder (tail pme))
#            (set pme2 (parse-one-expression remainder))
#            (typecheck-set-size( (typecheck-infer-type-compound (head pme)) (typecheck-infer-type-compound (head pme2)) ))
#            (set toks (tail pme2))
#         )))
#         (('import (relative-path remainder)) (tail(
#            (parse-program (tokenize-file relative-path))
#            (set toks remainder)
#         )))
#         ((key (:= remainder)) (tail(
#            (set pme (parse-many-expressions remainder))
#            (set parse-parsed-program ( parse-parsed-program (Global ( key (head pme))) ))
#            (set toks (tail pme))
#         )))
         (remainder (
            (match (parse-many-expressions remainder) (
               ()
               ( (PME( term remainder )) (tail(
                  (set ast-parsed-program (Seq(
                     (close ast-parsed-program)
                     (close term)
                  )))
                  (set tokens remainder)
               )))
            ))
         ))
      ))
   ))

   (print 'Parse:\n_s)
   (print ast-parsed-program)
   (print '\:\n_s)
)) Nil);

parse-many-expressions := λ(: tokens S). (: (tail(
   (let expr ASTEOF)
   (let remainder SNil)
   (while (non-zero tokens) (
      (match tokens (
         ()
         ( (SCons( (SAtom '\:_s) tl )) (tail(
            (set remainder tokens)
            (set tokens SNil)
         )))
         ( (SCons( (SAtom '\]_s) tl )) (tail(
            (if (non-zero expr) () (set expr ASTNil))
            (set remainder tl)
            (set tokens SNil)
         )))
         ( _ (
            (match (parse-one-expression tokens) (
               ()
               ( (PME( pe pr )) (tail(
                  (if (non-zero expr) (
                     (set expr (App(
                        (close expr)
                        (close pe)
                     )))
                  ) (
                     (set expr pe)
                  ))
                  (set tokens pr)
               )))
            ))
         ))
      ))
   ))
   (close( (PME( expr remainder )) ))
)) ParsePartial[]);

parse-one-expression := λ(: tokens S). (: (tail(
   (let expr ASTEOF)
   (let remainder SNil)
   (match tokens (
      ()
      ( SNil (tail(
         (set expr ASTNil)
         (set remainder SNil)
      )))
      ( (SCons( (SAtom '\l_s) r )) (
         (match (parse-lambda r) (
            ()
            ( (PME( le lr )) (tail(
               (set expr le)
               (set remainder lr)
            )))
         ))
      ))
      ( (SCons( (SAtom '\]_s) r )) (
         (parse-unexpect( 'Unexpected\sClosing\sParentheses_s tokens ))
      ))
      ( (SCons( (SAtom '\[_s) r )) (
         (match (parse-many-expressions r) (
            ()
            ( (PME( me mr )) (tail(
               (set expr me)
               (set remainder mr)
            )))
         ))
      ))
      ( (SCons( (SAtom '\`_s)
                (SCons( (SAtom i) r ))
        )) (tail(
         (set expr (Lit i))
         (set remainder r)
      )))
      ( (SCons( (SAtom a) r )) (tail(
         (if (is-variable a) (
            (set expr (Var a))
         ) (
            (set expr (Lit a))
         ))
         (set remainder r)
      )))
   ))
   (close( (PME( expr remainder )) ))
)) ParsePartial[]);

parse-lambda := λ(: tokens S). (: (tail(
   (let expr ASTEOF)
   (let remainder SNil)
   (close( (PME( expr remainder )) ))
)) ParsePartial[]);

parse-unexpect := λ(: msg String)(: tokens S). (: (tail(
   ()
   (fail msg)
)) Nil);

