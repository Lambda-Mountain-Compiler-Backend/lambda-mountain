
merge := λ(: lctx TContext)(: rctx TContext). (: (tail(
   (match rctx (
      ()
      ( (TCtxBind( rst (*( k v )) )) (tail(
         (let lctx2 (TCtxBind( (close lctx) k v )))
         (let lctx3 (merge( lctx2 rst )))
         (set lctx lctx3)
      )))
      ( _ () )
   ))
   (close lctx)
)) TContext[]);

print := λ(: tt Type). (: (match tt (
   ()
   ( TAny (print '?_s) )
   ( (TGround( tag TypeEOF )) (print tag) )
   ( (TGround( tag (TypeSeq( TypeEOF p1 )) )) (tail(
      (print tag)
      (print '<_s)
      (print p1)
      (print '>_s)
   )))
   ( (TGround( tag (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (tail(
      (print tag)
      (print '<_s)
      (print p1)
      (print ',_s)
      (print p2)
      (print '>_s)
   )))
   ( (TGround( tag (TypeSeq( (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) p3 )) )) (tail(
      (print tag)
      (print '<_s)
      (print p1)
      (print ',_s)
      (print p2)
      (print ',_s)
      (print p3)
      (print '>_s)
   )))
   ( (TAnd( lt rt )) (tail(
      (print lt)
      (print '\s+\s_s)
      (print rt)
   )))
   ( (TArray( lt rt )) (tail(
      (print lt)
      (print '[_s)
      (print rt)
      (print ']_s)
   )))
)) Nil);

serialize-ast := λ(: tt Type). (: (match tt (
   ()
   ( TAny (print '\[Variable\s?\]_s) )
   ( (TGround( tag TypeEOF )) (
      (if (is-variable tag) (tail(
         (print '\[Variable\s_s)
         (print tag)
         (print '\]_s)
      )) (tail(
         (print '\[Literal\s_s)
         (print tag)
         (print '\]_s)
      )))
   ))
   ( (TGround( tag (TypeSeq( TypeEOF p1 )) )) (tail(
      (print '\[App\s\[_s) 
      (print '\[Literal\s_s)
      (print tag)
      (print '\]\s_s)
      (serialize-ast p1)
      (print '\]\]_s)
   )))
   ( (TGround( tag (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) )) (tail(
      (print '\[App\s\[_s) 
      (print '\[Literal\s_s)
      (print tag)
      (print '\]\s_s)
      (print '\[App\s\[_s) 
      (serialize-ast p1)
      (print '\s_s)
      (serialize-ast p2)
      (print '\]\]_s)
      (print '\]\]_s)
   )))
   ( (TGround( tag (TypeSeq( (TypeSeq( (TypeSeq( TypeEOF p1 )) p2 )) p3 )) )) (tail(
      (print '\[App\s\[_s) 
      (print '\[Literal\s_s)
      (print tag)
      (print '\]\s_s)
      (print '\[App\s\[_s) 
      (print '\[App\s\[_s) 
      (serialize-ast p1)
      (print '\s_s)
      (serialize-ast p2)
      (print '\]\]\s_s)
      (serialize-ast p3)
      (print '\]\]_s)
      (print '\]\]_s)
   )))
   ( (TAnd( lt rt )) (tail(
      (print '\[App\s\[_s)
      (print '\[Literal\sAnd\]\s_s)
      (print '\[App\s\[_s)
      (serialize-ast lt)
      (print '\s_s)
      (serialize-ast rt)
      (print '\]\]_s)
      (print '\]\]_s)
   )))
   ( (TArray( lt rt )) (tail(
      (print '\[App\s\[_s)
      (print '\[Literal\sArray\]\s_s)
      (print '\[App\s\[_s)
      (serialize-ast lt)
      (print '\s_s)
      (serialize-ast rt)
      (print '\]\]_s)
      (print '\]\]_s)
   )))
)) Nil);

close := λ(: x Type). (: (tail(
   (mov( (malloc(sizeof Type)) R8 ))
   (mov( x 0_u64 (as R8 Type[]) ))
   (as R8 Type[])
)) Type[]);

tnil := λ. (: (tail(
   ()
   (close (TGround(
      'Nil_s
      (close TypeEOF)
   )))
)) Type[]);

type TermTypeList TTEOF | (TTSeq( TermTypeList[] , AST , Type ));

non-zero := λ(: t TermTypeList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TTEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

non-zero := λ(: t Type). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( TAny (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

close := λ(: x TermTypeList). (: (tail(
   (mov( (malloc(sizeof TermTypeList)) R8 ))
   (mov( x 0_u64 (as R8 TermTypeList[]) ))
   (as R8 TermTypeList[])
)) TermTypeList[]);

typecheck-typeof-lhs := λ(: lhs AST). (: (tail(
   (let r TAny)
   (match lhs (
      ()
      ( (Asc( _ tt )) (
         (set r tt)
      ))
      ( (App( ps (Asc( _ tt )) )) (
         (set r (TGround(
            'Cons_s
            (close(TypeSeq(
               (close(TypeSeq(
                  (close TypeEOF)
                  (maybe-deref(typecheck-typeof-lhs( ps )))
               )))
               tt
            )))
         )))
      ))
      ( ASTNil (tail(
         (let r2 (maybe-deref(tnil())))
         (set r r2)
      )))
      ( _ (exit-error( 'Unknown\sLHS_s lhs )))
   ))
   (close r)
)) Type[]);

typecheck-term-type-list := (: TTEOF TermTypeList);
typecheck-types-have-changed := True_u8;
typecheck := λ. (: (tail(
   (let p ast-parsed-program)
   (let ordered-type-exprs ASTEOF)
   (while (non-zero p) (match p (
      ()
      ( (Seq( rst r )) (tail(
         (set ordered-type-exprs (Seq( (close ordered-type-exprs) (close r) )))
         (set p rst)
      )))
   )))
   (while (non-zero ordered-type-exprs) (match ordered-type-exprs (
      ()
      ( (Seq( rst r )) (tail(
         (typecheck-infer-global-context( r ))
         (set ordered-type-exprs rst)
      )))
   )))
   (while (==( typecheck-types-have-changed True_u8 )) (
      (print 'Typecheck\sIter\n_s)
      (set typecheck-types-have-changed False_u8)
      (typecheck-infer-expr( global-type-context ast-parsed-program Unused))
   ))
   (typecheck-assert-complete ast-parsed-program)
)) Nil);

global-type-context := (: TCtxEOF TContext);

typecheck-infer-global-context := λ(: td AST). (: (tail(
   (match td (
      ()
      ( (ASTType( _ _ )) (tail(
         (print td)
         (print '\n_s)
      )))
      ( (Glb( k (Abs( lhs (Asc( rhs rhst )) )) )) (tail(
         (let lt (maybe-deref(typecheck-typeof-lhs lhs)))
         (let ft (maybe-deref(tarrow( lt rhst ))))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
         )))
      )))
      ( (Fragment( k (Abs( lhs (Asc( rhs rhst )) )) )) (tail(
         (let lt (maybe-deref(typecheck-typeof-lhs lhs)))
         (let ft (maybe-deref(tarrow( lt rhst ))))
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            ft
         )))
      )))
      ( (Glb( k (Asc( rhs rhst )) )) (
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            rhst
         )))
      ))
      ( (Fragment( k (Asc( rhs rhst )) )) (
         (set global-type-context (TCtxBind(
            (close global-type-context)
            k
            rhst
         )))
      ))
      ( (Glb( k _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( (Fragment( k _ )) (
         (exit-error( 'Global\sBindings\sMust\sBe\sAscripted_s td ))
      ))
      ( _ () )
   ))
   ()
)) Nil);

typecheck-assert-complete := λ(: term AST). (: (
   (match term (
      ()
      ( ASTEOF (typecheck-assert-one term) )
      ( ASTNil (typecheck-assert-one term) )
      ( (Glb( k v )) (
         (typecheck-assert-complete v)
      ))
      ( (ASTType( _ _ )) () )
      ( (Fragment( _ _ )) () )
      ( (App( (Abs( (Var lname) ASTNil )) rhs )) (tail(
         (typecheck-assert-complete rhs)
         (typecheck-assert-one term)
      )))
      ( (App( (Var 'gensym-label_s) _ )) () )
      ( (App( (Var 'label_s) (Var _) )) () )
      ( (App( (App( (Var 'while_s) cond )) body )) (tail(
         (typecheck-assert-complete cond)
         (typecheck-assert-complete body)
         (typecheck-assert-one term)
      )))
      ( (App( (App( (App( (Var 'if_s) cond )) t )) f )) (tail(
         (typecheck-assert-complete cond)
         (typecheck-assert-complete t)
         (typecheck-assert-complete f)
         (typecheck-assert-one term)
      )))
      ( (App( (App( (Var 'set_s) lhs )) rhs )) (tail(
         (typecheck-assert-complete rhs)
         (typecheck-assert-one term)
      )))
      ( (Asc( t tt )) (tail(
         (typecheck-assert-complete t)
         (typecheck-assert-one term)
      )))
      ( (Lit l) (typecheck-assert-one term) )
      ( (Var l) (typecheck-assert-one term) )
      ( (Abs( lhs rhs )) (tail(
         (typecheck-assert-complete rhs)
         (typecheck-assert-one term)
      )))
      ( (App( l r )) (tail(
         (typecheck-assert-complete l)
         (typecheck-assert-complete r)
         (typecheck-assert-one term)
      )))
      ( (Seq( l r )) (tail(
         (typecheck-assert-complete l)
         (typecheck-assert-complete r)
      )))
   ))
) Nil);

typecheck-assert-one := λ(: term AST). (: (
   (if (non-zero(maybe-deref(typecheck-lookup term))) () (tail(
      (print 'Unable\sto\sinfer\stype\sof\sexpression:\n_s)
      (print term)
      (print '\n_s)
      (exit 1_u64)
   )))
) Nil);

typecheck-lookup := λ(: term AST). (: (tail(
   (let found TAny)
   (let tctx typecheck-term-type-list)
   (while (non-zero tctx) (match tctx (
      ()
      ( (TTSeq( rst (*( t tt )) )) (tail(
         (if (==( t term )) (
            (set found tt)
         ) ())
         (set tctx rst)
      )))
   )))
   (close found)
)) Type[]);

exit-error := λ(: msg String)(: t AST). (: (tail(
   (print msg)
   (print '\n_s)
   (print (maybe-deref(location( t ))))
   (print '\n_s)
   (print t)
   (print '\n_s)
   (exit 1_u64)
)) Nil);

typecheck-ascript := λ(: t AST)(: tt Type). (: (
   (if (non-zero tt) (tail(
      (let ot (maybe-deref(typecheck-lookup t)))
      (if (non-zero ot) (
         (if (==( ot tt )) () (tail(
            (print ot)
            (print '\s!=\s_s)
            (print tt)
            (print '\n_s)
            (exit-error( 'Type\sAscription\sInequality_s t ))
         )))
      ) (tail(
         (set typecheck-term-type-list (TTSeq(
            (close typecheck-term-type-list)
            t tt
         )))
         (set typecheck-types-have-changed True_u8)
     )))
   )) ())
) Nil);

typecheck-infer-expr := λ(: tctx TContext)(: term AST)(: used Used). (: (tail(
   (match term (
      ()
      ( ASTNil (typecheck-ascript( term (maybe-deref(tnil())) )) )
      ( ASTEOF (typecheck-ascript( term (maybe-deref(tnil())) )) )
      ( (Seq( l r )) (tail(
         (typecheck-infer-expr( tctx l used ))
         (typecheck-infer-expr( tctx r used ))
      )))
      ( (ASTType( _ _ )) () )
      ( (Glb( k v )) (tail(
         (typecheck-ascript( v (maybe-deref(typecheck-lookup term)) ))
         (typecheck-infer-expr( tctx v Used ))
      )))
      ( (Fragment( k (Abs( lhs (Asc( rhs rhst )) )) )) (
         (typecheck-ascript( term rhst ))
      ))
      ( (Asc( t tt )) (tail(
         (typecheck-ascript( term tt ))
         (typecheck-ascript( t tt ))
         (typecheck-infer-expr( tctx t used ))
      )))
      ( (App( (Var 'gensym-label_s) (Var lname) )) (tail(
         (let tctx2 (TCtxBind(
            (close tctx)
            lname
            (maybe-deref(tlabel()))
         )))
         (set tctx tctx2)
         (typecheck-ascript( term (maybe-deref(tnil())) ))
      )))
      ( (App( (Var 'label_s) (Var lname) )) (
         (typecheck-ascript( term (maybe-deref(tnil())) ))
      ))
#       ( (Lit( lit )) (tail(
#         (set ctype (typecheck-infer-constructor-type lit))
#         (typecheck-ascript( term ctype ))
#       )))
      ( (App( (App( (App( (Var 'if_s) cond )) t )) f )) (tail(
         (let tctx2 (maybe-deref(typecheck-infer-expr( tctx cond Used ))))
         (let tctx3 (maybe-deref(typecheck-infer-expr( tctx2 t Used ))))
         (set tctx tctx3)
         (typecheck-infer-expr( tctx f Used ))
         (typecheck-ascript( term (maybe-deref(typecheck-lookup t)) ))
      )))
      ( (App( (App( (Var 'while_s) cond )) body )) (tail(
         (let tctx2 (maybe-deref(typecheck-infer-expr( tctx cond Used ))))
         (set tctx tctx2)
         (typecheck-infer-expr( tctx body Used ))
         (typecheck-ascript( term (maybe-deref(tnil())) ))
      )))
      ( (App( (Var 'tail_s) (App( l r )) )) (tail(
         (typecheck-infer-expr( tctx l Unused ))
         (typecheck-infer-expr( tctx r used ))
         (typecheck-ascript( term (maybe-deref(typecheck-lookup r)) ))
      )))
      ( (App( (App( (Var 'as_s) t )) (Lit lt) )) (tail(
         (let tt (maybe-deref(parse-type lt)))
         (typecheck-infer-expr( tctx t used ))
         (typecheck-ascript( term tt ))
      )))
      ( (App( (App( (Var 'as_s) t )) (Var lt) )) (tail(
         (let tt (maybe-deref(parse-type lt)))
         (typecheck-infer-expr( tctx t used ))
         (typecheck-ascript( term tt ))
      )))
#      ( (App( (Variable 'maybe-deref) r )) (tail(
#         (set ctx (typecheck-infer-expr( ctx r used )))
#         (local rtype)
#         (set rtype (typecheck-lookup r))
#         (if rtype (
#            (match (typecheck-slot( (typecheck-lookup r) Array )) (
#               ()
#               ( (Array( x '? )) (
#                  (if (typecheck-unify-implies( x '? )) () (
#                     (set rtype x)
#                  ))
#               ))
#            ))
#            (typecheck-ascript( e rtype ))
#         ) ())
#      )))
      ( (App( (Abs( (Var lname) ASTNil )) rhs )) (tail(
         (typecheck-infer-expr( tctx rhs Used ))
         (let rt (maybe-deref(as-local-variable(maybe-deref(typecheck-lookup rhs)))))
         (set tctx (TCtxBind(
            (close tctx)
            lname
            rt
         )))
         (typecheck-ascript( term (maybe-deref(tnil())) ))
      )))
      ( (App( l r )) (tail(
         (typecheck-infer-expr( tctx l Used ))
         (typecheck-infer-expr( tctx r Used ))
         (let rt (maybe-deref(typecheck-apply(
            (maybe-deref(typecheck-lookup l))
            (maybe-deref(typecheck-lookup r))
         ))))
         (typecheck-ascript( term rt ))
      )))
      ( (Abs( lhs rhs )) (tail(
         (let tctx2 (maybe-deref(typecheck-infer-ctx( tctx lhs ))))
         (set tctx tctx2)
         (typecheck-infer-expr( tctx rhs Used ))
         (let lt (maybe-deref(typecheck-typeof-lhs rhs)))
         (let rt (maybe-deref(typecheck-lookup rhs)))
         (typecheck-ascript( term (maybe-deref(tarrow( lt rt ))) ))
      )))
      ( (Var v) (
         (typecheck-ascript( term (maybe-deref(typecheck-typeof-var( term tctx v ))) ))
      ))
      ( (Lit _) () ) #Literals need to be ascripted or inferred or gradual
      ( _ (tail(
         (print 'Unknown\sTerm\sIn\sType\sInference\n_s)
         (print term)
         (print '\n_s)
         (exit 1_u64)
      )))
   ))
   (close tctx)
)) TContext[]);

as-local-variable := λ(: tt Type). (: (tail(
   ()
   (close tt)
)) Type[]);

is-arrow := λ(: tt Type). (: (tail(
   (let r 0_u64)
   (match tt (
      ()
      ( (TAnd( lt rt )) (
         (if (is-arrow lt) (
            (set r 1_u64)
         ) (
            (set r (is-arrow rt))
         ))
      ))
      ( (TGround( '->_s _ )) (set r 1_u64) )
      ( _ () )
   ))
   r
)) U64);

typecheck-apply := λ(: ft Type)(: pt Type). (: (tail(
   (let rt TAny)
   (if (is-arrow ft) (
      (match ft (
         ()
         ( (TAnd( ft1 ft2 )) (tail(
            (let rt1 (maybe-deref(typecheck-apply( ft1 pt ))))
            (if (non-zero rt1) (
               (set rt rt1)
            ) (tail(
               (let rt2 (maybe-deref(typecheck-apply( ft2 pt ))))
               (set rt rt2)
            )))
         )))
         ( (TGround( '->_s (TypeSeq( (TypeSeq( TypeEOF fpt )) frt )) )) (tail(
            (let ctx (maybe-deref(typecheck-unify-args( fpt pt ))))
            (if (non-zero ctx) (tail(
               (let rt1 (maybe-deref(typecheck-unify-ctx( ctx frt ))))
               (set rt rt1)
            )) ())
         )))
         ( _ () )
      ))
   ) (
      (if (non-zero ft) (
         (if (non-zero pt) (tail(
            (let rt2 (TGround(
               'Cons_s
               (close(TypeSeq(
                  (close(TypeSeq(
                     (close TypeEOF)
                     ft
                  )))
                  pt
               )))
            )))
            (set rt rt2)
         )) ())
      ) ())
   ))
   (print 'Apply:s\s_s)
   (print ft)
   (print '\sx\s_s)
   (print pt)
   (print '\s=\s_s)
   (print rt)
   (print '\n_s)
   (close rt)
)) Type[]);

typecheck-unify-ctx := λ(: ctx TContext)(: tt Type). (: (tail(
   ()
   (close tt)
)) Type[]);

tcontext-accept := λ. (: (tail(
   (let r (TCtxBind(
      (close TCtxEOF)
      'Accept_s
      (maybe-deref(tnil()))
   )))
   (close r)
)) TContext[]);

typecheck-unify-args := λ(: fpt Type)(: pt Type). (: (tail(
   (let ctx TCtxEOF)
   (match (TPair( fpt pt )) (
      ()
      ( (TPair( (TAnd( lt1 lt2 )) rt )) (
         (match (TCPair( (maybe-deref(typecheck-unify-args( lt1 rt ))) (maybe-deref(typecheck-unify-args( lt2 rt ))) )) (
            ()
            ( (TCPair( TCtxEOF _ )) () )
            ( (TCPair( _ TCtxEOF )) () )
            ( (TCPair( lctx rctx )) (tail(
               (let nctx (merge( lctx rctx )))
               (set ctx nctx)
            )))
         ))
      ))
      ( (TPair( lt (TAnd( rt1 rt2 )) )) (
         (match (TCPair( (maybe-deref(typecheck-unify-args( lt rt1 ))) (maybe-deref(typecheck-unify-args( lt rt2 ))) )) (
            ()
            ( (TCPair( TCtxEOF TCtxEOF )) () )
            ( (TCPair( lctx TCtxEOF )) (set ctx lctx) )
            ( (TCPair( TCtxEOF rctx )) (set ctx rctx) )
            ( (TCPair( lctx rctx )) (tail(
               (let nctx (merge( lctx rctx )))
               (set ctx nctx)
            )))
         ))
      ))
      ( (TPair( (TGround( ltn TypeEOF )) (TGround( rtn TypeEOF )) )) (
         (if (==( ltn rtn )) (tail(
            (let ctx2 (maybe-deref(tcontext-accept())))
            (set ctx ctx2)
         )) ())
      ))
      ( (TPair( (TGround( ltn (TypeSeq( TypeEOF lt1 )) )) (TGround( rtn (TypeSeq( TypeEOF rt1 )) )) )) (
         (if (==( ltn rtn )) (tail(
            (let ctx2 (maybe-deref(typecheck-unify-args( lt1 rt1 ))))
            (set ctx ctx2)
         )) ())
      ))
      ( (TPair( (TGround( ltn (TypeSeq( (TypeSeq( TypeEOF lt1 )) lt2 )) )) (TGround( rtn (TypeSeq( (TypeSeq( TypeEOF rt1 )) rt2 )) )) )) (
         (if (==( ltn rtn )) (tail(
            (let ctx2 (maybe-deref(typecheck-unify-args( lt1 rt1 ))))
            (if (non-zero ctx2) (tail(
               (let ctx3 (maybe-deref(typecheck-unify-args( lt2 rt2 ))))
               (set ctx ctx3)
            )) ())
         )) ())
      ))
      ( _ () )
   ))
   (close TCtxEOF)
)) TContext[]);

#typecheck-unify-args-inner := λlt rt . (match (lt rt) (
#   ( (a1 a2) (
#      (if (typecheck-unify-implies( a2 a1 )) ( # argument type must imply parameter type
#         Accept
#      ) (
#         (if (is-variable a1) (
#            (if (is-variable a2) (
#               Accept
#            ) (
#               (Bind( a1 a2 ))
#            ))
#         ) (
#            (if (is-variable a2) (
#               (Bind( a2 a1 ))
#            ) (
#               ()
#            ))
#         ))
#      ))
#   ))
#));

tarrow := λ(: lt Type)(: rt Type). (: (tail(
   ()
   (close(TGround( '->_s
      (close(TypeSeq( (close(TypeSeq( (close TypeEOF) lt ))) rt )))
   )))
)) Type[]);

tlabel := λ. (: (tail(
   ()
   (close(TGround( 'Label_s (close TypeEOF) )))
)) Type[]);

typecheck-infer-ctx := λ(: tctx TContext)(: lhs AST). (: (tail(
   (match lhs (
      ()
      ( (Asc( (Var v) tt )) (
         (set tctx (TCtxBind(
            (close tctx)
            v
            tt
         )))
      ))
      ( (App( ps (Asc( (Var v) tt )) )) (tail(
         (set tctx (TCtxBind(
            (close tctx)
            v
            tt
         )))
         (let tctx2 (maybe-deref(typecheck-infer-ctx( tctx ps ))))
         (set tctx tctx2)
      )))
      ( _ () )
   ))
   (close tctx)
)) TContext[]);

typecheck-typeof-var := λ(: sloc AST)(: tctx TContext)(: vname String). (: (tail(
   (let found TAny)
   (while (non-zero tctx) (match tctx (
      ()
      ( (TCtxBind( rst (*( k vt  )) )) (
         (if (==( k vname )) (tail(
            (set found vt)
            (set tctx TCtxEOF)
         )) (
            (set tctx rst)
         ))
      ))
   )))
   (if (non-zero found) () (
      (exit-error( 'Unknown\sReferenced\sVariable_s sloc ))
   ))
   (close found)
)) Type[]);
