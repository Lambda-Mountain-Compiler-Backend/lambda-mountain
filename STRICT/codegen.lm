
#global binding
compile-global := λ(: ctx CCContext)(: k String)(: term AST). (: (tail(
   ()
   (let kt (maybe-deref(typecheck-lookup term)))
   (match term (
      ()
      ( (Abs( lhs rhs )) (tail(
         (let ctx-2 (maybe-deref(compile-destructure-args( ctx lhs 0_i64 ))))
         (set ctx ctx-2)
         (let stack-offset (cccontext::get-offset( ctx )))
         (let e (maybe-deref(compile-expr( ctx rhs stack-offset Return ))))
         (let text SNil)
         (set text (SCons( (close text) (close(SAtom( (mangle-identifier( k kt )) ))) )))
         (let frame (maybe-deref(ccfragment::get( e 'frame_s ))))
         (set text (SCons( (close text) (close frame) )))
         (let program (maybe-deref(ccfragment::get( e 'program_s ))))
         (set text (SCons( (close text) (close program) )))
         (let unframe (maybe-deref(ccfragment::get( e 'unframe_s ))))
         (set text (SCons( (close text) (close unframe) )))
         (set text (SCons( (close text) (close(SAtom '\tret\n_s)) )))
         (let text-etc (maybe-deref(ccfragment::get( e 'text_s ))))
         (set text (SCons( (close text) (close text-etc) )))
         (let data (maybe-deref(ccfragment::get( e 'data_s ))))
         (set assemble-text-section (SCons( (close assemble-text-section) (close text) )))
         (set assemble-data-section (SCons( (close assemble-data-section) (close data) )))
      )))
      ( (Asc( t tt )) (tail(
         (print 'TODO:\sDeclare\sGlobal\sVariable\n_s)
         ()
      )))
      ( _ (
         (exit-error( 'Unrecognized\sCompile\sGlobal\n_s term ))
      ))
   ))
)) Nil);

#top expression
compile-global := λ(: ctx CCContext)(: term AST). (: (tail(
   (let e (maybe-deref(ccfragment::new())))
   (close e)
)) CCFragment[]);

compile-expr := λ(: ctx CCContext)(: term AST)(: stack-offset I64)(: used Used). (: (tail(
   (let e (maybe-deref(ccfragment::new())))
   (match term (
      ()
      ( ASTNil () )
      ( ASTEOF () )
      ( (Var( id )) (tail(
         (print 'TODO:\sVariable\n_s)
         ()
      )))
      ( (Lit( id )) (tail(
         (print 'TODO:\sLiteral\n_s)
         ()
      )))
      ( (Asc( t tt )) (tail(
         (let e1 (maybe-deref(compile-expr( ctx t stack-offset used ))))
         (set e e1)
      )))
      ( (App( (Var 'tail_s) (App( lt rt )) )) (tail(
         (let e1 (maybe-deref(compile-expr( ctx lt stack-offset Unused ))))
         (let e2 (maybe-deref(compile-expr( (maybe-deref(ccfragment::get-context e1)) rt (ccfragment::get-offset e1) used ))))
         (let e12 (maybe-deref(ccfragment::chain( e1 e2 ))))
         (set e e12)
      )))
      ( (App( (App( (Var 'while_s) cond )) body )) (tail(
         (print 'TODO:\sWhile\n_s)
         ()
      )))
      ( (App( (App( (App( (Var 'if_s) cond )) t )) f )) (tail(
         (print 'TODO:\sIf\n_s)
         ()
      )))
      ( (App( (Abs( (Var lhs) ASTNil )) rhs )) (tail(
         (print 'TODO:\sLet\sBinding\n_s)
         ()
      )))
      ( (App( f a )) (
         (match (maybe-deref(typecheck-slot( (maybe-deref(typecheck-lookup f)) '->_s ))) (
            ()
            ( (TGround( '->_s _ )) (
               (match f (
                  ()
                  ( (Var fname) (tail(
                     (let e1 (maybe-deref(compile-stack-call( ctx fname a stack-offset ))))
                     (set e e1)
                  )))
                  ( (Lit fname) (tail(
                     (let e1 (maybe-deref(compile-constructor( ctx fname a stack-offset ))))
                     (set e e1)
                  )))
               ))
            ))
            ( _ (
               (if (==( used Used )) (
                  (exit-error( 'Raw\sCons\sCells\sNot\sPermitted\sIn\sStrict\sMode_s term ))
               ) (tail(
                  (let e1 (maybe-deref(compile-expr( ctx f stack-offset Unused ))))
                  (let e2 (maybe-deref(compile-expr( (maybe-deref(ccfragment::get-context e1)) a (ccfragment::get-offset e1) used ))))
                  (let e12 (maybe-deref(ccfragment::chain( e1 e2 ))))
                  (set e e12)
               ))) 
            ))
         ))
      ))
      ( u (exit-error( 'compile-expr\sUnsupported\sExpression_s term )))
   ))
   (close e)
)) CCFragment[]);

compile-destructure-args := λ(: ctx CCContext)(: lhs AST)(: offset I64). (: (tail(
   ()
   (match lhs (
      ()
      ( (App( rst (Asc( (Var k) kt )) )) (tail(
         (let sz (max( (typecheck-sizeof kt) 8_u64 )))
         (let new-offset (-( offset (as sz I64) )))
         (let new-ctx (maybe-deref(cccontext::bind(
            ctx k kt (maybe-deref(ccfragment::local-variable new-offset))
         ))))
         (set ctx new-ctx)
         (let new-ctx-2 (maybe-deref(compile-destructure-args( ctx rst new-offset ))))
         (set ctx new-ctx-2)
      )))
      ( (Asc( (Var k) kt )) (tail(
         (let sz (max( (typecheck-sizeof kt) 8_u64 )))
         (let new-offset (-( offset (as sz I64) )))
         (let new-ctx (maybe-deref(cccontext::bind(
            ctx k kt (maybe-deref(ccfragment::local-variable new-offset))
         ))))
         (set ctx new-ctx)
         (let new-ctx-2 (maybe-deref(cccontext::bind( ctx 'offset_s (to-string new-offset) ))))
         (set ctx new-ctx-2)
      )))
      ( _ () )
   ))
   (close ctx)
)) CCContext[]);

compile-stack-call := λ(: ctx CCContext)(: function-name String)(: args AST)(: offset I64). (: (tail(
   (let r (maybe-deref(ccfragment::new())))
   (let f (maybe-deref(cccontext::lookup( ctx function-name (maybe-deref(typecheck-lookup args)) ))))
   (let push-args (maybe-deref(compile-stack-call-push-args( ctx args offset 0_i64 ))))
   (let call SNil)
   (set call (SCons( (close call) (close(SAtom '\o\scall\s_s)) )))
   (set call (SCons( (close call) (close(SAtom function-name)) )))
   (set call (SCons( (close call) (close(SAtom '\n_s)) )))
   (close r)


#         (set e-call (expr::set-prog( e-call (
#            (expr::get-frame e-args)
#            (expr::get-prog e-args)
#            (enter-function())
#            (\t 'call \s (mangle-identifier( function-name (typecheck-lookup body) )) \n)
#            (\t 'mov \s '%rbp, \s '%rsp              \n
#             \t 'pop \s '%rbp                        \n)
#            (expr::get-unframe e-args)
#         ))))
#         (set e-call (expr::set-expr( e-call (
#            (match (typecheck-sizeof (typecheck-rvalue (typecheck-lookup body))) (
#               ()
#               ( 1 'al )
#               ( 2 'ax )
#               ( 4 'eax )
#               ( 8 'rax )
#            ))
#         ))))
#         (set e-call (expr::set-context( e-call ctx )))
#         (set e-call (expr::set-offset( e-call offset )))

)) CCFragment[]);

compile-stack-call-push-args := λ(: ctx CCContext)(: args AST)(: inner-offset I64)(: outer-offset I64). (: (tail(
   (let r (maybe-deref(ccfragment::new())))
   (close r)
)) CCFragment[]);

compile-constructor := λ(: ctx CCContext)(: function-name String)(: args AST)(: offset I64). (: (tail(
   (let r (maybe-deref(ccfragment::new())))
   (print 'TODO:\sApply\sConstructor\n_s)
   (print function-name)(print '\n_s)
   (print args)
   (exit 1_u64)
   (close r)
#                        (set e1 (compile-push-rvalue( ctx r offset )))
#                        (set e2 (fragment-apply( ctx 'push (And( (typecheck-lookup e) DontChain)) (() e1) e1 )))
#                        (local sz)
#                        (set sz (typecheck-sizeof(typecheck-lookup e)))
#                        (set offset (expr::get-offset e2))
#                        (set offset (i2s(add( (inv(s2i( sz ))) (s2i offset) ))))
#                        (set e2 (expr::set-type( e2 StackVariable )))
#                        (set e2 (expr::set-offset( e2 offset )))
#                        e2
)) CCFragment[]);
