
type CCFragKV (CCKVEOF) | (CCKVSeq( CCFragKV[] , String , S ));

type CCFragment (CCFragment( CCFragKV[] , I64 , CCContext[] ));
type WrappedFragment (WrappedLocal( I64 , CCFragment )) | (WrappedGlobal( String , CCFragment )) | (WrappedUnknown( CCFragment ));

type FragList (FLEOF) | (FLSeq( FragList[] , CCFragment ));

non-zero := λ(: t CCFragKV). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( CCKVEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

non-zero := λ(: t FragList). (: (tail(
   (let r 1_u64)
   (match t (
      ()
      ( FLEOF (set r 0_u64))
      ( _ () )
   ))
   r
)) U64);

close := λ(: x CCFragment). (: (tail(
   (mov( (malloc(sizeof CCFragment)) R8 ))
   (mov( x 0_u64 (as R8 CCFragment[]) ))
   (as R8 CCFragment[])
)) CCFragment[]);

close := λ(: x CCFragKV). (: (tail(
   (mov( (malloc(sizeof CCFragKV)) R8 ))
   (mov( x 0_u64 (as R8 CCFragKV[]) ))
   (as R8 CCFragKV[])
)) CCFragKV[]);

close := λ(: x FragList). (: (tail(
   (mov( (malloc(sizeof FragList)) R8 ))
   (mov( x 0_u64 (as R8 FragList[]) ))
   (as R8 FragList[])
)) FragList[]);

close := λ(: x WrappedFragment). (: (tail(
   (mov( (malloc(sizeof WrappedFragment)) R8 ))
   (mov( x 0_u64 (as R8 WrappedFragment[]) ))
   (as R8 WrappedFragment[])
)) WrappedFragment[]);

ccfragment::new := λ . (: (tail(
   (let r (CCFragment(
      (close CCKVEOF)
      0_i64
      (cccontext::new())
   )))
   (close r)
)) CCFragment[]);

ccfragment::local-variable := λ(: offset I64) . (: (tail(
   (let r (CCFragment(
      (close(CCKVSeq(
         (close CCKVEOF)
         'offset_s
         (SAtom(to-string offset))
      )))
      0_i64
      (cccontext::new())
   )))
   (close r)
)) CCFragment[]);

ccfragment::expression := λ(: val String) . (: (tail(
   (let r (CCFragment(
      (close(CCKVSeq(
         (close CCKVEOF)
         'expression_s
         (SAtom( val ))
      )))
      0_i64
      (cccontext::new())
   )))
   (close r)
)) CCFragment[]);

ccfragment::get := λ(: e CCFragment)(: k String). (: (tail(
   (let r SNil)
   (close r)
)) S[]);

ccfragment::set := λ(: e CCFragment)(: k String)(: v S). (: (tail(
   ()
   (close e)
)) CCFragment[]);

ccfragment::get-context := λ(: e CCFragment) . (: (tail(
   (let ctx (.1( e )))
   ctx
)) CCContext[]);

ccfragment::set-context := λ(: e CCFragment)(: ctx CCContext). (: (tail(
   (match e (
      ()
      ( (CCFragment( e-kvs (*( e-offset e-ctx )) )) (
         (set e (CCFragment( (close e-kvs) e-offset (close ctx) ))) 
      ))
   ))
   (close e)
)) CCFragment[]);

ccfragment::get-offset := λ(: e CCFragment). (: (tail(
   ()
   0_i64
)) I64);

ccfragment::set-offset := λ(: e CCFragment)(: offset I64). (: (tail(
   ()
   (close e)
)) CCFragment[]);

ccfragment::chain := λ(: l CCFragment)(: r CCFragment). (: (tail(
   ()
   (close l)
)) CCFragment[]);

fragment-apply := λ(: ctx CCContext)(: k String)(: kt Type)(: args FragList)(: sloc AST). (: (tail(
   (let e-proto (maybe-deref(ccfragment::new())))
   (print 'Fragment\sApply\s_s)(print k)(print kt)(print '\n_s)
   (let arrow (maybe-deref(cccontext::lookup( ctx k kt sloc ))))
   (let chain True_u8)
   (match (maybe-deref(typecheck-slot( kt 'DontChain_s ))) (
      ()
      ( (TGround( 'DontChain_s _ )) (set chain False_u8) )
      ( _ () )
   ))
   (let return (maybe-deref(fragment-apply-direct( arrow args e-proto chain ))))
   (close return)
)) CCFragment[]);

fragment-apply-direct := λ(: arrow CCFragment)(: args FragList)(: e CCFragment)(: chain U8). (: (tail(
   (let r (maybe-deref(fragment-chain( args e ))))
   (close r)
)) CCFragment[]);

fragment-chain := λ(: fragment-ctx FragList)(: e CCFragment). (: (tail(
   ()
   (close e)
)) CCFragment[]);
#   (assert-typeof( 'fragment-chain::fragment-ctx fragment-ctx List<[Atom,StrictExpr]> ))
#   (assert-typeof( 'fragment-chain::e e StrictExpr ))
#   (while fragment-ctx (tail(
#      (set e (expr::chain( (tail(tail fragment-ctx)) e )))
#      (set fragment-ctx (head fragment-ctx))
#   )))
#   e
#));
