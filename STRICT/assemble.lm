
assemble-text-section                    := (: SNil S);
assemble-data-section                    := (: SNil S);
assemble-final                           := '_s;
assemble-argv-referenced                 := False_u8;

compile := λ(). (: (tail(
   (let global-ctx (maybe-deref(cccontext::new())))
   (let preview-program ast-parsed-program)
   (while (non-zero preview-program) (match preview-program (
      ()
      ( (Seq( rst (Glb( k rhs )) )) (tail(
         (if (==( k 'main_s )) (set assemble-argv-referenced True_u8) ())
         (let global-ctx-2 (maybe-deref(cccontext::bind(
            global-ctx
            k
            (maybe-deref(typecheck-lookup rhs))
            (maybe-deref(ccfragment::new()))
         ))))
         (set global-ctx global-ctx-2)
         (set preview-program rst)
      )))
      ( (Seq( rst (Fragment( k rhs )) )) (tail(
         (let global-ctx-2 (maybe-deref(cccontext::bind(
            global-ctx
            k
            (maybe-deref(typecheck-lookup rhs))
            (maybe-deref(ccfragment::new()))
         ))))
         (set global-ctx global-ctx-2)
         (set preview-program rst)
      )))
      ( (Seq( rst (ASTType( lhs rhs )) )) (tail(
         (let global-ctx-2 (maybe-deref(compile-type( global-ctx lhs rhs ))))
         (set global-ctx global-ctx-2)
         (set preview-program rst)
      )))
      ( (Seq( rst _ )) (
         (set preview-program rst)
      ))
   )))
   (let program ast-parsed-program)
   (while (non-zero preview-program) (match preview-program (
      ()
      ( (Seq( rst (Glb( k rhs )) )) (tail(
         (compile-global( global-ctx k rhs ))
         (set program rst)
      )))
      ( (Seq( rst e )) (tail(
         (compile-global( global-ctx e ))
         (set program rst)
      )))
   )))
   (compile-finish())
   (compile-write())
)) Nil);

compile-type := λ(: ctx CCContext)(: lhs AST)(: rhs AST). (: (tail(
   ()
   (close ctx)
)) CCContext[]);

compile-finish := λ. (: (tail(
   (let output SNil)
   (set output (SCons( (close output) (compile-program-header()) )))
   (set output (SCons( (close output) (compile-before-main()) )))
   (if (==( assemble-argv-referenced True_u8 )) (
      (set output (SCons(
         (close output)
         (compile-argv-text-header())
      )))
   ) ())
   (set output (SCons( (close output) (compile-exit-cleanup()) )))
   (set output (SCons( (close output) (close assemble-text-section) )))
   (set output (SCons( (close output) (close assemble-data-section) )))
   (if (==( assemble-argv-referenced True_u8 )) (
      (set output (SCons(
         (close output)
         (compile-argv-data-header())
      )))
   ) ())
   (set assemble-final (clone-rope output))
)) Nil);

compile-write := λ. (: (tail(
   ()
   (write-file( config-target assemble-final ))
)) Nil);

compile-destructure-args := λ(: ctx CCContext)(: lhs AST). (: (tail(
   ()
   (close ctx)
)) CCContext[]);

compile-argv-text-header := λ . (: (tail(
   (let r SNil)
   (set r (SCons( (close r) (close(SAtom '\tpop\s%r15\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tmov\s$argc,\s%r14\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tmov\s%r15,\s0\[%r14\]\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tmov\s$argv,\s%r14\n_s)) )))
   (set r (SCons( (close r) (close(SAtom 'argv_populate_loop_begin:\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tcmp\s$0,\s%r15\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tje\sargv_populate_loop_end\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tpop\s%r13\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tmov\s%r13,\s0\[%r14\]\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tadd\s$8,\s%r14\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tdec\s%r15\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tjmp\sargv_populate_loop_begin\n_s)) )))
   (set r (SCons( (close r) (close(SAtom 'argv_populate_loop_end:\n_s)) )))
   (close r)
)) S[]);

compile-argv-data-header := λ . (: (tail(
   (let r SNil)
   (set r (SCons( (close r) (close(SAtom 'argc:\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\t.zero\s8\n_s)) )))
   (set r (SCons( (close r) (close(SAtom 'argv:\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\t.zero\s8192\n_s)) )))
   (close r)
)) S[]);

compile-exit-cleanup := λ . (: (tail(
   (let r SNil)
   (set r (SCons( (close r) (close(SAtom '\tmov\s$60,\s%rax\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tmov\s$0,\s%rdi\n_s)) )))
   (set r (SCons( (close r) (close(SAtom '\tsyscall\n_s)) )))
   (close r)
)) S[]);

